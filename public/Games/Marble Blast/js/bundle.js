(function iife() {
(function () {
	'use strict';

	const state = {
	    modification: null,
	    level: null,
	    menu: null
	};

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Implementation of a quaternion. */
	class Quaternion {
	    constructor(x = 0, y = 0, z = 0, w = 1) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    /** Sets x, y, z, w properties of this quaternion. */
	    set(x, y, z, w) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	        return this;
	    }
	    /** Creates a new Quaternion with identical x, y, z and w properties to this one. */
	    clone() {
	        return new Quaternion(this.x, this.y, this.z, this.w);
	    }
	    /** Copies the x, y, z and w properties of `q` into this quaternion. */
	    copy(quaternion) {
	        this.x = quaternion.x;
	        this.y = quaternion.y;
	        this.z = quaternion.z;
	        this.w = quaternion.w;
	        return this;
	    }
	    /** Sets this quaternion from the rotation specified by Euler angle. */
	    setFromEuler(euler) {
	        const x = euler.x, y = euler.y, z = euler.z, order = euler.order;
	        // http://www.mathworks.com/matlabcentral/fileexchange/
	        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	        //	content/SpinCalc.m
	        const cos = Math.cos;
	        const sin = Math.sin;
	        const c1 = cos(x / 2);
	        const c2 = cos(y / 2);
	        const c3 = cos(z / 2);
	        const s1 = sin(x / 2);
	        const s2 = sin(y / 2);
	        const s3 = sin(z / 2);
	        switch (order) {
	            case "XYZ":
	                this.x = s1 * c2 * c3 + c1 * s2 * s3;
	                this.y = c1 * s2 * c3 - s1 * c2 * s3;
	                this.z = c1 * c2 * s3 + s1 * s2 * c3;
	                this.w = c1 * c2 * c3 - s1 * s2 * s3;
	                break;
	            case "YXZ":
	                this.x = s1 * c2 * c3 + c1 * s2 * s3;
	                this.y = c1 * s2 * c3 - s1 * c2 * s3;
	                this.z = c1 * c2 * s3 - s1 * s2 * c3;
	                this.w = c1 * c2 * c3 + s1 * s2 * s3;
	                break;
	            case "ZXY":
	                this.x = s1 * c2 * c3 - c1 * s2 * s3;
	                this.y = c1 * s2 * c3 + s1 * c2 * s3;
	                this.z = c1 * c2 * s3 + s1 * s2 * c3;
	                this.w = c1 * c2 * c3 - s1 * s2 * s3;
	                break;
	            case "ZYX":
	                this.x = s1 * c2 * c3 - c1 * s2 * s3;
	                this.y = c1 * s2 * c3 + s1 * c2 * s3;
	                this.z = c1 * c2 * s3 - s1 * s2 * c3;
	                this.w = c1 * c2 * c3 + s1 * s2 * s3;
	                break;
	            case "YZX":
	                this.x = s1 * c2 * c3 + c1 * s2 * s3;
	                this.y = c1 * s2 * c3 + s1 * c2 * s3;
	                this.z = c1 * c2 * s3 - s1 * s2 * c3;
	                this.w = c1 * c2 * c3 - s1 * s2 * s3;
	                break;
	            case "XZY":
	                this.x = s1 * c2 * c3 - c1 * s2 * s3;
	                this.y = c1 * s2 * c3 - s1 * c2 * s3;
	                this.z = c1 * c2 * s3 + s1 * s2 * c3;
	                this.w = c1 * c2 * c3 + s1 * s2 * s3;
	                break;
	            default:
	                console.warn("Quaternion: .setFromEuler() encountered an unknown order: " + order);
	        }
	        return this;
	    }
	    /** Sets this quaternion from rotation specified by `axis` and `angle`. Axis is assumed to be normalized, angle is in radians. */
	    setFromAxisAngle(axis, angle) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	        // assumes axis is normalized
	        const halfAngle = angle / 2, s = Math.sin(halfAngle);
	        this.x = axis.x * s;
	        this.y = axis.y * s;
	        this.z = axis.z * s;
	        this.w = Math.cos(halfAngle);
	        return this;
	    }
	    /** Sets this quaternion from rotation component of `m`. */
	    setFromRotationMatrix(m) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
	        if (trace > 0) {
	            const s = 0.5 / Math.sqrt(trace + 1.0);
	            this.w = 0.25 / s;
	            this.x = (m32 - m23) * s;
	            this.y = (m13 - m31) * s;
	            this.z = (m21 - m12) * s;
	        }
	        else if (m11 > m22 && m11 > m33) {
	            const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
	            this.w = (m32 - m23) / s;
	            this.x = 0.25 * s;
	            this.y = (m12 + m21) / s;
	            this.z = (m13 + m31) / s;
	        }
	        else if (m22 > m33) {
	            const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
	            this.w = (m13 - m31) / s;
	            this.x = (m12 + m21) / s;
	            this.y = 0.25 * s;
	            this.z = (m23 + m32) / s;
	        }
	        else {
	            const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
	            this.w = (m21 - m12) / s;
	            this.x = (m13 + m31) / s;
	            this.y = (m23 + m32) / s;
	            this.z = 0.25 * s;
	        }
	        return this;
	    }
	    /** Sets this quaternion to the rotation required to rotate direction vector `vFrom` to direction vector `vTo`. `vFrom` and `vTo` are assumed to be normalized. */
	    setFromUnitVectors(vFrom, vTo) {
	        // assumes direction vectors vFrom and vTo are normalized
	        let r = vFrom.dot(vTo) + 1;
	        if (r < Number.EPSILON) {
	            // vFrom and vTo point in opposite directions
	            r = 0;
	            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	                this.x = -vFrom.y;
	                this.y = vFrom.x;
	                this.z = 0;
	                this.w = r;
	            }
	            else {
	                this.x = 0;
	                this.y = -vFrom.z;
	                this.z = vFrom.y;
	                this.w = r;
	            }
	        }
	        else {
	            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
	            this.x = vFrom.y * vTo.z - vFrom.z * vTo.y;
	            this.y = vFrom.z * vTo.x - vFrom.x * vTo.z;
	            this.z = vFrom.x * vTo.y - vFrom.y * vTo.x;
	            this.w = r;
	        }
	        return this.normalize();
	    }
	    /** Returns the angle between this quaternion and quaternion `q` in radians. */
	    angleTo(q) {
	        return 2 * Math.acos(Math.abs(Util.clamp(this.dot(q), -1, 1)));
	    }
	    /** Rotates this quaternion by a given angular step to the defined quaternion `q`. The method ensures that the final quaternion will not overshoot `q`. */
	    rotateTowards(q, step) {
	        const angle = this.angleTo(q);
	        if (angle === 0)
	            return this;
	        const t = Math.min(1, step / angle);
	        this.slerp(q, t);
	        return this;
	    }
	    /** Sets this quaternion to the identity quaternion; that is, to the quaternion that represents "no rotation". */
	    identity() {
	        return this.set(0, 0, 0, 1);
	    }
	    /** Inverts this quaternion - calculates the conjugate. The quaternion is assumed to have unit length. */
	    invert() {
	        // quaternion is assumed to have unit length
	        return this.conjugate();
	    }
	    /** Returns the rotational conjugate of this quaternion. The conjugate of a quaternion represents the same rotation in the opposite direction about the rotational axis. */
	    conjugate() {
	        this.x *= -1;
	        this.y *= -1;
	        this.z *= -1;
	        return this;
	    }
	    /** Calculates the dot product of quaternions `v` and this one. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    }
	    /** Computes the squared Euclidean length (straight-line length) of this quaternion, considered as a 4 dimensional vector. */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	    }
	    /** Computes the Euclidean length (straight-line length) of this quaternion, considered as a 4 dimensional vector. */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    }
	    /** Normalizes this quaternion - that is, calculated the quaternion that performs the same rotation as this one, but has length equal to 1. */
	    normalize() {
	        let l = this.length();
	        if (l === 0) {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	            this.w = 1;
	        }
	        else {
	            l = 1 / l;
	            this.x = this.x * l;
	            this.y = this.y * l;
	            this.z = this.z * l;
	            this.w = this.w * l;
	        }
	        return this;
	    }
	    /** Multiplies this quaternion by `q`. */
	    multiply(q) {
	        return this.multiplyQuaternions(this, q);
	    }
	    /** Pre-multiplies this quaternion by `q`. */
	    premultiply(q) {
	        return this.multiplyQuaternions(q, this);
	    }
	    /** Sets this quaternion to `a` x `b`. */
	    multiplyQuaternions(a, b) {
	        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	        const qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
	        const qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
	        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	        return this;
	    }
	    /** Handles the spherical linear interpolation between quaternions. t represents the amount of rotation between this quaternion (where `t` is 0) and `qb` (where `t` is 1). This quaternion is set to the result. */
	    slerp(qb, t) {
	        if (t === 0)
	            return this;
	        if (t === 1)
	            return this.copy(qb);
	        const x = this.x, y = this.y, z = this.z, w = this.w;
	        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	        let cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
	        if (cosHalfTheta < 0) {
	            this.w = -qb.w;
	            this.x = -qb.x;
	            this.y = -qb.y;
	            this.z = -qb.z;
	            cosHalfTheta = -cosHalfTheta;
	        }
	        else {
	            this.copy(qb);
	        }
	        if (cosHalfTheta >= 1.0) {
	            this.w = w;
	            this.x = x;
	            this.y = y;
	            this.z = z;
	            return this;
	        }
	        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
	        if (sqrSinHalfTheta <= Number.EPSILON) {
	            const s = 1 - t;
	            this.w = s * w + t * this.w;
	            this.x = s * x + t * this.x;
	            this.y = s * y + t * this.y;
	            this.z = s * z + t * this.z;
	            this.normalize();
	            return this;
	        }
	        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
	        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	        this.w = w * ratioA + this.w * ratioB;
	        this.x = x * ratioA + this.x * ratioB;
	        this.y = y * ratioA + this.y * ratioB;
	        this.z = z * ratioA + this.z * ratioB;
	        return this;
	    }
	    /** Performs a spherical linear interpolation between the given quaternions and stores the result in this quaternion. */
	    slerpQuaternions(qa, qb, t) {
	        return this.copy(qa).slerp(qb, t);
	    }
	    /** Sets this quaternion to a uniformly random, normalized quaternion. */
	    random() {
	        // Derived from http://planning.cs.uiuc.edu/node198.html
	        // Note, this source uses w, x, y, z ordering,
	        // so we swap the order below.
	        const u1 = Math.random();
	        const sqrt1u1 = Math.sqrt(1 - u1);
	        const sqrtu1 = Math.sqrt(u1);
	        const u2 = 2 * Math.PI * Math.random();
	        const u3 = 2 * Math.PI * Math.random();
	        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
	    }
	    /** Compares the x, y, z and w properties of v to the equivalent properties of this quaternion to determine if they represent the same rotation. */
	    equals(quaternion) {
	        return (quaternion.x === this.x && quaternion.y === this.y && quaternion.z === this.z && quaternion.w === this.w);
	    }
	    /** Sets this quaternion's x, y, z and w properties from an array. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        this.w = array[offset + 3];
	        return this;
	    }
	    /** Returns the numerical elements of this quaternion in an array of format [x, y, z, w]. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.w;
	        return array;
	    }
	}

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Class representing a 3D vector. */
	class Vector3 {
	    constructor(x = 0, y = 0, z = 0) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	    }
	    /** Sets the x, y and z components of this vector. */
	    set(x, y, z) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        return this;
	    }
	    /** Set the x, y and z values of this vector both equal to scalar. */
	    setScalar(scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        this.z = scalar;
	        return this;
	    }
	    /** Replace this vector's x value with x. */
	    setX(x) {
	        this.x = x;
	        return this;
	    }
	    /** Replace this vector's y value with y. */
	    setY(y) {
	        this.y = y;
	        return this;
	    }
	    /** Replace this vector's z value with z. */
	    setZ(z) {
	        this.z = z;
	        return this;
	    }
	    /** If index equals 0 set x to value. If index equals 1 set y to value. If index equals 2 set z to value */
	    setComponent(index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            case 2:
	                this.z = value;
	                break;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	        return this;
	    }
	    /** If index equals 0 returns the x value. If index equals 1 returns the y value. If index equals 2 returns the z value. */
	    getComponent(index) {
	        switch (index) {
	            case 0:
	                return this.x;
	            case 1:
	                return this.y;
	            case 2:
	                return this.z;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	    }
	    /** Returns a new vector3 with the same x, y and z values as this one. */
	    clone() {
	        return new Vector3(this.x, this.y, this.z);
	    }
	    /** Copies the values of the passed vector3's x, y and z properties to this vector3. */
	    copy(v) {
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        return this;
	    }
	    /** Adds v to this vector. */
	    add(v) {
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;
	        return this;
	    }
	    /** Adds the scalar value s to this vector's x, y and z values. */
	    addScalar(s) {
	        this.x += s;
	        this.y += s;
	        this.z += s;
	        return this;
	    }
	    /** Sets this vector to a + b. */
	    addVectors(a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        return this;
	    }
	    /** Adds the multiple of v and s to this vector. */
	    addScaledVector(v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        this.z += v.z * s;
	        return this;
	    }
	    /** Subtracts v from this vector. */
	    sub(v) {
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        return this;
	    }
	    /** Subtracts s from this vector's x, y and z components. */
	    subScalar(s) {
	        this.x -= s;
	        this.y -= s;
	        this.z -= s;
	        return this;
	    }
	    /** Sets this vector to a - b. */
	    subVectors(a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        return this;
	    }
	    /** Multiplies this vector by v. */
	    multiply(v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z;
	        return this;
	    }
	    /** Multiplies this vector by scalar s. */
	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        this.z *= scalar;
	        return this;
	    }
	    /** Sets this vector equal to a * b, component-wise. */
	    multiplyVectors(a, b) {
	        this.x = a.x * b.x;
	        this.y = a.y * b.y;
	        this.z = a.z * b.z;
	        return this;
	    }
	    /** Applies euler transform to this vector by converting the Euler object to a Quaternion and applying. */
	    applyEuler(euler) {
	        return this.applyQuaternion(_quaternion.setFromEuler(euler));
	    }
	    /** Applies a rotation specified by an axis and an angle to this vector. */
	    applyAxisAngle(axis, angle) {
	        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
	    }
	    /** Multiplies this vector by m. */
	    applyMatrix3(m) {
	        const x = this.x, y = this.y, z = this.z;
	        const e = m.elements;
	        this.x = e[0] * x + e[3] * y + e[6] * z;
	        this.y = e[1] * x + e[4] * y + e[7] * z;
	        this.z = e[2] * x + e[5] * y + e[8] * z;
	        return this;
	    }
	    /** Multiplies this vector by normal matrix m and normalizes the result. */
	    applyNormalMatrix(m) {
	        return this.applyMatrix3(m).normalize();
	    }
	    /** Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective. */
	    applyMatrix4(m) {
	        const x = this.x, y = this.y, z = this.z;
	        const e = m.elements;
	        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
	        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
	        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
	        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
	        return this;
	    }
	    /** Applies a Quaternion transform to this vector. */
	    applyQuaternion(q) {
	        const x = this.x, y = this.y, z = this.z;
	        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	        // calculate quat * vector
	        const ix = qw * x + qy * z - qz * y;
	        const iy = qw * y + qz * x - qx * z;
	        const iz = qw * z + qx * y - qy * x;
	        const iw = -qx * x - qy * y - qz * z;
	        // calculate result * inverse quat
	        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	        return this;
	    }
	    /** Transforms the direction of this vector by a matrix (the upper left 3 x 3 subset of a m) and then normalizes the result. */
	    transformDirection(m) {
	        // input: Matrix4 affine matrix
	        // vector interpreted as a direction
	        const x = this.x, y = this.y, z = this.z;
	        const e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z;
	        this.y = e[1] * x + e[5] * y + e[9] * z;
	        this.z = e[2] * x + e[6] * y + e[10] * z;
	        return this.normalize();
	    }
	    /** Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective. */
	    divide(v) {
	        this.x /= v.x;
	        this.y /= v.y;
	        this.z /= v.z;
	        return this;
	    }
	    /** Divides this vector by scalar s. */
	    divideScalar(scalar) {
	        return this.multiplyScalar(1 / scalar);
	    }
	    /** If this vector's x, y or z value is greater than v's x, y or z value, replace that value with the corresponding min value. */
	    min(v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);
	        return this;
	    }
	    /** If this vector's x, y or z value is less than v's x, y or z value, replace that value with the corresponding max value. */
	    max(v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);
	        return this;
	    }
	    /** If this vector's x, y or z value is greater than the max vector's x, y or z value, it is replaced by the corresponding value. If this vector's x, y or z value is less than the min vector's x, y or z value, it is replaced by the corresponding value. */
	    clamp(min, max) {
	        // assumes min < max, componentwise
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        this.z = Math.max(min.z, Math.min(max.z, this.z));
	        return this;
	    }
	    /** If this vector's x, y or z values are greater than the max value, they are replaced by the max value. If this vector's x, y or z values are less than the min value, they are replaced by the min value. */
	    clampScalar(minVal, maxVal) {
	        this.x = Math.max(minVal, Math.min(maxVal, this.x));
	        this.y = Math.max(minVal, Math.min(maxVal, this.y));
	        this.z = Math.max(minVal, Math.min(maxVal, this.z));
	        return this;
	    }
	    /** If this vector's length is greater than the max value, the vector will be scaled down so its length is the max value. If this vector's length is less than the min value, the vector will be scaled up so its length is the min value. */
	    clampLength(min, max) {
	        const length = this.length();
	        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	    }
	    /** The components of this vector are rounded down to the nearest integer value. */
	    floor() {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        this.z = Math.floor(this.z);
	        return this;
	    }
	    /** The x, y and z components of this vector are rounded up to the nearest integer value. */
	    ceil() {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        this.z = Math.ceil(this.z);
	        return this;
	    }
	    /** The components of this vector are rounded to the nearest integer value. */
	    round() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        this.z = Math.round(this.z);
	        return this;
	    }
	    /** The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value. */
	    roundToZero() {
	        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
	        return this;
	    }
	    /** Inverts this vector - i.e. sets x = -x, y = -y and z = -z. */
	    negate() {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        return this;
	    }
	    /** Calculate the dot product of this vector and v. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z;
	    }
	    /** Computes the square of the Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z). */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y + this.z * this.z;
	    }
	    /** Computes the Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z). */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	    }
	    /** Computes the Manhattan length of this vector. */
	    manhattanLength() {
	        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	    }
	    /** Convert this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1. */
	    normalize() {
	        return this.divideScalar(this.length() || 1);
	    }
	    /** Set this vector to a vector with the same direction as this one, but length l. */
	    setLength(length) {
	        return this.normalize().multiplyScalar(length);
	    }
	    /** Linearly interpolate between this vector and v, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v. */
	    lerp(v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        this.z += (v.z - this.z) * alpha;
	        return this;
	    }
	    /** Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2. */
	    lerpVectors(v1, v2, alpha) {
	        this.x = v1.x + (v2.x - v1.x) * alpha;
	        this.y = v1.y + (v2.y - v1.y) * alpha;
	        this.z = v1.z + (v2.z - v1.z) * alpha;
	        return this;
	    }
	    /** Sets this vector to cross product of itself and v. */
	    cross(v) {
	        return this.crossVectors(this, v);
	    }
	    /** Sets this vector to cross product of a and b. */
	    crossVectors(a, b) {
	        const ax = a.x, ay = a.y, az = a.z;
	        const bx = b.x, by = b.y, bz = b.z;
	        this.x = ay * bz - az * by;
	        this.y = az * bx - ax * bz;
	        this.z = ax * by - ay * bx;
	        return this;
	    }
	    /** Projects this vector onto v. */
	    projectOnVector(v) {
	        const denominator = v.lengthSq();
	        if (denominator === 0)
	            return this.set(0, 0, 0);
	        const scalar = v.dot(this) / denominator;
	        return this.copy(v).multiplyScalar(scalar);
	    }
	    /** Projects this vector onto a plane by subtracting this vector projected onto the plane's normal from this vector. */
	    projectOnPlane(planeNormal) {
	        _vector.copy(this).projectOnVector(planeNormal);
	        return this.sub(_vector);
	    }
	    /** Reflect this vector off of plane orthogonal to normal. Normal is assumed to have unit length. */
	    reflect(normal) {
	        // reflect incident vector off plane orthogonal to normal
	        // normal is assumed to have unit length
	        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
	    }
	    /** Returns the angle between this vector and vector v in radians. */
	    angleTo(v) {
	        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	        if (denominator === 0)
	            return Math.PI / 2;
	        const theta = this.dot(v) / denominator;
	        // clamp, to handle numerical problems
	        return Math.acos(Util.clamp(theta, -1, 1));
	    }
	    /** Computes the distance from this vector to v. */
	    distanceTo(v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    }
	    /** Computes the squared distance from this vector to v. */
	    distanceToSquared(v) {
	        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	        return dx * dx + dy * dy + dz * dz;
	    }
	    /** Computes the Manhattan distance from this vector to v. */
	    manhattanDistanceTo(v) {
	        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	    }
	    /** Sets this vector to the position elements of the transformation matrix m. */
	    setFromMatrixPosition(m) {
	        const e = m.elements;
	        this.x = e[12];
	        this.y = e[13];
	        this.z = e[14];
	        return this;
	    }
	    /** Sets this vector to the scale elements of the transformation matrix m. */
	    setFromMatrixScale(m) {
	        const sx = this.setFromMatrixColumn(m, 0).length();
	        const sy = this.setFromMatrixColumn(m, 1).length();
	        const sz = this.setFromMatrixColumn(m, 2).length();
	        this.x = sx;
	        this.y = sy;
	        this.z = sz;
	        return this;
	    }
	    /** Sets this vector's x, y and z components from index column of matrix. */
	    setFromMatrixColumn(m, index) {
	        return this.fromArray(m.elements, index * 4);
	    }
	    /** Sets this vector's x, y and z components from index column of matrix. */
	    setFromMatrix3Column(m, index) {
	        return this.fromArray(m.elements, index * 3);
	    }
	    /** Returns true if the components of this vector and v are strictly equal; false otherwise. */
	    equals(v) {
	        return v.x === this.x && v.y === this.y && v.z === this.z;
	    }
	    /** Sets this vector's x value to be array[offset + 0], y value to be array[offset + 1] and z value to be array[offset + 2]. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        return this;
	    }
	    /** Returns an array [x, y, z], or copies x, y and z into the provided array. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        return array;
	    }
	    /** Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1. */
	    random() {
	        this.x = Math.random();
	        this.y = Math.random();
	        this.z = Math.random();
	        return this;
	    }
	    /** Sets this vector to a uniformly random point on a unit sphere. */
	    randomDirection() {
	        // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
	        const u = (Math.random() - 0.5) * 2;
	        const t = Math.random() * Math.PI * 2;
	        const f = Math.sqrt(1 - u ** 2);
	        this.x = f * Math.cos(t);
	        this.y = f * Math.sin(t);
	        this.z = u;
	        return this;
	    }
	    *[Symbol.iterator]() {
	        yield this.x;
	        yield this.y;
	        yield this.z;
	    }
	}
	const _vector = new Vector3();
	const _quaternion = new Quaternion();

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Represents an axis-aligned bounding box (AABB) in 3D space. */
	class Box3 {
	    constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
	        this.min = min;
	        this.max = max;
	    }
	    /** Sets the lower and upper (x, y, z) boundaries of this box. */
	    set(min, max) {
	        this.min.copy(min);
	        this.max.copy(max);
	        return this;
	    }
	    /** Sets the upper and lower bounds of this box to include all of the data in `array`. */
	    setFromArray(array) {
	        let minX = +Infinity;
	        let minY = +Infinity;
	        let minZ = +Infinity;
	        let maxX = -Infinity;
	        let maxY = -Infinity;
	        let maxZ = -Infinity;
	        for (let i = 0, l = array.length; i < l; i += 3) {
	            const x = array[i];
	            const y = array[i + 1];
	            const z = array[i + 2];
	            if (x < minX)
	                minX = x;
	            if (y < minY)
	                minY = y;
	            if (z < minZ)
	                minZ = z;
	            if (x > maxX)
	                maxX = x;
	            if (y > maxY)
	                maxY = y;
	            if (z > maxZ)
	                maxZ = z;
	        }
	        this.min.set(minX, minY, minZ);
	        this.max.set(maxX, maxY, maxZ);
	        return this;
	    }
	    /** Sets the upper and lower bounds of this box to include all of the points in `points`. */
	    setFromPoints(points) {
	        this.makeEmpty();
	        for (let i = 0, il = points.length; i < il; i++) {
	            this.expandByPoint(points[i]);
	        }
	        return this;
	    }
	    /** Centers this box on `center` and sets this box's width, height and depth to the values specified in `size`. */
	    setFromCenterAndSize(center, size) {
	        const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
	        this.min.copy(center).sub(halfSize);
	        this.max.copy(center).add(halfSize);
	        return this;
	    }
	    /** Returns a new Box3 with the same min and max as this one. */
	    clone() {
	        return new Box3().copy(this);
	    }
	    /** Copies the min and max from `box` to this box. */
	    copy(box) {
	        this.min.copy(box.min);
	        this.max.copy(box.max);
	        return this;
	    }
	    /** Makes this box empty. */
	    makeEmpty() {
	        this.min.x = this.min.y = this.min.z = +Infinity;
	        this.max.x = this.max.y = this.max.z = -Infinity;
	        return this;
	    }
	    /** Returns true if this box includes zero points within its bounds. Note that a box with equal lower and upper bounds still includes one point, the one both bounds share. */
	    isEmpty() {
	        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	    }
	    /** Returns the center point of the box as a Vector3. */
	    getCenter(target) {
	        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	    }
	    /** Returns the width, height and depth of this box. */
	    getSize(target) {
	        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	    }
	    /** Expands the boundaries of this box to include point. */
	    expandByPoint(point) {
	        this.min.min(point);
	        this.max.max(point);
	        return this;
	    }
	    /** Expands this box equilaterally by vector. The width of this box will be expanded by the x component of vector in both directions. The height of this box will be expanded by the y component of vector in both directions. The depth of this box will be expanded by the z component of vector in both directions. */
	    expandByVector(vector) {
	        this.min.sub(vector);
	        this.max.add(vector);
	        return this;
	    }
	    /** Expands each dimension of the box by scalar. If negative, the dimensions of the box will be contracted. */
	    expandByScalar(scalar) {
	        this.min.addScalar(-scalar);
	        this.max.addScalar(scalar);
	        return this;
	    }
	    /** Returns true if the specified point lies within or on the boundaries of this box. */
	    containsPoint(point) {
	        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
	    }
	    /** Returns true if this box includes the entirety of box. If this and box are identical, this function also returns true. */
	    containsBox(box) {
	        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	    }
	    /** Returns a point as a proportion of this box's width, height and depth. */
	    getParameter(point, target) {
	        // This can potentially have a divide by zero if the box
	        // has a size dimension of 0.
	        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	    }
	    /** Determines whether or not this box intersects box. */
	    intersectsBox(box) {
	        // using 6 splitting planes to rule out intersections.
	        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	    }
	    /** Clamps the point within the bounds of this box. */
	    clampPoint(point, target) {
	        return target.copy(point).clamp(this.min, this.max);
	    }
	    /** Returns the distance from any edge of this box to the specified point. If the point lies inside of this box, the distance will be 0. */
	    distanceToPoint(point) {
	        const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
	        return clampedPoint.sub(point).length();
	    }
	    /** Computes the intersection of this and `box`, setting the upper bound of this box to the lesser of the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' lower bounds. If there's no overlap, makes this box empty. */
	    intersect(box) {
	        this.min.max(box.min);
	        this.max.min(box.max);
	        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	        if (this.isEmpty())
	            this.makeEmpty();
	        return this;
	    }
	    /** Computes the union of this box and `box`, setting the upper bound of this box to the greater of the two boxes' upper bounds and the lower bound of this box to the lesser of the two boxes' lower bounds. */
	    union(box) {
	        this.min.min(box.min);
	        this.max.max(box.max);
	        return this;
	    }
	    /** Transforms this Box3 with the supplied matrix. */
	    applyMatrix4(matrix) {
	        // transform of empty box is an empty box.
	        if (this.isEmpty())
	            return this;
	        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
	        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
	        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
	        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
	        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
	        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
	        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
	        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
	        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
	        this.setFromPoints(_points);
	        return this;
	    }
	    /** Adds `offset` to both the upper and lower bounds of this box, effectively moving this box offset units in 3D space. */
	    translate(offset) {
	        this.min.add(offset);
	        this.max.add(offset);
	        return this;
	    }
	    /** Returns true if this box and `box` share the same lower and upper bounds. */
	    equals(box) {
	        return box.min.equals(this.min) && box.max.equals(this.max);
	    }
	}
	const _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
	const _vector$1 = new Vector3();

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** A class representing a 3x3 matrix. Defaults to the identity matrix. */
	class Matrix3 {
	    constructor() {
	        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    }
	    /** Sets the 3x3 matrix values to the given row-major sequence of values. */
	    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	        const te = this.elements;
	        te[0] = n11;
	        te[1] = n21;
	        te[2] = n31;
	        te[3] = n12;
	        te[4] = n22;
	        te[5] = n32;
	        te[6] = n13;
	        te[7] = n23;
	        te[8] = n33;
	        return this;
	    }
	    /** Resets this matrix to the 3x3 identity matrix. */
	    identity() {
	        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	        return this;
	    }
	    /** Copies the elements of matrix m into this matrix. */
	    copy(m) {
	        const te = this.elements;
	        const me = m.elements;
	        te[0] = me[0];
	        te[1] = me[1];
	        te[2] = me[2];
	        te[3] = me[3];
	        te[4] = me[4];
	        te[5] = me[5];
	        te[6] = me[6];
	        te[7] = me[7];
	        te[8] = me[8];
	        return this;
	    }
	    /** Extracts the basis of this matrix into the three axis vectors provided. */
	    extractBasis(xAxis, yAxis, zAxis) {
	        xAxis.setFromMatrix3Column(this, 0);
	        yAxis.setFromMatrix3Column(this, 1);
	        zAxis.setFromMatrix3Column(this, 2);
	        return this;
	    }
	    /** Set this matrix to the upper 3x3 matrix of the Matrix4 `m`. */
	    setFromMatrix4(m) {
	        const me = m.elements;
	        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
	        return this;
	    }
	    /** Post-multiplies this matrix by `m`. */
	    multiply(m) {
	        return this.multiplyMatrices(this, m);
	    }
	    /** Pre-multiplies this matrix by `m`. */
	    premultiply(m) {
	        return this.multiplyMatrices(m, this);
	    }
	    /** Sets this matrix to `a` x `b`. */
	    multiplyMatrices(a, b) {
	        const ae = a.elements;
	        const be = b.elements;
	        const te = this.elements;
	        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
	        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
	        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
	        const b11 = be[0], b12 = be[3], b13 = be[6];
	        const b21 = be[1], b22 = be[4], b23 = be[7];
	        const b31 = be[2], b32 = be[5], b33 = be[8];
	        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
	        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
	        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
	        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
	        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
	        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
	        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
	        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
	        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
	        return this;
	    }
	    /** Multiplies every component of the matrix by the scalar value `s`. */
	    multiplyScalar(s) {
	        const te = this.elements;
	        te[0] *= s;
	        te[3] *= s;
	        te[6] *= s;
	        te[1] *= s;
	        te[4] *= s;
	        te[7] *= s;
	        te[2] *= s;
	        te[5] *= s;
	        te[8] *= s;
	        return this;
	    }
	    /** Adds `m` to this matrix, component-wise. */
	    add(m) {
	        for (let i = 0; i < 9; i++)
	            this.elements[i] += m.elements[i];
	        return this;
	    }
	    /** Subtracts `m` from this matrix, component-wise. */
	    sub(m) {
	        for (let i = 0; i < 9; i++)
	            this.elements[i] -= m.elements[i];
	        return this;
	    }
	    /** Computes and returns the determinant of this matrix. */
	    determinant() {
	        const te = this.elements;
	        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
	        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	    }
	    /** Inverts this matrix, using the analytic method. You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead. */
	    invert() {
	        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
	        if (det === 0)
	            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
	        const detInv = 1 / det;
	        te[0] = t11 * detInv;
	        te[1] = (n31 * n23 - n33 * n21) * detInv;
	        te[2] = (n32 * n21 - n31 * n22) * detInv;
	        te[3] = t12 * detInv;
	        te[4] = (n33 * n11 - n31 * n13) * detInv;
	        te[5] = (n31 * n12 - n32 * n11) * detInv;
	        te[6] = t13 * detInv;
	        te[7] = (n21 * n13 - n23 * n11) * detInv;
	        te[8] = (n22 * n11 - n21 * n12) * detInv;
	        return this;
	    }
	    /** Transposes this matrix in place. */
	    transpose() {
	        let tmp;
	        const m = this.elements;
	        tmp = m[1];
	        m[1] = m[3];
	        m[3] = tmp;
	        tmp = m[2];
	        m[2] = m[6];
	        m[6] = tmp;
	        tmp = m[5];
	        m[5] = m[7];
	        m[7] = tmp;
	        return this;
	    }
	    /** Sets this matrix as the upper left 3x3 of the normal matrix of the passed matrix4. The normal matrix is the inverse transpose of the matrix m. */
	    getNormalMatrix(matrix4) {
	        return this.setFromMatrix4(matrix4).invert().transpose();
	    }
	    /** Transposes this matrix into the supplied array, and returns itself unchanged. */
	    transposeIntoArray(r) {
	        const m = this.elements;
	        r[0] = m[0];
	        r[1] = m[3];
	        r[2] = m[6];
	        r[3] = m[1];
	        r[4] = m[4];
	        r[5] = m[7];
	        r[6] = m[2];
	        r[7] = m[5];
	        r[8] = m[8];
	        return this;
	    }
	    /** Sets the UV transform matrix from offset, repeat, rotation, and center. */
	    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
	        const c = Math.cos(rotation);
	        const s = Math.sin(rotation);
	        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
	        return this;
	    }
	    /** Scales this matrix. */
	    scale(sx, sy) {
	        const te = this.elements;
	        te[0] *= sx;
	        te[3] *= sx;
	        te[6] *= sx;
	        te[1] *= sy;
	        te[4] *= sy;
	        te[7] *= sy;
	        return this;
	    }
	    /** Rotates this matrix. */
	    rotate(theta) {
	        const c = Math.cos(theta);
	        const s = Math.sin(theta);
	        const te = this.elements;
	        const a11 = te[0], a12 = te[3], a13 = te[6];
	        const a21 = te[1], a22 = te[4], a23 = te[7];
	        te[0] = c * a11 + s * a21;
	        te[3] = c * a12 + s * a22;
	        te[6] = c * a13 + s * a23;
	        te[1] = -s * a11 + c * a21;
	        te[4] = -s * a12 + c * a22;
	        te[7] = -s * a13 + c * a23;
	        return this;
	    }
	    /** Translates this matrix. */
	    translate(tx, ty) {
	        const te = this.elements;
	        te[0] += tx * te[2];
	        te[3] += tx * te[5];
	        te[6] += tx * te[8];
	        te[1] += ty * te[2];
	        te[4] += ty * te[5];
	        te[7] += ty * te[8];
	        return this;
	    }
	    /** Return true if this matrix and m are equal. */
	    equals(matrix) {
	        const te = this.elements;
	        const me = matrix.elements;
	        for (let i = 0; i < 9; i++) {
	            if (te[i] !== me[i])
	                return false;
	        }
	        return true;
	    }
	    /** Sets the elements of this matrix based on an array in column-major format. */
	    fromArray(array, offset = 0) {
	        for (let i = 0; i < 9; i++) {
	            this.elements[i] = array[i + offset];
	        }
	        return this;
	    }
	    /** Writes the elements of this matrix to an array in column-major format. */
	    toArray(array = [], offset = 0) {
	        const te = this.elements;
	        array[offset] = te[0];
	        array[offset + 1] = te[1];
	        array[offset + 2] = te[2];
	        array[offset + 3] = te[3];
	        array[offset + 4] = te[4];
	        array[offset + 5] = te[5];
	        array[offset + 6] = te[6];
	        array[offset + 7] = te[7];
	        array[offset + 8] = te[8];
	        return array;
	    }
	    /** Creates a new Matrix3 and with identical elements to this one. */
	    clone() {
	        return new Matrix3().fromArray(this.elements);
	    }
	}

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** A class representing a 4x4 matrix. Defaults to the identity matrix. */
	class Matrix4 {
	    constructor() {
	        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    }
	    /** Set the elements of this matrix to the supplied row-major values `n11`, `n12`, ... `n44`. */
	    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	        const te = this.elements;
	        te[0] = n11;
	        te[4] = n12;
	        te[8] = n13;
	        te[12] = n14;
	        te[1] = n21;
	        te[5] = n22;
	        te[9] = n23;
	        te[13] = n24;
	        te[2] = n31;
	        te[6] = n32;
	        te[10] = n33;
	        te[14] = n34;
	        te[3] = n41;
	        te[7] = n42;
	        te[11] = n43;
	        te[15] = n44;
	        return this;
	    }
	    /** Resets this matrix to the identity matrix. */
	    identity() {
	        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Creates a new Matrix4 with identical elements to this one. */
	    clone() {
	        return new Matrix4().fromArray(this.elements);
	    }
	    /** Copies the elements of matrix m into this matrix. */
	    copy(m) {
	        const te = this.elements;
	        const me = m.elements;
	        te[0] = me[0];
	        te[1] = me[1];
	        te[2] = me[2];
	        te[3] = me[3];
	        te[4] = me[4];
	        te[5] = me[5];
	        te[6] = me[6];
	        te[7] = me[7];
	        te[8] = me[8];
	        te[9] = me[9];
	        te[10] = me[10];
	        te[11] = me[11];
	        te[12] = me[12];
	        te[13] = me[13];
	        te[14] = me[14];
	        te[15] = me[15];
	        return this;
	    }
	    /** Copies the translation component of the supplied matrix m into this matrix's translation component. */
	    copyPosition(m) {
	        const te = this.elements, me = m.elements;
	        te[12] = me[12];
	        te[13] = me[13];
	        te[14] = me[14];
	        return this;
	    }
	    /** Set the upper 3x3 elements of this matrix to the values of the Matrix3 `m`. */
	    setFromMatrix3(m) {
	        const me = m.elements;
	        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Extracts the basis of this matrix into the three axis vectors provided. */
	    extractBasis(xAxis, yAxis, zAxis) {
	        xAxis.setFromMatrixColumn(this, 0);
	        yAxis.setFromMatrixColumn(this, 1);
	        zAxis.setFromMatrixColumn(this, 2);
	        return this;
	    }
	    /** Set this to the basis matrix consisting of the three provided basis vectors. */
	    makeBasis(xAxis, yAxis, zAxis) {
	        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Extracts the rotation component of the supplied matrix m into this matrix's rotation component. */
	    extractRotation(m) {
	        // this method does not support reflection matrices
	        const te = this.elements;
	        const me = m.elements;
	        const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
	        const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
	        const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();
	        te[0] = me[0] * scaleX;
	        te[1] = me[1] * scaleX;
	        te[2] = me[2] * scaleX;
	        te[3] = 0;
	        te[4] = me[4] * scaleY;
	        te[5] = me[5] * scaleY;
	        te[6] = me[6] * scaleY;
	        te[7] = 0;
	        te[8] = me[8] * scaleZ;
	        te[9] = me[9] * scaleZ;
	        te[10] = me[10] * scaleZ;
	        te[11] = 0;
	        te[12] = 0;
	        te[13] = 0;
	        te[14] = 0;
	        te[15] = 1;
	        return this;
	    }
	    /** Sets the rotation component (the upper left 3x3 matrix) of this matrix to the rotation specified by the given Euler Angle. The rest of the matrix is set to the identity. Depending on the order of the euler, there are six possible outcomes. */
	    makeRotationFromEuler(euler) {
	        const te = this.elements;
	        const x = euler.x, y = euler.y, z = euler.z;
	        const a = Math.cos(x), b = Math.sin(x);
	        const c = Math.cos(y), d = Math.sin(y);
	        const e = Math.cos(z), f = Math.sin(z);
	        if (euler.order === "XYZ") {
	            const ae = a * e, af = a * f, be = b * e, bf = b * f;
	            te[0] = c * e;
	            te[4] = -c * f;
	            te[8] = d;
	            te[1] = af + be * d;
	            te[5] = ae - bf * d;
	            te[9] = -b * c;
	            te[2] = bf - ae * d;
	            te[6] = be + af * d;
	            te[10] = a * c;
	        }
	        else if (euler.order === "YXZ") {
	            const ce = c * e, cf = c * f, de = d * e, df = d * f;
	            te[0] = ce + df * b;
	            te[4] = de * b - cf;
	            te[8] = a * d;
	            te[1] = a * f;
	            te[5] = a * e;
	            te[9] = -b;
	            te[2] = cf * b - de;
	            te[6] = df + ce * b;
	            te[10] = a * c;
	        }
	        else if (euler.order === "ZXY") {
	            const ce = c * e, cf = c * f, de = d * e, df = d * f;
	            te[0] = ce - df * b;
	            te[4] = -a * f;
	            te[8] = de + cf * b;
	            te[1] = cf + de * b;
	            te[5] = a * e;
	            te[9] = df - ce * b;
	            te[2] = -a * d;
	            te[6] = b;
	            te[10] = a * c;
	        }
	        else if (euler.order === "ZYX") {
	            const ae = a * e, af = a * f, be = b * e, bf = b * f;
	            te[0] = c * e;
	            te[4] = be * d - af;
	            te[8] = ae * d + bf;
	            te[1] = c * f;
	            te[5] = bf * d + ae;
	            te[9] = af * d - be;
	            te[2] = -d;
	            te[6] = b * c;
	            te[10] = a * c;
	        }
	        else if (euler.order === "YZX") {
	            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	            te[0] = c * e;
	            te[4] = bd - ac * f;
	            te[8] = bc * f + ad;
	            te[1] = f;
	            te[5] = a * e;
	            te[9] = -b * e;
	            te[2] = -d * e;
	            te[6] = ad * f + bc;
	            te[10] = ac - bd * f;
	        }
	        else if (euler.order === "XZY") {
	            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	            te[0] = c * e;
	            te[4] = -f;
	            te[8] = d * e;
	            te[1] = ac * f + bd;
	            te[5] = a * e;
	            te[9] = ad * f - bc;
	            te[2] = bc * f - ad;
	            te[6] = b * e;
	            te[10] = bd * f + ac;
	        }
	        // bottom row
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        // last column
	        te[12] = 0;
	        te[13] = 0;
	        te[14] = 0;
	        te[15] = 1;
	        return this;
	    }
	    /** Sets the rotation component of this matrix to the rotation specified by q, as outlined here (https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion). The rest of the matrix is set to the identity */
	    makeRotationFromQuaternion(q) {
	        return this.compose(_zero, q, _one);
	    }
	    /** Constructs a rotation matrix, looking from `eye` towards `target` oriented by the `up` vector. */
	    lookAt(eye, target, up) {
	        const te = this.elements;
	        _z.subVectors(eye, target);
	        if (_z.lengthSq() === 0) {
	            // eye and target are in the same position
	            _z.z = 1;
	        }
	        _z.normalize();
	        _x.crossVectors(up, _z);
	        if (_x.lengthSq() === 0) {
	            // up and z are parallel
	            if (Math.abs(up.z) === 1) {
	                _z.x += 0.0001;
	            }
	            else {
	                _z.z += 0.0001;
	            }
	            _z.normalize();
	            _x.crossVectors(up, _z);
	        }
	        _x.normalize();
	        _y.crossVectors(_z, _x);
	        te[0] = _x.x;
	        te[4] = _y.x;
	        te[8] = _z.x;
	        te[1] = _x.y;
	        te[5] = _y.y;
	        te[9] = _z.y;
	        te[2] = _x.z;
	        te[6] = _y.z;
	        te[10] = _z.z;
	        return this;
	    }
	    /** Post-multiplies this matrix by m. */
	    multiply(m) {
	        return this.multiplyMatrices(this, m);
	    }
	    /** Pre-multiplies this matrix by m. */
	    premultiply(m) {
	        return this.multiplyMatrices(m, this);
	    }
	    /** Sets this matrix to a x b. */
	    multiplyMatrices(a, b) {
	        const ae = a.elements;
	        const be = b.elements;
	        const te = this.elements;
	        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
	        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
	        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
	        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
	        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
	        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
	        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
	        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
	        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	        return this;
	    }
	    /** Multiplies every component of the matrix by a scalar value s. */
	    multiplyScalar(s) {
	        const te = this.elements;
	        te[0] *= s;
	        te[4] *= s;
	        te[8] *= s;
	        te[12] *= s;
	        te[1] *= s;
	        te[5] *= s;
	        te[9] *= s;
	        te[13] *= s;
	        te[2] *= s;
	        te[6] *= s;
	        te[10] *= s;
	        te[14] *= s;
	        te[3] *= s;
	        te[7] *= s;
	        te[11] *= s;
	        te[15] *= s;
	        return this;
	    }
	    /** Adds `m` to this matrix, component-wise. */
	    add(m) {
	        for (let i = 0; i < 16; i++)
	            this.elements[i] += m.elements[i];
	        return this;
	    }
	    /** Subtracts `m` from this matrix, component-wise. */
	    sub(m) {
	        for (let i = 0; i < 16; i++)
	            this.elements[i] -= m.elements[i];
	        return this;
	    }
	    /** Computes and returns the determinant of this matrix. */
	    determinant() {
	        const te = this.elements;
	        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
	        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
	        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
	        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
	        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	        return (n41 *
	            (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) +
	            n42 *
	                (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) +
	            n43 *
	                (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) +
	            n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
	    }
	    /** Transposes this matrix. */
	    transpose() {
	        const te = this.elements;
	        let tmp;
	        tmp = te[1];
	        te[1] = te[4];
	        te[4] = tmp;
	        tmp = te[2];
	        te[2] = te[8];
	        te[8] = tmp;
	        tmp = te[6];
	        te[6] = te[9];
	        te[9] = tmp;
	        tmp = te[3];
	        te[3] = te[12];
	        te[12] = tmp;
	        tmp = te[7];
	        te[7] = te[13];
	        te[13] = tmp;
	        tmp = te[11];
	        te[11] = te[14];
	        te[14] = tmp;
	        return this;
	    }
	    /** Sets the position component for this matrix from vector v, without affecting the rest of the matrix. */
	    setPosition(x) {
	        const te = this.elements;
	        te[12] = x.x;
	        te[13] = x.y;
	        te[14] = x.z;
	        return this;
	    }
	    /** Inverts this matrix, using the analytic method. You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead. */
	    invert() {
	        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	        if (det === 0)
	            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	        const detInv = 1 / det;
	        te[0] = t11 * detInv;
	        te[1] =
	            (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) *
	                detInv;
	        te[2] =
	            (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) *
	                detInv;
	        te[3] =
	            (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) *
	                detInv;
	        te[4] = t12 * detInv;
	        te[5] =
	            (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) *
	                detInv;
	        te[6] =
	            (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) *
	                detInv;
	        te[7] =
	            (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) *
	                detInv;
	        te[8] = t13 * detInv;
	        te[9] =
	            (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) *
	                detInv;
	        te[10] =
	            (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) *
	                detInv;
	        te[11] =
	            (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) *
	                detInv;
	        te[12] = t14 * detInv;
	        te[13] =
	            (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) *
	                detInv;
	        te[14] =
	            (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) *
	                detInv;
	        te[15] =
	            (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) *
	                detInv;
	        return this;
	    }
	    /** Multiplies the columns of this matrix by vector v. */
	    scale(v) {
	        const te = this.elements;
	        const x = v.x, y = v.y, z = v.z;
	        te[0] *= x;
	        te[4] *= y;
	        te[8] *= z;
	        te[1] *= x;
	        te[5] *= y;
	        te[9] *= z;
	        te[2] *= x;
	        te[6] *= y;
	        te[10] *= z;
	        te[3] *= x;
	        te[7] *= y;
	        te[11] *= z;
	        return this;
	    }
	    /** Gets the maximum scale value of the 3 axes. */
	    getMaxScaleOnAxis() {
	        const te = this.elements;
	        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	    }
	    /** Sets this matrix as a translation transform. */
	    makeTranslation(x, y, z) {
	        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a rotational transformation around the X axis by theta (θ) radians. */
	    makeRotationX(theta) {
	        const c = Math.cos(theta), s = Math.sin(theta);
	        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a rotational transformation around the Y axis by theta (θ) radians. */
	    makeRotationY(theta) {
	        const c = Math.cos(theta), s = Math.sin(theta);
	        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a rotational transformation around the Z axis by theta (θ) radians. */
	    makeRotationZ(theta) {
	        const c = Math.cos(theta), s = Math.sin(theta);
	        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as rotation transform around axis by theta radians. */
	    makeRotationAxis(axis, angle) {
	        // Based on http://www.gamedev.net/reference/articles/article1199.asp
	        const c = Math.cos(angle);
	        const s = Math.sin(angle);
	        const t = 1 - c;
	        const x = axis.x, y = axis.y, z = axis.z;
	        const tx = t * x, ty = t * y;
	        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as scale transform. */
	    makeScale(x, y, z) {
	        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a shear transform. */
	    makeShear(xy, xz, yx, yz, zx, zy) {
	        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix to the transformation composed of position, quaternion and scale. */
	    compose(position, quaternion, scale) {
	        const te = this.elements;
	        const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
	        const x2 = x + x, y2 = y + y, z2 = z + z;
	        const xx = x * x2, xy = x * y2, xz = x * z2;
	        const yy = y * y2, yz = y * z2, zz = z * z2;
	        const wx = w * x2, wy = w * y2, wz = w * z2;
	        const sx = scale.x, sy = scale.y, sz = scale.z;
	        te[0] = (1 - (yy + zz)) * sx;
	        te[1] = (xy + wz) * sx;
	        te[2] = (xz - wy) * sx;
	        te[3] = 0;
	        te[4] = (xy - wz) * sy;
	        te[5] = (1 - (xx + zz)) * sy;
	        te[6] = (yz + wx) * sy;
	        te[7] = 0;
	        te[8] = (xz + wy) * sz;
	        te[9] = (yz - wx) * sz;
	        te[10] = (1 - (xx + yy)) * sz;
	        te[11] = 0;
	        te[12] = position.x;
	        te[13] = position.y;
	        te[14] = position.z;
	        te[15] = 1;
	        return this;
	    }
	    /** Decomposes this matrix into its position, quaternion and scale components. Note: Not all matrices are decomposable in this way. For example, if an object has a non-uniformly scaled parent, then the object's world matrix may not be decomposable, and this method may not be appropriate. */
	    decompose(position, quaternion, scale) {
	        const te = this.elements;
	        let sx = _v1.set(te[0], te[1], te[2]).length();
	        const sy = _v1.set(te[4], te[5], te[6]).length();
	        const sz = _v1.set(te[8], te[9], te[10]).length();
	        // if determine is negative, we need to invert one scale
	        const det = this.determinant();
	        if (det < 0)
	            sx = -sx;
	        position.x = te[12];
	        position.y = te[13];
	        position.z = te[14];
	        // scale the rotation part
	        _m1.copy(this);
	        const invSX = 1 / sx;
	        const invSY = 1 / sy;
	        const invSZ = 1 / sz;
	        _m1.elements[0] *= invSX;
	        _m1.elements[1] *= invSX;
	        _m1.elements[2] *= invSX;
	        _m1.elements[4] *= invSY;
	        _m1.elements[5] *= invSY;
	        _m1.elements[6] *= invSY;
	        _m1.elements[8] *= invSZ;
	        _m1.elements[9] *= invSZ;
	        _m1.elements[10] *= invSZ;
	        quaternion.setFromRotationMatrix(_m1);
	        scale.x = sx;
	        scale.y = sy;
	        scale.z = sz;
	        return this;
	    }
	    /** Creates a perspective projection matrix. */
	    makePerspective(left, right, top, bottom, near, far) {
	        const te = this.elements;
	        const x = (2 * near) / (right - left);
	        const y = (2 * near) / (top - bottom);
	        const a = (right + left) / (right - left);
	        const b = (top + bottom) / (top - bottom);
	        const c = -(far + near) / (far - near);
	        const d = (-2 * far * near) / (far - near);
	        te[0] = x;
	        te[4] = 0;
	        te[8] = a;
	        te[12] = 0;
	        te[1] = 0;
	        te[5] = y;
	        te[9] = b;
	        te[13] = 0;
	        te[2] = 0;
	        te[6] = 0;
	        te[10] = c;
	        te[14] = d;
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = -1;
	        te[15] = 0;
	        return this;
	    }
	    /** Creates an orthographic projection matrix. */
	    makeOrthographic(left, right, top, bottom, near, far) {
	        const te = this.elements;
	        const w = 1.0 / (right - left);
	        const h = 1.0 / (top - bottom);
	        const p = 1.0 / (far - near);
	        const x = (right + left) * w;
	        const y = (top + bottom) * h;
	        const z = (far + near) * p;
	        te[0] = 2 * w;
	        te[4] = 0;
	        te[8] = 0;
	        te[12] = -x;
	        te[1] = 0;
	        te[5] = 2 * h;
	        te[9] = 0;
	        te[13] = -y;
	        te[2] = 0;
	        te[6] = 0;
	        te[10] = -2 * p;
	        te[14] = -z;
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        te[15] = 1;
	        return this;
	    }
	    /** Return true if this matrix and `matrix` are equal. */
	    equals(matrix) {
	        const te = this.elements;
	        const me = matrix.elements;
	        for (let i = 0; i < 16; i++) {
	            if (te[i] !== me[i])
	                return false;
	        }
	        return true;
	    }
	    /** Sets the elements of this matrix based on an `array` in column-major format. */
	    fromArray(array, offset = 0) {
	        for (let i = 0; i < 16; i++) {
	            this.elements[i] = array[i + offset];
	        }
	        return this;
	    }
	    /** Writes the elements of this matrix to an array in column-major format. */
	    toArray(array = [], offset = 0) {
	        const te = this.elements;
	        array[offset] = te[0];
	        array[offset + 1] = te[1];
	        array[offset + 2] = te[2];
	        array[offset + 3] = te[3];
	        array[offset + 4] = te[4];
	        array[offset + 5] = te[5];
	        array[offset + 6] = te[6];
	        array[offset + 7] = te[7];
	        array[offset + 8] = te[8];
	        array[offset + 9] = te[9];
	        array[offset + 10] = te[10];
	        array[offset + 11] = te[11];
	        array[offset + 12] = te[12];
	        array[offset + 13] = te[13];
	        array[offset + 14] = te[14];
	        array[offset + 15] = te[15];
	        return array;
	    }
	}
	const _v1 = new Vector3();
	const _m1 = new Matrix4();
	const _zero = new Vector3(0, 0, 0);
	const _one = new Vector3(1, 1, 1);
	const _x = new Vector3();
	const _y = new Vector3();
	const _z = new Vector3();

	let v1 = new Vector3();
	let v2 = new Vector3();
	let v3 = new Vector3();
	let v4 = new Vector3();
	let v5 = new Vector3();
	let m1 = new Matrix4();
	let q1 = new Quaternion();
	/** Represents a convex collision shape. */
	class CollisionShape {
	    constructor() {
	        /** The body this shape belongs to. */
	        this.body = null;
	        this.boundingBox = new Box3();
	        /** The collision margin of this shape, can be used to make the shape thiccer in all directions. */
	        this.margin = 0;
	        /** If set, this shape will be used instead for broadphase collision detection (allows for better caching). */
	        this.broadphaseShape = null;
	        this.collisionDetectionMask = 0b1;
	        this.collisionResponseMask = 0b1;
	        this.friction = 1;
	        this.restitution = 1;
	        this.mass = 1;
	        this.inertia = new Matrix3();
	        this.invInertia = new Matrix3();
	        /** Material overrides allow a single collision shape to have more than one material (i.e. friction and restitution). These properties are described by a direction vector (intended to be the normal vector of the face the material applies) to, and the material with the highest dot product with the collision normal is chosen. */
	        this.materialOverrides = new Map();
	    }
	    updateBoundingBox() {
	        var _a, _b;
	        m1.compose(this.body.position, this.body.orientation, v1.setScalar(1));
	        this.boundingBox.applyMatrix4(m1); // Puts a bounding box around the translated bounding box
	        this.boundingBox.min.subScalar(this.margin);
	        this.boundingBox.max.addScalar(this.margin);
	        if (this.body.prevValid) {
	            // Extend the bounding box towards the previous position for CCD purposes
	            let translation = v1.copy(this.body.position).sub(this.body.prevPosition);
	            v2.copy(this.boundingBox.min).sub(translation); // Go backwards
	            v3.copy(this.boundingBox.max).sub(translation);
	            this.boundingBox.expandByPoint(v2).expandByPoint(v3);
	        }
	        // Update the octree
	        (_b = (_a = this.body) === null || _a === void 0 ? void 0 : _a.world) === null || _b === void 0 ? void 0 : _b.octree.update(this);
	    }
	}
	/** Represents a ball with a given radius. */
	class BallCollisionShape extends CollisionShape {
	    constructor(radius) {
	        super();
	        this.radius = radius;
	        this.updateInertiaTensor();
	    }
	    updateInertiaTensor() {
	        let scalar = 2 / 5 * this.mass * this.radius ** 2;
	        this.inertia.identity().multiplyScalar(scalar);
	        this.invInertia.copy(this.inertia).invert();
	    }
	    support(dst, direction) {
	        dst.copy(direction).setLength(this.radius).add(this.body.position);
	        if (this.margin > 0)
	            dst.add(v1.copy(direction).setLength(this.margin));
	        return dst;
	    }
	    getCenter(dst) {
	        return dst.copy(this.body.position);
	    }
	    updateBoundingBox() {
	        this.boundingBox.min.setScalar(-this.radius);
	        this.boundingBox.max.setScalar(this.radius);
	        super.updateBoundingBox();
	    }
	}
	/** Represents the convex hull of a set of points. */
	class ConvexHullCollisionShape extends CollisionShape {
	    constructor(points) {
	        super();
	        this.localCenter = new Vector3();
	        this.localAabb = new Box3();
	        this.points = points;
	        this.computeLocalBoundingBox();
	        this.updateInertiaTensor();
	    }
	    computeLocalBoundingBox() {
	        // Precompute some stuff so it's faster later
	        this.localCenter.setScalar(0);
	        for (let point of this.points)
	            this.localCenter.addScaledVector(point, 1 / this.points.length);
	        this.localAabb.setFromPoints(this.points);
	    }
	    updateInertiaTensor() {
	        // Do nothing for now, we likely won't need it because there is no dynamic convex hull object
	    }
	    support(dst, direction) {
	        q1.copy(this.body.orientation).conjugate();
	        let localDirection = v1.copy(direction).applyQuaternion(q1); // Transform it to local space
	        let maxDot = -Infinity;
	        // Naive O(n) support function, loop over all points and find the one with the biggest dot
	        for (let i = 0; i < this.points.length; i++) {
	            let point = this.points[i];
	            let dot = point.dot(localDirection);
	            if (dot > maxDot) {
	                maxDot = dot;
	                dst.copy(point);
	            }
	        }
	        this.body.transformPoint(dst); // Transform it from local into world space
	        if (this.margin > 0)
	            dst.add(v1.copy(direction).setLength(this.margin));
	        return dst;
	    }
	    getCenter(dst) {
	        return this.body.transformPoint(dst.copy(this.localCenter));
	    }
	    updateBoundingBox() {
	        this.boundingBox.copy(this.localAabb);
	        super.updateBoundingBox();
	    }
	}
	/** Represents the convex hull of two other collision shapes. */
	class CombinedCollisionShape extends CollisionShape {
	    constructor(s1, s2) {
	        super();
	        this.s1 = s1;
	        this.s2 = s2;
	    }
	    updateInertiaTensor() { }
	    support(dst, direction) {
	        // Simply return the max of the two support functions
	        let supp1 = this.s1.support(v4, direction);
	        let supp2 = this.s2.support(v5, direction);
	        if (supp1.dot(direction) > supp2.dot(direction))
	            dst.copy(supp1);
	        else
	            dst.copy(supp2);
	        return dst;
	    }
	    getCenter(dst) {
	        // Return the average, this is probably not correct
	        return this.s1.getCenter(dst).add(this.s2.getCenter(v4)).multiplyScalar(0.5);
	    }
	}
	/** Represents the shape that's just a single dot at the origin, so C = { (0, 0, 0)^T } */
	class SingletonCollisionShape extends CollisionShape {
	    updateInertiaTensor() { }
	    support(dst) {
	        return dst.copy(this.body.position);
	    }
	    getCenter(dst) {
	        return dst.copy(this.body.position);
	    }
	}

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Class representing a 2D vector. */
	class Vector2 {
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    get width() {
	        return this.x;
	    }
	    set width(value) {
	        this.x = value;
	    }
	    get height() {
	        return this.y;
	    }
	    set height(value) {
	        this.y = value;
	    }
	    /** Sets the x and y components of this vector. */
	    set(x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    }
	    /** Sets the x and y values of this vector both equal to scalar. */
	    setScalar(scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        return this;
	    }
	    /** Replaces this vector's x value with `x`. */
	    setX(x) {
	        this.x = x;
	        return this;
	    }
	    /** Replaces this vector's y value with `y`. */
	    setY(y) {
	        this.y = y;
	        return this;
	    }
	    /** If index equals 0 set x to value. If index equals 1 set y to value */
	    setComponent(index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	        return this;
	    }
	    /** If index equals 0 returns the x value. If index equals 1 returns the y value. */
	    getComponent(index) {
	        switch (index) {
	            case 0:
	                return this.x;
	            case 1:
	                return this.y;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	    }
	    /** Returns a new Vector2 with the same x and y values as this one. */
	    clone() {
	        return new Vector2(this.x, this.y);
	    }
	    /** Copies the values of the passed Vector2's x and y properties to this Vector2. */
	    copy(v) {
	        this.x = v.x;
	        this.y = v.y;
	        return this;
	    }
	    /** Adds `v` to this vector. */
	    add(v) {
	        this.x += v.x;
	        this.y += v.y;
	        return this;
	    }
	    /** Adds the scalar value `s` to this vector's x and y values. */
	    addScalar(s) {
	        this.x += s;
	        this.y += s;
	        return this;
	    }
	    /** Sets this vector to `a` + `b`. */
	    addVectors(a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        return this;
	    }
	    /** Adds the multiple of `v` and `s` to this vector. */
	    addScaledVector(v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        return this;
	    }
	    /** Subtracts `v` from this vector. */
	    sub(v) {
	        this.x -= v.x;
	        this.y -= v.y;
	        return this;
	    }
	    /** Subtracts `s` from this vector's x and y components. */
	    subScalar(s) {
	        this.x -= s;
	        this.y -= s;
	        return this;
	    }
	    /** Sets this vector to `a` - `b`. */
	    subVectors(a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        return this;
	    }
	    /** Multiplies this vector by `v`. */
	    multiply(v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        return this;
	    }
	    /** Multiplies this vector by scalar `s`. */
	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        return this;
	    }
	    /** Divides this vector by `v`. */
	    divide(v) {
	        this.x /= v.x;
	        this.y /= v.y;
	        return this;
	    }
	    /** Divides this vector by scalar `s`. */
	    divideScalar(scalar) {
	        return this.multiplyScalar(1 / scalar);
	    }
	    /** Multiplies this vector (with an implicit 1 as the 3rd component) by `m`. */
	    applyMatrix3(m) {
	        const x = this.x, y = this.y;
	        const e = m.elements;
	        this.x = e[0] * x + e[3] * y + e[6];
	        this.y = e[1] * x + e[4] * y + e[7];
	        return this;
	    }
	    /** If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value. */
	    min(v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        return this;
	    }
	    /** If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value. */
	    max(v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        return this;
	    }
	    /** If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value. If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value. */
	    clamp(min, max) {
	        // assumes min < max, componentwise
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        return this;
	    }
	    /** If this vector's x or y values are greater than the max value, they are replaced by the max value. If this vector's x or y values are less than the min value, they are replaced by the min value. */
	    clampScalar(minVal, maxVal) {
	        this.x = Math.max(minVal, Math.min(maxVal, this.x));
	        this.y = Math.max(minVal, Math.min(maxVal, this.y));
	        return this;
	    }
	    /** If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value. */
	    clampLength(min, max) {
	        const length = this.length();
	        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	    }
	    /** The components of this vector are rounded down to the nearest integer value. */
	    floor() {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        return this;
	    }
	    /** The components of this vector are rounded up to the nearest integer value. */
	    ceil() {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        return this;
	    }
	    /** The components of this vector are rounded to the nearest integer value. */
	    round() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        return this;
	    }
	    /** The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value. */
	    roundToZero() {
	        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	        return this;
	    }
	    /** Inverts this vector - i.e. sets x = -x and y = -y. */
	    negate() {
	        this.x = -this.x;
	        this.y = -this.y;
	        return this;
	    }
	    /** Calculates the dot product of this vector and v. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y;
	    }
	    /** Calculates the cross product of this vector and v. Note that a 'cross-product' in 2D is not well-defined. This function computes a geometric cross-product often used in 2D graphics. */
	    cross(v) {
	        return this.x * v.y - this.y * v.x;
	    }
	    /** Computes the square of the Euclidean length (straight-line length) from (0, 0) to (x, y). */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y;
	    }
	    /** Computes the Euclidean length (straight-line length) from (0, 0) to (x, y). */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    }
	    /** Computes the Manhattan length of this vector. */
	    manhattanLength() {
	        return Math.abs(this.x) + Math.abs(this.y);
	    }
	    /** Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1. */
	    normalize() {
	        return this.divideScalar(this.length() || 1);
	    }
	    /** Computes the angle in radians of this vector with respect to the positive x-axis. */
	    angle() {
	        // computes the angle in radians with respect to the positive x-axis
	        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
	        return angle;
	    }
	    /** Computes the distance from this vector to v. */
	    distanceTo(v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    }
	    /** Computes the squared distance from this vector to v. */
	    distanceToSquared(v) {
	        const dx = this.x - v.x, dy = this.y - v.y;
	        return dx * dx + dy * dy;
	    }
	    /** Computes the Manhattan distance from this vector to v. */
	    manhattanDistanceTo(v) {
	        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	    }
	    /** Sets this vector to a vector with the same direction as this one, but length l. */
	    setLength(length) {
	        return this.normalize().multiplyScalar(length);
	    }
	    /** Linearly interpolates between this vector and `v`, where `alpha` is the percent distance along the line - `alpha` = 0 will be this vector, and `alpha` = 1 will be `v`. */
	    lerp(v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        return this;
	    }
	    /** Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2. */
	    lerpVectors(v1, v2, alpha) {
	        this.x = v1.x + (v2.x - v1.x) * alpha;
	        this.y = v1.y + (v2.y - v1.y) * alpha;
	        return this;
	    }
	    /** Returns true if the components of this vector and v are strictly equal; false otherwise. */
	    equals(v) {
	        return v.x === this.x && v.y === this.y;
	    }
	    /** Sets this vector's x value to be array[ offset ] and y value to be array[ offset + 1 ]. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        return this;
	    }
	    /** Returns an array [x, y], or copies x and y into the provided array. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        return array;
	    }
	    /** Rotates this vector around center by angle radians. */
	    rotateAround(center, angle) {
	        const c = Math.cos(angle), s = Math.sin(angle);
	        const x = this.x - center.x;
	        const y = this.y - center.y;
	        this.x = x * c - y * s + center.x;
	        this.y = x * s + y * c + center.y;
	        return this;
	    }
	    /** Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1. */
	    random() {
	        this.x = Math.random();
	        this.y = Math.random();
	        return this;
	    }
	    *[Symbol.iterator]() {
	        yield this.x;
	        yield this.y;
	    }
	}

	class Util {
	    static async init() {
	        var _a;
	        try {
	            // Fetch the keyboard map for instant access later
	            this.keyboardMap = await ((_a = navigator.keyboard) === null || _a === void 0 ? void 0 : _a.getLayoutMap());
	        }
	        catch (e) { }
	    }
	    static degToRad(deg) {
	        return deg / 180 * Math.PI;
	    }
	    static randomFromArray(arr) {
	        return arr[Math.floor(Math.random() * arr.length)];
	    }
	    /** Rotates and/or flips an image with a canvas and returns the canvas. */
	    static modifyImageWithCanvas(image, rotate, flip = false) {
	        let canvas = document.createElement('canvas');
	        canvas.setAttribute('width', image.width.toString());
	        canvas.setAttribute('height', image.height.toString());
	        let ctx = canvas.getContext('2d');
	        ctx.translate(image.width / 2, image.height / 2);
	        if (flip)
	            ctx.scale(1, -1);
	        ctx.rotate(rotate);
	        ctx.translate(-image.width / 2, -image.height / 2);
	        ctx.drawImage(image, 0, 0, image.width, image.height);
	        return canvas;
	    }
	    /** Removes the alpha channel from an image (sets all alpha values to 1) */
	    static removeAlphaChannel(image) {
	        let canvas = document.createElement('canvas');
	        canvas.setAttribute('width', image.width.toString());
	        canvas.setAttribute('height', image.height.toString());
	        let ctx = canvas.getContext('2d');
	        ctx.drawImage(image, 0, 0);
	        let imageData = ctx.getImageData(0, 0, image.width, image.height);
	        for (let i = 0; i < imageData.data.length; i += 4) {
	            imageData.data[i + 3] = 255;
	        }
	        ctx.putImageData(imageData, 0, 0);
	        return canvas;
	    }
	    static async resampleImage(image, newWidth, newHeight) {
	        let canvas = document.createElement('canvas');
	        canvas.setAttribute('width', newWidth.toString());
	        canvas.setAttribute('height', newHeight.toString());
	        let ctx = canvas.getContext('2d');
	        ctx.drawImage(image, 0, 0, newWidth, newHeight);
	        let data = canvas.toDataURL();
	        let newImage = new Image();
	        newImage.src = data;
	        await new Promise(resolve => newImage.onload = resolve);
	        return newImage;
	    }
	    static clamp(value, min, max) {
	        if (value < min)
	            return min;
	        if (value > max)
	            return max;
	        return value;
	    }
	    static lerp(a, b, t) {
	        return (1 - t) * a + t * b;
	    }
	    static avg(a, b) {
	        return (a + b) / 2;
	    }
	    static isSameVector(v1, v2) {
	        return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
	    }
	    /** Add a vector to another vector while making sure not to exceed a certain magnitude. */
	    static addToVectorCapped(target, add, magnitudeCap) {
	        let direction = add.clone().normalize();
	        let dot = Math.max(0, target.dot(direction));
	        if (dot + add.length() > magnitudeCap) {
	            let newLength = Math.max(0, magnitudeCap - dot);
	            add.normalize().multiplyScalar(newLength);
	        }
	        target.add(add);
	    }
	    static leftPadZeroes(str, amount) {
	        return "0".repeat(Math.max(0, amount - str.length)) + str;
	    }
	    /** Forces an element's layout to be recalculated. */
	    static forceLayout(element) {
	        element.clientWidth; // It's hacky, but simply accessing this forces it.
	    }
	    /** Get the value of a key for the corresponding button code. For example, KeyA -> A. Respects the user's keyboard layout. */
	    static getKeyForButtonCode(code) {
	        outer: if (this.keyboardMap) {
	            let value = this.keyboardMap.get(code);
	            if (!value)
	                break outer;
	            // Use the value from the keyboard map. This maps things like KeyZ to Y for German keyboards, for example.
	            return (value.toUpperCase().length > 1) ? value : value.toUpperCase(); // This special handling here is for characters that turn into more than one letter when capitalized (like ß).
	        }
	        if (code.startsWith("Key"))
	            return code.slice(3);
	        if (code.startsWith("Digit"))
	            return code.slice(5);
	        if (code.startsWith('Arrow'))
	            return code.slice(5);
	        if (code === "Space")
	            return "Space Bar";
	        if (code === "LMB")
	            return "the Left Mouse Button";
	        if (code === "MMB")
	            return "the Middle Mouse Button";
	        if (code === "RMB")
	            return "the Right Mouse Button";
	        return code;
	    }
	    static setsHaveOverlap(a, b) {
	        for (let val of a) {
	            if (b.has(val))
	                return true;
	        }
	        return false;
	    }
	    /** Compute the value of a 1D Catmull-Rom spline. */
	    static catmullRom(t, p0, p1, p2, p3) {
	        let point = t * t * t * ((-1) * p0 + 3 * p1 - 3 * p2 + p3) / 2;
	        point += t * t * (2 * p0 - 5 * p1 + 4 * p2 - p3) / 2;
	        point += t * ((-1) * p0 + p2) / 2;
	        point += p1;
	        return point;
	    }
	    /** Clones an object using JSON. */
	    static jsonClone(obj) {
	        return JSON.parse(JSON.stringify(obj));
	    }
	    static lerpColors(c1, c2, t) {
	        return {
	            r: Math.floor(Util.lerp(c1.r, c2.r, t)),
	            g: Math.floor(Util.lerp(c1.g, c2.g, t)),
	            b: Math.floor(Util.lerp(c1.b, c2.b, t)),
	            a: Math.floor(Util.lerp(c1.a, c2.a, t))
	        };
	    }
	    /** Returns a random point within the unit circle, distributed uniformly. */
	    static randomPointInUnitCircle() {
	        let r = Math.sqrt(Math.random());
	        let theta = Math.random() * Math.PI * 2;
	        return new Vector2(r * Math.cos(theta), r * Math.sin(theta));
	    }
	    /** Removes an item from an array, or does nothing if it isn't contained in it. */
	    static removeFromArray(arr, item) {
	        let index = arr.indexOf(item);
	        if (index !== -1)
	            arr.splice(index, 1);
	    }
	    /** Used to transform normal vectors. Shamelessly copied from Torque's source code. */
	    static m_matF_x_vectorF(matrix, v) {
	        let m = matrix.transpose().elements;
	        let v0 = v.x, v1 = v.y, v2 = v.z;
	        let m0 = m[0], m1 = m[1], m2 = m[2];
	        let m4 = m[4], m5 = m[5], m6 = m[6];
	        let m8 = m[8], m9 = m[9], m10 = m[10];
	        matrix.transpose();
	        let vresult_0 = m0 * v0 + m1 * v1 + m2 * v2;
	        let vresult_1 = m4 * v0 + m5 * v1 + m6 * v2;
	        let vresult_2 = m8 * v0 + m9 * v1 + m10 * v2;
	        v.set(vresult_0, vresult_1, vresult_2);
	    }
	    /** Creates a cylinder-shaped convex hull geometry, aligned with the y-axis. */
	    static createCylinderConvexHull(radius, halfHeight, radialSegments = 32, scale = new Vector3(1, 1, 1)) {
	        let vertices = [];
	        for (let i = 0; i < 2; i++) {
	            for (let j = 0; j < radialSegments; j++) {
	                let angle = j / radialSegments * Math.PI * 2;
	                let x = Math.cos(angle);
	                let z = Math.sin(angle);
	                vertices.push(new Vector3(x * radius * scale.x, (i ? halfHeight : -halfHeight) * scale.y, z * radius * scale.z));
	            }
	        }
	        return new ConvexHullCollisionShape(vertices);
	    }
	    static uppercaseFirstLetter(str) {
	        if (!str)
	            return str;
	        return str[0].toUpperCase() + str.slice(1);
	    }
	    /** Returns a promise that resolves after `ms` milliseconds. */
	    static wait(ms) {
	        return new Promise((resolve) => setTimeout(resolve, ms));
	    }
	    /** Modulo, but works as expected for negative numbers too. */
	    static adjustedMod(a, n) {
	        return ((a % n) + n) % n;
	    }
	    static concatArrays(arrays) {
	        if (arrays.length === 0)
	            return [];
	        return arrays[0].concat(...arrays.slice(1));
	    }
	    static isInFullscreen() {
	        var _a, _b;
	        // Only check the height for now because Android has those nav buttons
	        // Also weird edge case here with phone thinking it's still in portrait
	        return ( /*window.innerWidth === screen.width && */window.innerHeight === screen.height || (((_b = (_a = screen.orientation) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.includes('portrait')) && window.innerHeight === screen.width)) || !!document.fullscreenElement;
	    }
	    static swapInArray(arr, i1, i2) {
	        let temp = arr[i1];
	        arr[i1] = arr[i2];
	        arr[i2] = temp;
	    }
	    /** Makes the camera look at a point directly, meaning with the shortest rotation change possible and while ignoring the camera's up vector. */
	    static cameraLookAtDirect(camera, target) {
	        let lookVector = new Vector3(0, 0, -1);
	        lookVector.applyQuaternion(camera.orientation);
	        let quat = new Quaternion();
	        quat.setFromUnitVectors(lookVector, target.clone().sub(camera.position).normalize());
	        camera.orientation.copy(quat.multiply(camera.orientation));
	    }
	    static arrayBufferToString(buf) {
	        let str = "";
	        let view = new Uint8Array(buf);
	        for (let i = 0; i < buf.byteLength; i++) {
	            str += String.fromCharCode(view[i]);
	        }
	        return str;
	    }
	    static stringToArrayBuffer(str) {
	        let view = new Uint8Array(str.length);
	        for (let i = 0; i < str.length; i++) {
	            view[i] = str.charCodeAt(i);
	        }
	        return view.buffer;
	    }
	    static stringIsOnlyWhitespace(str) {
	        return str.trim().length === 0;
	    }
	    /** Unescapes escaped (\) characters. */
	    static unescape(str) {
	        let cEscapeRegex = /(^|[^\\])\\x([0-9a-f]{2})/gi; // Matches \xhh
	        let match = null;
	        while ((match = cEscapeRegex.exec(str)) !== null) {
	            let code = Number.parseInt(match[2], 16);
	            let char = this.macRomanToUtf8(code); // DUMB
	            str = str.slice(0, match.index) + match[1] + char + str.slice(match.index + match[0].length); // match[1] is "negative lookbehind"
	            cEscapeRegex.lastIndex -= 3;
	        }
	        let regex = /\\(.)/g;
	        let specialCases = {
	            '\\': '\\',
	            't': '\t',
	            'v': '\v',
	            '0': '\0',
	            'f': '\f',
	            'n': '\n',
	            'r': '\r'
	        };
	        while ((match = regex.exec(str)) !== null) {
	            let replaceWith;
	            if (specialCases[match[1]])
	                replaceWith = specialCases[match[1]];
	            else
	                replaceWith = match[1];
	            str = str.slice(0, match.index) + replaceWith + str.slice(match.index + match[0].length);
	            regex.lastIndex--;
	        }
	        return str;
	    }
	    /** Splits a string like String.prototype.split, but ignores the splitter if it appears inside string literal tokens. */
	    static splitIgnoreStringLiterals(str, splitter, strLiteralToken = '"') {
	        let indices = [];
	        let inString = false;
	        for (let i = 0; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	            else if (c === splitter)
	                indices.push(i);
	        }
	        let parts = [];
	        let remaining = str;
	        for (let i = 0; i < indices.length; i++) {
	            let index = indices[i] - (str.length - remaining.length);
	            let part = remaining.slice(0, index);
	            remaining = remaining.slice(index + 1);
	            parts.push(part);
	        }
	        parts.push(remaining);
	        return parts;
	    }
	    /** Gets the index of a substring like String.prototype.indexOf, but only if that index lies outside of string literals. */
	    static indexOfIgnoreStringLiterals(str, searchString, position = 0, strLiteralToken = '"') {
	        let inString = false;
	        for (let i = position; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	            else if (str.startsWith(searchString, i))
	                return i;
	        }
	        return -1;
	    }
	    /** Returns true iff the supplied index is part of a string literal. */
	    static indexIsInStringLiteral(str, index, strLiteralToken = '"') {
	        let inString = false;
	        for (let i = 0; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (i === index)
	                    return true;
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	        }
	        return false;
	    }
	    /** Reorders an array with the given index map. */
	    static remapIndices(arr, indices) {
	        return indices.map(i => arr[i]);
	    }
	    /** Finds the last element in an array that fulfills a predicate. */
	    static findLast(arr, predicate) {
	        for (let i = arr.length - 1; i >= 0; i--) {
	            if (predicate(arr[i]))
	                return arr[i];
	        }
	    }
	    /** Finds the last element in an array that fulfills a predicate. */
	    static findLastIndex(arr, predicate, start = arr.length - 1) {
	        for (let i = start; i >= 0; i--) {
	            if (predicate(arr[i]))
	                return i;
	        }
	        return -1;
	    }
	    /** Removes diacritics from a string. */
	    static normalizeString(str) {
	        // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
	        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
	    }
	    static removeSpecialCharacters(str) {
	        return str.replace(/[-!$%^&*()_+|~=`{}\[\]:";'<>?,.\/]/g, '');
	    }
	    /** Gets the last item in an array. */
	    static last(arr) {
	        return arr[arr.length - 1];
	    }
	    static isSafari() {
	        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	    }
	    static isFirefox() {
	        return navigator.userAgent.includes('Firefox');
	    }
	    static download(url, filename) {
	        let element = document.createElement('a');
	        element.setAttribute('href', url);
	        element.setAttribute('download', filename);
	        element.style.display = 'none';
	        document.body.appendChild(element);
	        element.click();
	        document.body.removeChild(element);
	    }
	    /** Removes all characters from a string that aren't letters or digits. */
	    static removeSpecialChars(str) {
	        let regex = /[^\w\d]/gi;
	        let match = null;
	        while ((match = regex.exec(str)) !== null) {
	            str = str.slice(0, match.index) + str.slice(match.index + match[0].length);
	            regex.lastIndex -= match[0].length;
	        }
	        return str;
	    }
	    /** Checks if a string is likely to be naughty or inappropriate based on its words. */
	    static isNaughty(str) {
	        let words = str.toLowerCase().split(' ');
	        for (let word of words)
	            if (this.naughtyWords.includes(word))
	                return true;
	        return false;
	    }
	    static shallowClone(obj) {
	        let clone = {};
	        for (let key in obj) {
	            clone[key] = obj[key];
	        }
	        return clone;
	    }
	    static isMac() {
	        return window.navigator.platform.toLowerCase().includes('mac');
	    }
	    // https://stackoverflow.com/questions/9038625/detect-if-device-is-ios
	    static isIOS() {
	        return [
	            'iPad Simulator',
	            'iPhone Simulator',
	            'iPod Simulator',
	            'iPad',
	            'iPhone',
	            'iPod'
	        ].includes(navigator.platform)
	            // iPad on iOS 13 detection
	            || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
	    }
	    /** Converts seconds into a time string as seen in the game clock at the top, for example. */
	    static secondsToTimeString(seconds, decimalDigits = this.getDefaultSecondsToTimeStringDecimalDigits()) {
	        let abs = Math.abs(seconds);
	        let minutes = Math.floor(abs / 60);
	        let string = Util.leftPadZeroes(minutes.toString(), 2) + ':' + Util.leftPadZeroes(Math.floor(abs % 60).toString(), 2) + '.' + Util.leftPadZeroes(Math.floor(abs * 10 ** decimalDigits % 10 ** decimalDigits).toString(), decimalDigits);
	        if (seconds < 0)
	            string = '-' + string;
	        return string;
	    }
	    static async arrayBufferToBase64(buf) {
	        let blob = new Blob([buf]);
	        let dataUrl = await new Promise((resolve) => {
	            let reader = new FileReader();
	            reader.onload = (e) => resolve(e.target.result);
	            reader.readAsDataURL(blob);
	        });
	        return dataUrl.slice(dataUrl.indexOf(',') + 1); // Remove the stupid preamble
	    }
	    /** Gets the next random number. Will be equal to the number returned by `peekRandomNumber(0)`. */
	    static popRandomNumber() {
	        if (this.randomNumberQueue.length > 0) {
	            return this.randomNumberQueue.shift();
	        }
	        else {
	            return Math.random();
	        }
	    }
	    /** See what the (`index` + 1)th next call of `popRandomNumber()` will return. */
	    static peekRandomNumber(index = 0) {
	        while (this.randomNumberQueue.length <= index) {
	            this.randomNumberQueue.push(Math.random());
	        }
	        return this.randomNumberQueue[index];
	    }
	    /** Compares two major.minor.patch version number strings. */
	    static compareVersions(v1, v2) {
	        let parts1 = v1.split('.').map(x => Number(x));
	        let parts2 = v2.split('.').map(x => Number(x));
	        for (let i = 0; i < parts1.length; i++) {
	            let a = parts1[i];
	            let b = parts2[i];
	            if (a > b)
	                return 1;
	            if (a < b)
	                return -1;
	        }
	        return 0;
	    }
	    /** Returns true if the current device is a mobile device or a tablet. If it's a computer with a touch screen, it will return false. */
	    static checkIsTouchDevice() {
	        return 'ontouchstart' in window; // Let's see if this suffices for now actually (this doesn't match my touchscreen laptop)
	    }
	    static signedSqrt(x) {
	        return Math.sign(x) * Math.sqrt(Math.abs(x));
	    }
	    static signedSquare(x) {
	        return x * Math.abs(x);
	    }
	    static htmlEscape(raw) {
	        this.htmlEscapeElem.textContent = raw;
	        return this.htmlEscapeElem.innerHTML;
	    }
	    /** Gets a unique id. */
	    static getRandomId() {
	        // This might seem cheap, but Math.random can return 2^52 different values, so the chance of collisions here is still ridiculously low.
	        // https://v8.dev/blog/math-random
	        return Math.random().toString();
	    }
	    static roundToMultiple(val, fac) {
	        if (!fac)
	            return val;
	        return Math.round(val / fac) * fac;
	    }
	    /** Checks if a ray intersects an AABB. Uses the algorithm described at https://tavianator.com/2011/ray_box.html. */
	    static rayIntersectsBox(rayOrigin, rayDirection, box, intersectionPoint) {
	        let tx1 = (box.min.x - rayOrigin.x) / rayDirection.x;
	        let tx2 = (box.max.x - rayOrigin.x) / rayDirection.x;
	        let tmin = Math.min(tx1, tx2);
	        let tmax = Math.max(tx1, tx2);
	        let ty1 = (box.min.y - rayOrigin.y) / rayDirection.y;
	        let ty2 = (box.max.y - rayOrigin.y) / rayDirection.y;
	        tmin = Math.max(tmin, Math.min(ty1, ty2));
	        tmax = Math.min(tmax, Math.max(ty1, ty2));
	        let tz1 = (box.min.z - rayOrigin.z) / rayDirection.z;
	        let tz2 = (box.max.z - rayOrigin.z) / rayDirection.z;
	        tmin = Math.max(tmin, Math.min(tz1, tz2));
	        tmax = Math.min(tmax, Math.max(tz1, tz2));
	        if (intersectionPoint && tmax >= tmin)
	            intersectionPoint.copy(rayOrigin).addScaledVector(rayDirection, (tmin >= 0) ? tmin : tmax); // use tmax if the ray starts inside the box
	        return tmax >= tmin;
	    }
	    /** Some fonts were apparently compiled on Mac and use this encoding instead of something sensible. Stupid. */
	    static macRomanToUtf8(char) {
	        if (char < 128)
	            return String.fromCharCode(char);
	        else
	            return this.macRomanToUtf8Map[char - 128];
	    }
	    /** Manually ensures all numbers in the element's text have the same width so they align nicely. */
	    static monospaceNumbers(element, ems = 0.5) {
	        element.innerHTML = element.textContent.split('').map(x => (x >= '0' && x <= '9') ? `<span style="width: ${ems}em; display: inline-block; text-align: center;">${x}</span>` : x).join('');
	    }
	    /** Fires a callback when the user has held down a given element for a longer amount of time. Allows "right clicking" on touch devices. */
	    static onLongTouch(element, callback) {
	        let id;
	        let kicked = false;
	        element.addEventListener('touchstart', (e) => {
	            id = setTimeout(() => {
	                callback(e);
	                kicked = true;
	            }, 500);
	        });
	        element.addEventListener('touchend', (e) => {
	            clearTimeout(id);
	            if (kicked) {
	                e.stopPropagation();
	                e.preventDefault();
	                kicked = false;
	            }
	        });
	    }
	    /** Turns each component's value into its absolute value. */
	    static absVector(vec) {
	        vec.x = Math.abs(vec.x);
	        vec.y = Math.abs(vec.y);
	        vec.z = Math.abs(vec.z);
	        return vec;
	    }
	    /** Returns an array of permutations of the input array. */
	    static getPermutations(arr) {
	        if (arr.length === 0)
	            return [];
	        if (arr.length === 1)
	            return [arr.slice()];
	        let res = [];
	        for (let i = 0; i < arr.length; i++) {
	            let first = arr[i];
	            let spliced = arr.slice();
	            spliced.splice(i, 1);
	            let subpermutations = this.getPermutations(spliced);
	            res.push(...subpermutations.map(x => (x.unshift(first), x)));
	        }
	        return res;
	    }
	    static pushArray(target, toPush) {
	        for (let elem of toPush)
	            target.push(elem);
	    }
	    static requestPointerLock() {
	        var _a, _b;
	        let ret = (_b = (_a = document.documentElement).requestPointerLock) === null || _b === void 0 ? void 0 : _b.call(_a);
	        if (ret && ret instanceof Promise)
	            ret.catch(() => { });
	    }
	    /** Returns true iff `b` is a subsequence of `a`. */
	    static isSubsequenceOf(b, a) {
	        if (b.length > a.length)
	            return false; // Early out
	        let j = 0;
	        for (let i = 0; i < b.length; i++) {
	            while (a[j] !== b[i] && j < a.length)
	                j++;
	            if (j === a.length)
	                return false;
	            j++;
	        }
	        return true;
	    }
	    static isPowerOf2(x) {
	        return !(x & (x - 1));
	    }
	    static ceilPowerOf2(x) {
	        let power = 1;
	        while (power < x)
	            power *= 2;
	        return power;
	    }
	    static assert(bool) {
	        if (!bool)
	            throw new Error("Assertion failed: " + bool);
	    }
	    static getBoxVertices(box) {
	        let dx = new Vector3(box.max.x - box.min.x, 0, 0);
	        let dy = new Vector3(0, box.max.y - box.min.y, 0);
	        let dz = new Vector3(0, 0, box.max.z - box.min.z);
	        return [
	            box.min.clone(),
	            box.min.clone().add(dx),
	            box.min.clone().add(dy),
	            box.min.clone().add(dz),
	            box.min.clone().add(dx).add(dy),
	            box.min.clone().add(dx).add(dz),
	            box.min.clone().add(dy).add(dz),
	            box.max.clone()
	        ];
	    }
	    /** Rounds a number in [0, 1] to a neighboring multiple of 1/`steps`. Has the additional property that f(x) = 0 -> x = 0 and f(x) = 1 -> 1. */
	    static cursedRound(x, steps) {
	        return Math.floor(((steps - 1) * x - Number.EPSILON) + 1) / steps;
	    }
	    static async checkDatabaseExists(dbName) {
	        return new Promise((resolve, reject) => {
	            let existed = true;
	            const req = indexedDB.open(dbName);
	            req.onsuccess = function () {
	                req.result.close();
	                if (!existed)
	                    indexedDB.deleteDatabase(dbName);
	                resolve(existed);
	            };
	            req.onerror = function () {
	                reject(new Error('Error opening database'));
	            };
	            req.onupgradeneeded = function () {
	                existed = false;
	            };
	        });
	    }
	}
	/** Taken from https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/blob/master/en. Lmao. */
	Util.naughtyWords = ["2g1c", "2 girls 1 cup", "acrotomophilia", "alabama hot pocket", "alaskan pipeline", "anal", "anilingus", "anus", "apeshit", "arsehole", "ass", "asshole", "assmunch", "auto erotic", "autoerotic", "babeland", "baby batter", "baby juice", "ball gag", "ball gravy", "ball kicking", "ball licking", "ball sack", "ball sucking", "bangbros", "bangbus", "bareback", "barely legal", "barenaked", "bastard", "bastardo", "bastinado", "bbw", "bdsm", "beaner", "beaners", "beaver cleaver", "beaver lips", "beastiality", "bestiality", "big black", "big breasts", "big knockers", "big tits", "bimbos", "birdlock", "bitch", "bitches", "black cock", "blonde action", "blonde on blonde action", "blowjob", "blow job", "blow your load", "blue waffle", "blumpkin", "bollocks", "bondage", "boner", "boob", "boobs", "booty call", "brown showers", "brunette action", "bukkake", "bulldyke", "bullet vibe", "bullshit", "bung hole", "bunghole", "busty", "butt", "buttcheeks", "butthole", "camel toe", "camgirl", "camslut", "camwhore", "carpet muncher", "carpetmuncher", "chocolate rosebuds", "cialis", "circlejerk", "cleveland steamer", "clit", "clitoris", "clover clamps", "clusterfuck", "cock", "cocks", "coprolagnia", "coprophilia", "cornhole", "coon", "coons", "creampie", "cum", "cumming", "cumshot", "cumshots", "cunnilingus", "cunt", "darkie", "date rape", "daterape", "deep throat", "deepthroat", "dendrophilia", "dick", "dildo", "dingleberry", "dingleberries", "dirty pillows", "dirty sanchez", "doggie style", "doggiestyle", "doggy style", "doggystyle", "dog style", "dolcett", "domination", "dominatrix", "dommes", "donkey punch", "double dong", "double penetration", "dp action", "dry hump", "dvda", "eat my ass", "ecchi", "ejaculation", "erotic", "erotism", "escort", "eunuch", "fag", "faggot", "fecal", "felch", "fellatio", "feltch", "female squirting", "femdom", "figging", "fingerbang", "fingering", "fisting", "foot fetish", "footjob", "frotting", "fuck", "fuck buttons", "fuckin", "fucking", "fucktards", "fudge packer", "fudgepacker", "futanari", "gangbang", "gang bang", "gay sex", "genitals", "giant cock", "girl on", "girl on top", "girls gone wild", "goatcx", "goatse", "god damn", "gokkun", "golden shower", "goodpoop", "goo girl", "goregasm", "grope", "group sex", "g-spot", "guro", "hand job", "handjob", "hard core", "hardcore", "hentai", "homoerotic", "honkey", "hooker", "horny", "hot carl", "hot chick", "how to kill", "how to murder", "huge fat", "humping", "incest", "intercourse", "jack off", "jail bait", "jailbait", "jelly donut", "jerk off", "jigaboo", "jiggaboo", "jiggerboo", "jizz", "juggs", "kike", "kinbaku", "kinkster", "kinky", "knobbing", "leather restraint", "leather straight jacket", "lemon party", "livesex", "lolita", "lovemaking", "make me come", "male squirting", "masturbate", "masturbating", "masturbation", "menage a trois", "milf", "missionary position", "mong", "motherfucker", "mound of venus", "mr hands", "muff diver", "muffdiving", "nambla", "nawashi", "negro", "neonazi", "nigga", "nigger", "nig nog", "nimphomania", "nipple", "nipples", "nsfw", "nsfw images", "nude", "nudity", "nutten", "nympho", "nymphomania", "octopussy", "omorashi", "one cup two girls", "one guy one jar", "orgasm", "orgy", "paedophile", "paki", "panties", "panty", "pedobear", "pedophile", "pegging", "penis", "phone sex", "piece of shit", "pikey", "pissing", "piss pig", "pisspig", "playboy", "pleasure chest", "pole smoker", "ponyplay", "poof", "poon", "poontang", "punany", "poop chute", "poopchute", "porn", "porno", "pornography", "prince albert piercing", "pthc", "pubes", "pussy", "queaf", "queef", "quim", "raghead", "raging boner", "rape", "raping", "rapist", "rectum", "reverse cowgirl", "rimjob", "rimming", "rosy palm", "rosy palm and her 5 sisters", "rusty trombone", "sadism", "santorum", "scat", "schlong", "scissoring", "semen", "sex", "sexcam", "sexo", "sexy", "sexual", "sexually", "sexuality", "shaved beaver", "shaved pussy", "shemale", "shibari", "shit", "shitblimp", "shitty", "shota", "shrimping", "skeet", "slanteye", "slut", "s&m", "smut", "snatch", "snowballing", "sodomize", "sodomy", "spastic", "spic", "splooge", "splooge moose", "spooge", "spread legs", "spunk", "strap on", "strapon", "strappado", "strip club", "style doggy", "suck", "sucks", "suicide girls", "sultry women", "swastika", "swinger", "tainted love", "taste my", "tea bagging", "threesome", "throating", "thumbzilla", "tied up", "tight white", "tit", "tits", "titties", "titty", "tongue in a", "topless", "tosser", "towelhead", "tranny", "tribadism", "tub girl", "tubgirl", "tushy", "twat", "twink", "twinkie", "two girls one cup", "undressing", "upskirt", "urethra play", "urophilia", "vagina", "venus mound", "viagra", "vibrator", "violet wand", "vorarephilia", "voyeur", "voyeurweb", "voyuer", "vulva", "wank", "wetback", "wet dream", "white power", "whore", "worldsex", "wrapping men", "wrinkled starfish", "xx", "xxx", "yaoi", "yellow showers", "yiffy", "zoophilia", "🖕"];
	/** Override dis if you want. */
	Util.getDefaultSecondsToTimeStringDecimalDigits = () => 3;
	Util.randomNumberQueue = [];
	Util.htmlEscapeElem = document.createElement('p');
	Util.macRomanToUtf8Map = ['Ä', 'Å', 'Ç', 'É', 'Ñ', 'Ö', 'Ü', 'á', 'à', 'â', 'ä', 'ã', 'å', 'ç', 'é', 'è', 'ê', 'ë', 'í', 'ì', 'î', 'ï', 'ñ', 'ó', 'ò', 'ô', 'ö', 'õ', 'ú', 'ù', 'û', 'ü', '†', '°', '¢', '£', '§', '•', '¶', 'ß', '®', '©', '™', '´', '¨', '≠', 'Æ', 'Ø', '∞', '±', '≤', '≥', '¥', 'µ', '∂', '∑', '∏', 'π', '∫', 'ª', 'º', 'Ω', 'æ', 'ø', '¿', '¡', '¬', '√', 'ƒ', '≈', '∆', '«', '»', '…', ' ', 'À', 'Ã', 'Õ', 'Œ', 'œ', '–', '—', '“', '”', '‘', '’', '÷', '◊', 'ÿ', 'Ÿ', '⁄', '€', '‹', '›', 'ﬁ', 'ﬂ', '‡', '·', '‚', '„', '‰', 'Â', 'Ê', 'Á', 'Ë', 'È', 'Í', 'Î', 'Ï', 'Ì', 'Ó', 'Ô', '🍎', 'Ò', 'Ú', 'Û', 'Ù', 'ı', 'ˆ', '˜', '¯', '˘', '˙', '˚', '¸', '˝', '˛', 'ˇ'];
	/** Produces a funny easter egg once in a while based on a stupid pun. */
	Util.isWeeb = Math.random() < 0.001; // Mazik <3
	Util.isTouchDevice = Util.checkIsTouchDevice(); // Precompute the thing
	/** A scheduler can be used to schedule tasks in the future which will be executed when it's time. */
	class Scheduler {
	    constructor() {
	        this.scheduled = [];
	    }
	    tickSchedule(time) {
	        for (let item of this.scheduled.slice()) {
	            if (time >= item.time) {
	                Util.removeFromArray(this.scheduled, item);
	                item.callback();
	            }
	        }
	    }
	    schedule(time, callback, id = null) {
	        this.scheduled.push({ time, callback, id });
	    }
	    clearSchedule() {
	        this.scheduled.length = 0;
	    }
	    clearScheduleId(id) {
	        for (let i = 0; i < this.scheduled.length; i++) {
	            if (this.scheduled[i].id === id)
	                this.scheduled.splice(i--, 1);
	        }
	    }
	}

	const workerBody = () => {
	    const respond = (msgId, payload) => {
	        self.postMessage({
	            msgId: msgId,
	            data: payload
	        });
	    };
	    let url = null;
	    self.onmessage = (e) => {
	        if (!url) {
	            // The first message received will be the url
	            url = e.data;
	            self.importScripts(url + 'lib/pako.js');
	            return;
	        }
	        let data = e.data;
	        if (data.command === 'compress') {
	            let compressed = pako.deflate(data.data);
	            respond(e.data.msgId, compressed);
	        }
	    };
	};
	// Create the worker by converting the function into a blob resource
	let entire = workerBody.toString();
	let body = entire.slice(entire.indexOf("{") + 1, entire.lastIndexOf("}"));
	let blob = new Blob([body]);
	let worker = new Worker(URL.createObjectURL(blob));
	let currentPromiseResolves = new Map();
	// https://stackoverflow.com/questions/22172426/using-importsscripts-within-blob-in-a-karma-environment
	worker.postMessage(window.location.href.slice(0, window.location.href.lastIndexOf('/') + 1));
	worker.onmessage = (e) => {
	    currentPromiseResolves.get(e.data.msgId)(e.data.data);
	};
	/** Executes a command with a payload on the worker. Returns a promise that resolves with the result. */
	const executeOnWorker = (command, payload) => {
	    let msgId = Util.getRandomId();
	    worker.postMessage({
	        msgId: msgId,
	        command: command,
	        data: payload
	    });
	    let promise = new Promise((resolve) => {
	        currentPromiseResolves.set(msgId, resolve);
	    });
	    return promise;
	};
	const timerWorkerBody = () => {
	    let idMap = new Map();
	    self.onmessage = (e) => {
	        let data = e.data;
	        if (data.command === 'setTimeout') {
	            let internalId = setTimeout(() => {
	                self.postMessage({
	                    externalId: data.externalId
	                });
	            }, data.timeout);
	            idMap.set(data.externalId, internalId);
	        }
	        else if (data.command === 'setInterval') {
	            let internalId = setInterval(() => {
	                self.postMessage({
	                    externalId: data.externalId
	                });
	            }, data.timeout);
	            idMap.set(data.externalId, internalId);
	        }
	        else if (data.command === 'clear') {
	            clearTimeout(idMap.get(data.externalId));
	            clearInterval(idMap.get(data.externalId));
	        }
	    };
	};
	let timerEntire = timerWorkerBody.toString();
	let timerBody = timerEntire.slice(timerEntire.indexOf("{") + 1, timerEntire.lastIndexOf("}"));
	let timerWorker = new Worker(URL.createObjectURL(new Blob([timerBody])));
	let timerId = 0;
	let handlerMap = new Map();
	timerWorker.onmessage = (ev) => {
	    let handler = handlerMap.get(ev.data.externalId);
	    handler === null || handler === void 0 ? void 0 : handler.func();
	    if (handler === null || handler === void 0 ? void 0 : handler.once)
	        handlerMap.delete(ev.data.externalId);
	};
	/** Works exactly like setTimeout, except that the timer runs on a Web Worker that keeps running in background tabs. */
	const workerSetTimeout = (handler, timeout = 0) => {
	    timerWorker.postMessage({
	        command: 'setTimeout',
	        timeout: timeout,
	        externalId: timerId
	    });
	    handlerMap.set(timerId, { func: handler, once: true });
	    return timerId++;
	};

	const MAX_SCORE_TIME = (99 * 60 + 59) * 1000 + 999.99; // The 99:59.999 thing
	const DEFAULT_STORAGE_DATA = {
	    settings: {
	        resolution: 2,
	        videoDriver: 0,
	        screenStyle: 0,
	        colorDepth: 1,
	        shadows: false,
	        musicVolume: 0.5,
	        soundVolume: 0.7,
	        gameButtonMapping: {
	            "up": "KeyW",
	            "down": "KeyS",
	            "left": "KeyA",
	            "right": "KeyD",
	            "jump": "Space",
	            "use": "LMB",
	            "cameraUp": "ArrowUp",
	            "cameraDown": "ArrowDown",
	            "cameraLeft": "ArrowLeft",
	            "cameraRight": "ArrowRight",
	            "freeLook": "RMB",
	            "restart": "KeyR",
	            "blast": "KeyE"
	        },
	        mouseSensitivity: 0.2,
	        keyboardSensitivity: 0.1,
	        invertMouse: 0,
	        alwaysFreeLook: true,
	        marbleReflectivity: 0,
	        showFrameRate: true,
	        showThousandths: true,
	        fov: 60,
	        fancyShaders: true,
	        pixelRatio: 2,
	        inputType: 0,
	        frameRateCap: 7,
	        canvasDesynchronized: !/(CrOS)/.test(navigator.userAgent),
	        joystickPosition: 0,
	        joystickSize: 250,
	        joystickLeftOffset: 75,
	        joystickVerticalPosition: 0.5,
	        actionButtonOrder: 0,
	        actionButtonSize: 120,
	        actionButtonRightOffset: 30,
	        actionButtonBottomOffset: 30,
	        actionButtonAsJoystickMultiplier: 1.5
	    },
	    bestTimes: {},
	    lastUsedName: '',
	    randomId: Util.getRandomId(),
	    bestTimeSubmissionQueue: [],
	    lastSeenVersion: null,
	    collectedEggs: [],
	    modification: 'platinum',
	    videoRecorderConfig: {
	        width: 1280,
	        height: 720,
	        kilobitRate: 5000,
	        frameRate: 60,
	        playbackSpeed: 1,
	        fastMode: true,
	        bt709: false,
	        includeAudio: true,
	        audioKilobitRate: 64,
	        musicToSoundRatio: 0.7
	    }
	};
	const VERSION_UPGRADE_PROCEDURES = {
	    '2.1.5': async () => {
	        // Got more performant now, so encourage people to have this on :)
	        StorageManager.data.settings.marbleReflectivity = 0;
	        await StorageManager.store();
	    },
	    '2.3.0': async () => {
	        // Got super pretty now, so encourage people to have this on :)
	        StorageManager.data.settings.marbleReflectivity = 0;
	        await StorageManager.store();
	    }
	};
	/** Manages storage and persistence. */
	class StorageManager {
	    static async init() {
	        // Set up the IndexedDB
	        if (indexedDB.databases) {
	            let allDatabases = await indexedDB.databases();
	            if (allDatabases.find(x => x.name === 'mb-database')) {
	                this.hadOldDatabase = true;
	            }
	        }
	        else {
	            if (Util.checkDatabaseExists('mb-database')) {
	                this.hadOldDatabase = true;
	            }
	        }
	        this.idbDatabaseLoading = new Promise((resolve) => {
	            let request = indexedDB.open("mbw", 3);
	            request.onsuccess = (e) => {
	                resolve();
	                this.idbDatabase = e.target.result;
	                this.idbDatabaseLoading = null;
	            };
	            request.onupgradeneeded = (e) => {
	                let db = e.target.result;
	                let transaction = e.target.transaction;
	                // For storing replays
	                try {
	                    db.createObjectStore('replays', {});
	                }
	                catch (error) {
	                    transaction.objectStore('replays');
	                }
	                // A simple key-value store
	                try {
	                    db.createObjectStore('keyvalue', {});
	                }
	                catch (error) {
	                    transaction.objectStore('keyvalue');
	                }
	            };
	        });
	        // Old storage format detected, let's migrate it
	        if (localStorage.getItem('mb-storage'))
	            await this.migrate();
	        // Get the storage data
	        let storageData = await this.databaseGet('keyvalue', 'storageData');
	        if (storageData) {
	            // Correct fields incase the stored data is stale / from an older version
	            this.data = this.correctFields(DEFAULT_STORAGE_DATA, storageData);
	        }
	        else {
	            this.data = DEFAULT_STORAGE_DATA;
	        }
	        // Override the inferred type
	        if (this.data.settings.inputType === 1)
	            Util.isTouchDevice = false;
	        else if (this.data.settings.inputType === 2)
	            Util.isTouchDevice = true;
	        // Get the best times and uncompress them
	        this.data.bestTimes = {};
	        let compressedBestTimes = await this.databaseGet('keyvalue', 'bestTimes');
	        if (compressedBestTimes) {
	            try {
	                let uncompressed = pako.inflate(compressedBestTimes, { to: 'string' });
	                let json = JSON.parse(uncompressed);
	                this.data.bestTimes = json;
	            }
	            catch (e) {
	                console.error("Error decoding best times!", e);
	            }
	        }
	        Util.getDefaultSecondsToTimeStringDecimalDigits = () => this.data.settings.showThousandths ? 3 : 2;
	    }
	    /** Migrates from localStorage to IndexedDB. */
	    static async migrate() {
	        let stored = JSON.parse(localStorage.getItem('mb-storage'));
	        this.data = stored;
	        for (let key in stored.bestTimes) {
	            for (let bestTime of stored.bestTimes[key]) {
	                bestTime[3] = 0; // Set timestamp to 0, indicating that this score shouldn't be uploaded to the leaderboards.
	            }
	        }
	        await this.store();
	        await this.storeBestTimes();
	        localStorage.removeItem('mb-storage');
	    }
	    static async store() {
	        let obj = Util.shallowClone(this.data);
	        delete obj.bestTimes;
	        await this.databasePut('keyvalue', obj, 'storageData');
	    }
	    static async storeBestTimes() {
	        let string = JSON.stringify(this.data.bestTimes);
	        let compressed = await executeOnWorker('compress', string); // Compress the best times to make them take up less space and harder to modify from the outside.
	        await this.databasePut('keyvalue', compressed, 'bestTimes');
	    }
	    /** Get the three best times for a mission path. */
	    static getBestTimesForMission(path, count, placeholderName) {
	        let result = [];
	        let stored = this.data.bestTimes[path];
	        if (stored) {
	            result.push(...stored);
	        }
	        result.sort((a, b) => a[1] - b[1]); // Make sure they're in ascending order
	        let remaining = count - result.length;
	        for (let i = 0; i < remaining; i++) {
	            // Fill the remaining slots with Nardo Polo scores
	            result.push([placeholderName, MAX_SCORE_TIME, "", 0]);
	        }
	        return result;
	    }
	    /** Register a new time for a mission.
	     * @returns The inserted score and the index at which at was inserted. Returns null, if the score wasn't inserted (so, not in the top maxScoresPerLevel best times).
	     */
	    static insertNewTime(path, name, time) {
	        var _a;
	        let stored = (_a = this.data.bestTimes[path]) !== null && _a !== void 0 ? _a : [];
	        let scoreId = Util.getRandomId();
	        let toInsert = [name, time, scoreId, Date.now()];
	        // Determine the correct index to insert the time at
	        let index;
	        for (index = 0; index < stored.length; index++) {
	            if (stored[index][1] > time)
	                break;
	        }
	        stored.splice(index, 0, toInsert);
	        // Shorten the array if needed
	        if (stored.length > this.maxScoresPerLevel) {
	            let lost = stored[this.maxScoresPerLevel];
	            stored = stored.slice(0, this.maxScoresPerLevel);
	            if (lost[2]) {
	                this.databaseGet('replays', lost[2]).then(replayData => {
	                    if (!replayData)
	                        return;
	                    this.databaseDelete('replays', lost[2]); // Delete the replay
	                });
	            }
	        }
	        this.data.bestTimes[path] = stored;
	        this.storeBestTimes();
	        if (index === this.maxScoresPerLevel)
	            return null;
	        return {
	            index,
	            score: toInsert
	        };
	    }
	    /** Gets an entry from an IndexedDB store by key. */
	    static async databaseGet(storeName, key) {
	        var _a;
	        await this.idbDatabaseLoading;
	        let db = this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readonly');
	        let store = transaction.objectStore(storeName);
	        let request = store.get(key);
	        await new Promise(resolve => request.onsuccess = resolve);
	        return (_a = request.result) !== null && _a !== void 0 ? _a : null;
	    }
	    /** Puts an entry into an IndexedDB store by key. */
	    static async databasePut(storeName, value, key) {
	        await this.idbDatabaseLoading;
	        let db = this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readwrite');
	        let store = transaction.objectStore(storeName);
	        store.put(value, key);
	        await new Promise(resolve => transaction.addEventListener('complete', resolve));
	    }
	    /** Deletes an entry from an IndexedDB store by key. */
	    static async databaseDelete(storeName, key) {
	        await this.idbDatabaseLoading;
	        let db = this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readwrite');
	        let store = transaction.objectStore(storeName);
	        store.delete(key);
	        await new Promise(resolve => transaction.addEventListener('complete', resolve));
	    }
	    /** Counts all entries in an IndexedDB store with a specific key. */
	    static async databaseCount(storeName, key) {
	        var _a;
	        await this.idbDatabaseLoading;
	        let db = this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readonly');
	        let store = transaction.objectStore(storeName);
	        let request = store.count(key);
	        await new Promise(resolve => request.onsuccess = resolve);
	        return (_a = request.result) !== null && _a !== void 0 ? _a : null;
	    }
	    /** Makes sure the second parameter has the same deep structure as the first. */
	    static correctFields(truth, obj) {
	        // Look for all fields present in the truth but not present in the object
	        for (let key in truth) {
	            if (!(key in obj))
	                obj[key] = truth[key]; // Copy the value
	            // If it's a non-empty non-array object, recurse
	            if (truth[key] && typeof truth[key] === 'object' && !Array.isArray(truth[key]) && Object.keys(truth[key]).length)
	                this.correctFields(truth[key], obj[key]);
	        }
	        // Look for all fields not present in the truth but present in the object
	        for (let key in obj) {
	            if (!(key in truth))
	                delete obj[key];
	        }
	        return obj;
	    }
	    /** Performs a series of modification needed to upgrade an old version. */
	    static async onVersionUpgrade(from) {
	        for (let vers in VERSION_UPGRADE_PROCEDURES) {
	            if (Util.compareVersions(from, vers) >= 0)
	                continue;
	            await VERSION_UPGRADE_PROCEDURES[vers]();
	        }
	    }
	}
	StorageManager.hadOldDatabase = false;
	StorageManager.maxScoresPerLevel = 5;

	/** Represents a WebGL program composed of a vertex and fragment shader. */
	class Program {
	    constructor(renderer, vertexSource, fragmentSource, defineChunk = "") {
	        /** For each vertex buffer group, store a VAO for faster binding later. */
	        this.vertexArrayObjects = new Map();
	        this.uniformLocations = new Map();
	        this.attributeLocations = new Map();
	        this.compileStatusChecked = false;
	        this.renderer = renderer;
	        let { gl } = renderer;
	        if (!(gl instanceof WebGLRenderingContext)) {
	            // We need to convert the shader to version 300 in order to use fancy WebGL2 features
	            [vertexSource, fragmentSource] = this.convertFromGLSL100ToGLSL300(vertexSource, fragmentSource);
	        }
	        // Inject definitions into both shaders
	        let useLogDepthBuf = !(gl instanceof WebGLRenderingContext) || !!renderer.extensions.EXT_frag_depth;
	        let definitions = `
			${useLogDepthBuf ? '#define LOG_DEPTH_BUF' : ''}
			${(gl instanceof WebGLRenderingContext) ? '#define IS_WEBGL1' : ''}
			${defineChunk}
		`;
	        vertexSource = vertexSource.replace('#include <definitions>', definitions);
	        fragmentSource = fragmentSource.replace('#include <definitions>', definitions);
	        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
	        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	        gl.shaderSource(this.vertexShader, vertexSource);
	        gl.shaderSource(this.fragmentShader, fragmentSource);
	        gl.compileShader(this.vertexShader);
	        gl.compileShader(this.fragmentShader);
	        let program = gl.createProgram();
	        gl.attachShader(program, this.vertexShader);
	        gl.attachShader(program, this.fragmentShader);
	        gl.linkProgram(program);
	        // We don't check compile/link status here because it's a synchronous operation that blocks until compilation completes. It's much more efficient to check it later.
	        this.glProgram = program;
	    }
	    convertFromGLSL100ToGLSL300(vertSrc, fragSrc) {
	        vertSrc = '#version 300 es\n' + vertSrc;
	        fragSrc = '#version 300 es\n' + fragSrc;
	        vertSrc = vertSrc.replace(/\nattribute /g, '\nin ');
	        vertSrc = vertSrc.replace(/\nvarying /g, '\nout ');
	        fragSrc = fragSrc.replace(/\nvarying /g, '\nin ');
	        fragSrc = fragSrc.replace('\nvoid main()', 'out vec4 FragColor;\nvoid main()'); // There is no gl_FragColor, so we make our own one
	        fragSrc = fragSrc.replace(/gl_FragColor/g, 'FragColor');
	        fragSrc = fragSrc.replace(/gl_FragDepthEXT/g, 'gl_FragDepth');
	        // Create alises for the sampler functions
	        let definitions = `
			#define texture2D texture
			#define textureCube texture
			#include <definitions>
		`;
	        vertSrc = vertSrc.replace('#include <definitions>', definitions);
	        fragSrc = fragSrc.replace('#include <definitions>', definitions);
	        return [vertSrc, fragSrc];
	    }
	    checkCompileStatus() {
	        let { gl } = this.renderer;
	        this.compileStatusChecked = true;
	        if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
	            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(this.vertexShader));
	            return;
	        }
	        if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
	            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(this.fragmentShader));
	            return;
	        }
	        if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) {
	            console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(this.glProgram));
	            return;
	        }
	    }
	    /** Enables this program and properly cleans up the previously-enabled program. */
	    use() {
	        var _a;
	        if (this.renderer.currentProgram === this)
	            return;
	        if (!this.compileStatusChecked)
	            this.checkCompileStatus();
	        (_a = this.renderer.currentProgram) === null || _a === void 0 ? void 0 : _a.unuse();
	        this.renderer.gl.useProgram(this.glProgram);
	        this.renderer.currentProgram = this;
	    }
	    unuse() {
	        let { gl } = this.renderer;
	        this.renderer.bindVertexArray(null); // Disable the VAO first so that VBO changes aren't stored into it
	        for (let [, loc] of this.attributeLocations)
	            gl.disableVertexAttribArray(loc);
	    }
	    /** Binds a group of VBOs and stores the state in a VAO for faster reuse later. */
	    bindVertexBufferGroup(group) {
	        if (this.vertexArrayObjects.has(group)) {
	            // We've already seen this vertex group, just bind the VAO
	            this.renderer.bindVertexArray(this.vertexArrayObjects.get(group));
	            return;
	        }
	        let { gl } = this.renderer;
	        let vao = this.renderer.createVertexArray();
	        this.renderer.bindVertexArray(vao);
	        for (let buffer of group.buffers)
	            this.bindVertexBuffer(buffer);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); // VAOs also store the currently-bound element array buffer, and since we want a clean VAO, just bind null here
	        this.vertexArrayObjects.set(group, vao);
	    }
	    /** Binds a single vertex buffer and all attributes associated with it. */
	    bindVertexBuffer(buf) {
	        let { gl } = this.renderer;
	        gl.bindBuffer(gl.ARRAY_BUFFER, buf.buffer);
	        let offset = 0;
	        // Simply loop over all attributes and create vertex attribute pointers for them
	        for (let attribute in buf.attributes) {
	            let itemSize = buf.attributes[attribute];
	            let thisOffset = offset;
	            offset += itemSize;
	            let location = this.attributeLocations.get(attribute);
	            if (location === undefined) {
	                location = gl.getAttribLocation(this.glProgram, attribute);
	                if (location >= 0)
	                    this.attributeLocations.set(attribute, location);
	            }
	            if (location === -1)
	                continue;
	            gl.enableVertexAttribArray(location);
	            gl.vertexAttribPointer(location, itemSize, gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT * buf.stride, Float32Array.BYTES_PER_ELEMENT * thisOffset);
	        }
	    }
	    getUniformLocation(name) {
	        if (this.uniformLocations.has(name))
	            return this.uniformLocations.get(name);
	        let { gl } = this.renderer;
	        let location = gl.getUniformLocation(this.glProgram, name);
	        this.uniformLocations.set(name, location);
	        return location;
	    }
	    cleanUp() {
	        // We only need to trash the VAO
	        this.renderer.bindVertexArray(null);
	        for (let [, vao] of this.vertexArrayObjects)
	            this.renderer.deleteVertexArray(vao);
	        this.vertexArrayObjects.clear();
	    }
	}

	var shadowMapVert = "precision highp float;\nprecision highp int;\n\n#include <definitions>\n\nattribute vec3 position;\nattribute float meshInfoIndex;\n\nuniform highp sampler2D meshInfos;\nuniform int meshInfoTextureWidth;\nuniform int meshInfoTextureHeight;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nint _mod(int a, int n) {\n\t#ifdef IS_WEBGL1\n\t\treturn a - n * (a / n);\n\t#else\n\t\treturn a % n;\n\t#endif\n}\n\n// Refer to material_vert.glsl for an explanation of what this does\nmat4 getMeshInfo(int index) {\n\tivec2 coords = ivec2(\n\t\t_mod(4 * index, meshInfoTextureWidth),\n\t\t(4 * index) / meshInfoTextureWidth\n\t);\n\n\t#ifdef IS_WEBGL1\n\t\treturn mat4(\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(0, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(1, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(2, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(3, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight))\n\t\t);\n\t#else\n\t\treturn mat4(\n\t\t\ttexelFetch(meshInfos, coords + ivec2(0, 0), 0),\n\t\t\ttexelFetch(meshInfos, coords + ivec2(1, 0), 0),\n\t\t\ttexelFetch(meshInfos, coords + ivec2(2, 0), 0),\n\t\t\ttexelFetch(meshInfos, coords + ivec2(3, 0), 0)\n\t\t);\n\t#endif\n}\n\nvoid main() {\n\tmat4 meshInfo = getMeshInfo(int(meshInfoIndex + 0.1)); // + 0.1 to make sure it casts correctly, lol\n\tmat4 transform = meshInfo;\n\ttransform[0][3] = 0.0;\n\ttransform[1][3] = 0.0;\n\ttransform[2][3] = 0.0;\n\ttransform[3][3] = 1.0;\n\tfloat opacity = meshInfo[0][3];\n\n\tif (opacity < 1.0) {\n\t\t// Non-opaque objects don't cast shadows in our perfect world\n\t\tgl_Position = vec4(0.0);\n\t\treturn;\n\t}\n\n\t// Simply transform the vertex and we're done\n\tmat4 mvp = projectionMatrix * viewMatrix * transform;\n\tgl_Position = mvp * vec4(position, 1.0);\n}";

	var shadowMapFrag = "precision mediump float;\n\n#include <definitions>\n\nvoid main() {\n\tgl_FragColor = vec4(1.0); // Simple pass-through shader\n}";

	var particleVert = "precision highp float;\n\n#include <definitions>\n\nattribute vec2 position;\nattribute vec2 uv;\nattribute float particleSpawnTime;\nattribute float particleLifetime;\nattribute vec3 particlePosition;\nattribute vec3 particleVelocity;\nattribute float particleInitialSpin;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float time;\nuniform float acceleration;\nuniform float spinSpeed;\nuniform float dragCoefficient;\nuniform vec4 times;\nuniform vec4 sizes;\nuniform mat4 colors;\n\nvarying vec2 vUv;\nvarying float vFragDepth;\nvarying float vIsPerspective;\nvarying vec4 color;\n\nbool isPerspectiveMatrix(mat4 m) {\n\treturn m[2][3] == -1.0;\n}\n\n// Dynamic access of vecs and mats doesn't work properly in WebGL, so wrap the functionality in a function that does it the ugly way.\nfloat accessDynamically(vec4 data, int idx) {\n\t#ifdef IS_WEBGL1\n\t\t// Since all these indices are known at compile-time, this works just fine\n\t\tif (idx == 0) return data[0];\n\t\tif (idx == 1) return data[1];\n\t\tif (idx == 2) return data[2];\n\t\treturn data[3];\n\t#else\n\t\treturn data[idx];\n\t#endif\n}\n\nvec4 accessDynamically(mat4 data, int idx) {\n\t#ifdef IS_WEBGL1\n\t\tif (idx == 0) return data[0];\n\t\tif (idx == 1) return data[1];\n\t\tif (idx == 2) return data[2];\n\t\treturn data[3];\n\t#else\n\t\treturn data[idx];\n\t#endif\n}\n\nvoid main() {\n\tfloat elapsed = time - particleSpawnTime;\n\tfloat completion = clamp(elapsed / particleLifetime, 0.0, 1.0);\n\n\tif (completion == 1.0) {\n\t\t// We're dead, don't render\n\t\tgl_Position = vec4(0.0);\n\t\treturn;\n\t}\n\n\tfloat velElapsed = elapsed / 1000.0;\n\tvelElapsed = pow(velElapsed, 1.0 - dragCoefficient);\n\n\t// Compute the position\n\tvec3 computedPosition = particlePosition + particleVelocity * (velElapsed + acceleration * velElapsed * velElapsed / 2.0);\n\tfloat rotation = particleInitialSpin + spinSpeed * elapsed / 1000.0;\n\n\t// Check where we are in the times array\n\tint indexLow = 0;\n\tint indexHigh = 1;\n\tfor (int i = 2; i < 4; i++) {\n\t\tif (times[indexHigh] >= completion) break;\n\n\t\tindexLow = indexHigh;\n\t\tindexHigh = i;\n\t}\n\tif (times[1] > 1.0) indexHigh = indexLow; // Basically checking if (this.o.times.length === 1)\n\tfloat timeLow = accessDynamically(times, indexLow);\n\tfloat timeHigh = accessDynamically(times, indexHigh);\n\tfloat t = (completion - timeLow) / (timeHigh - timeLow);\n\n\t// Compute the color to send to the fragment shader\n\tcolor = mix(accessDynamically(colors, indexLow), accessDynamically(colors, indexHigh), t);\n\tcolor.a = pow(color.a, 1.5); // Adjusted because additive mixing can be kind of extreme\n\n\tvec4 viewPosition = viewMatrix * vec4(computedPosition, 1.0);\n\n\tvec2 scale = vec2(1.0);\n\tscale *= mix(accessDynamically(sizes, indexLow), accessDynamically(sizes, indexHigh), t); // Adjust sizing\n\n\t// Enable the following code if you don't want to attenuate the size with growing distance:\n\t// scale *= -viewPosition.z;\n\n\tvec2 center = vec2(0.5, 0.5); // Fixed, for now\n\tvec2 alignedPosition = (position - (center - vec2(0.5))) * scale;\n\tvec2 rotatedPosition;\n\n\trotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\n\trotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\n\tviewPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * viewPosition;\n\n\tvUv = uv;\n\n\t#ifdef LOG_DEPTH_BUF\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\n\t#endif\n}";

	var particleFrag = "precision mediump float;\n\n#include <definitions>\n\nvarying vec2 vUv;\nvarying float vFragDepth;\nvarying float vIsPerspective;\nvarying vec4 color;\n\nuniform sampler2D diffuseMap;\nuniform float logDepthBufFC;\n\n#if defined(LOG_DEPTH_BUF) && defined(IS_WEBGL1)\n\t#extension GL_EXT_frag_depth : enable\n#endif\n\nvoid main() {\n\tgl_FragColor = color * texture2D(diffuseMap, vUv);\n\t\n\t#ifdef LOG_DEPTH_BUF\n\t\t// We always need to set gl_FragDepthEXT when it's present in the file, otherwise it gets real weird\n\t\t// Also: Doing a strict comparison with == 1.0 can cause noise artifacts\n\t\tgl_FragDepthEXT = (vIsPerspective != 0.0)? log2(vFragDepth) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n\t#endif\n}";

	/**
	 * Provides utility functions for parsing DirectDraw Surface (DDS) textures.
	 */
	class DdsParser {
	    static async toImage(buffer) {
	        let data = new DataView(buffer);
	        // Check the DDS magic number
	        if (data.getUint32(0, true) !== 0x20534444) {
	            throw new Error('Not a valid DDS file');
	        }
	        // Check for DXT1 fourCC
	        let fourCC = String.fromCharCode(data.getUint8(84), data.getUint8(85), data.getUint8(86), data.getUint8(87));
	        if (fourCC !== 'DXT1') {
	            throw new Error('Only DXT1 format is supported');
	        }
	        let height = data.getUint32(12, true);
	        let width = data.getUint32(16, true);
	        // RGBA buffer for putImageData
	        let rgbaData = new Uint8ClampedArray(width * height * 4);
	        let offset = 128;
	        for (let y = 0; y < height; y += 4) {
	            for (let x = 0; x < width; x += 4) {
	                let color0 = data.getUint16(offset, true);
	                let color1 = data.getUint16(offset + 2, true);
	                let r0 = (color0 & 0xF800) >> 8;
	                let g0 = (color0 & 0x07E0) >> 3;
	                let b0 = (color0 & 0x001F) << 3;
	                let r1 = (color1 & 0xF800) >> 8;
	                let g1 = (color1 & 0x07E0) >> 3;
	                let b1 = (color1 & 0x001F) << 3;
	                let lookupTable = data.getUint32(offset + 4, true);
	                for (let blockY = 0; blockY < 4; blockY++) {
	                    for (let blockX = 0; blockX < 4; blockX++) {
	                        let pixelIndex = ((y + blockY) * width + (x + blockX)) * 4;
	                        let index = (lookupTable >> (2 * (blockY * 4 + blockX))) & 0x03;
	                        if (color0 > color1) {
	                            switch (index) {
	                                case 0:
	                                    rgbaData.set([r0, g0, b0, 255], pixelIndex);
	                                    break;
	                                case 1:
	                                    rgbaData.set([r1, g1, b1, 255], pixelIndex);
	                                    break;
	                                case 2:
	                                    rgbaData.set([(2 * r0 + r1) / 3, (2 * g0 + g1) / 3, (2 * b0 + b1) / 3, 255], pixelIndex);
	                                    break;
	                                case 3:
	                                    rgbaData.set([(r0 + 2 * r1) / 3, (g0 + 2 * g1) / 3, (b0 + 2 * b1) / 3, 255], pixelIndex);
	                                    break;
	                            }
	                        }
	                        else {
	                            switch (index) {
	                                case 0:
	                                    rgbaData.set([r0, g0, b0, 255], pixelIndex);
	                                    break;
	                                case 1:
	                                    rgbaData.set([r1, g1, b1, 255], pixelIndex);
	                                    break;
	                                case 2:
	                                    rgbaData.set([(r0 + r1) / 2, (g0 + g1) / 2, (b0 + b1) / 2, 255], pixelIndex);
	                                    break;
	                                case 3:
	                                    rgbaData.set([0, 0, 0, 0], pixelIndex); // Transparent
	                                    break;
	                            }
	                        }
	                    }
	                }
	                offset += 8;
	            }
	        }
	        let canvas = document.createElement('canvas');
	        canvas.width = width;
	        canvas.height = height;
	        let ctx = canvas.getContext('2d');
	        let imageData = new ImageData(rgbaData, width, height);
	        ctx.putImageData(imageData, 0, 0);
	        let canvasDataUrl = canvas.toDataURL();
	        let newImage = new Image();
	        newImage.src = canvasDataUrl;
	        await new Promise(resolve => newImage.onload = resolve);
	        return newImage;
	    }
	}

	class Texture {
	    constructor(image) {
	        this.id = Util.getRandomId();
	        /** A single texture instance can be used by multiple renderering contexts, that's why we use a map here. */
	        this.glTextures = new Map();
	        if (!image.complete)
	            throw new Error("Can only pass loaded images into Texture.");
	        this.image = image;
	    }
	    /** Gets a WebGLTexture object for this texture for a given renderer. Creates one if it doesn't exist yet. */
	    getGLTexture(renderer) {
	        let glTexture = this.glTextures.get(renderer);
	        if (glTexture)
	            return glTexture;
	        let { gl } = renderer;
	        glTexture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, glTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
	        gl.generateMipmap(gl.TEXTURE_2D); // Make sure to enable mipmapping
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	        if (renderer.extensions.EXT_texture_filter_anisotropic)
	            gl.texParameteri(gl.TEXTURE_2D, renderer.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, 4); // Anisotropy to make it loop *sharp*
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        this.glTextures.set(renderer, glTexture);
	    }
	}

	const imageCacheElement = document.querySelector('#image-cache');
	const MBP_REDIRECT_RULES = {
	    'assets/data_mbp/sound/gotgem.wav': 'assets/data_mbp/sound/gotdiamond.wav',
	    'assets/data_mbp/sound/gotallgems.wav': 'assets/data_mbp/sound/gotalldiamonds.wav',
	    'assets/data_mbp/sound/music/groovepolice': 'assets/data_mbp/sound/music/groove police'
	};
	/** Manages loading and caching of resources. */
	class ResourceManager {
	    static get mainDataPath() {
	        return (state.modification === 'gold') ? './assets/data/' : './assets/data_mbp/';
	    }
	    static async init() {
	        let promiseMbg = this.loadResource('./api/directory_structure');
	        let promiseMbp = this.loadResource('./api/directory_structure_mbp');
	        let [responseMbg, responseMbp] = await Promise.all([promiseMbg, promiseMbp]);
	        this.dataDirectoryStructure = JSON.parse(await this.readBlobAsText(responseMbg));
	        this.dataMbpDirectoryStructure = JSON.parse(await this.readBlobAsText(responseMbp));
	    }
	    /** Creates a Texture from the path, or returns the cached version. */
	    static getTexture(path, prependPath = this.mainDataPath) {
	        let fullPath = prependPath + path;
	        let cached = this.textureCache.get(fullPath);
	        if (cached)
	            return Promise.resolve(cached);
	        if (this.loadTexturePromises.get(fullPath))
	            return this.loadTexturePromises.get(fullPath);
	        let promise = new Promise(async (resolve) => {
	            let image = await this.loadImage(fullPath);
	            let texture = new Texture(image);
	            texture.getGLTexture(mainRenderer); // Any texture is immediately uploaded to the main renderer context as a preloading measure. This avoids flickering later.
	            this.textureCache.set(fullPath, texture);
	            this.loadTexturePromises.delete(fullPath);
	            resolve(texture);
	        });
	        this.loadTexturePromises.set(fullPath, promise);
	        return promise;
	    }
	    static getTextureFromCache(path, prependPath = this.mainDataPath) {
	        let fullPath = prependPath + path;
	        let cached = this.textureCache.get(fullPath);
	        if (cached)
	            return cached;
	        return null;
	    }
	    /** Gets the full filenames (with extension) of the file located at the given path (without extension). */
	    static getFullNamesOf(path, mbp = state.modification === 'platinum') {
	        let parts = path.split('/');
	        let current = mbp ? this.dataMbpDirectoryStructure : this.dataDirectoryStructure;
	        while (parts.length) {
	            let part = parts.shift();
	            if (parts.length === 0) {
	                let results = [];
	                for (let name in current) {
	                    if (name.toLowerCase().startsWith(part.toLowerCase())
	                        // Make sure nothing or only the extension follows
	                        && (name.length === part.length || part.length === name.lastIndexOf('.')))
	                        results.push(name);
	                }
	                return results;
	            }
	            else {
	                current = current[part];
	                if (!current)
	                    return [];
	            }
	        }
	    }
	    static redirectPath(path) {
	        if (state.modification !== 'gold') {
	            for (let key in MBP_REDIRECT_RULES) {
	                if (path.includes(key))
	                    return path.replace(key, MBP_REDIRECT_RULES[key]);
	            }
	        }
	        return path;
	    }
	    /** Loads a resource from a path. Retries until it worked. */
	    static loadResource(path) {
	        path = this.redirectPath(path);
	        let cached = this.cachedResources.get(path);
	        if (cached)
	            return Promise.resolve(cached);
	        if (this.loadResourcePromises.get(path))
	            return this.loadResourcePromises.get(path);
	        let promise = new Promise((resolve, reject) => {
	            const attempt = async () => {
	                try {
	                    let response = await fetch(path);
	                    if (response.status === 404) {
	                        this.cachedResources.set(path, null);
	                        this.loadResourcePromises.delete(path);
	                        resolve(null);
	                        return;
	                    }
	                    else if (!response.ok) {
	                        // If we get an error code that isn't 404, the resource isn't just missing, but the request failed somehow. Throw.
	                        reject(`Error getting resource (${response.status}): ` + path);
	                        this.loadResourcePromises.delete(path);
	                        return;
	                    }
	                    // Retrieve the blob and store it
	                    let blob = await response.blob();
	                    this.cachedResources.set(path, blob);
	                    this.loadResourcePromises.delete(path);
	                    resolve(blob);
	                }
	                catch (e) {
	                    // Try again in a second
	                    setTimeout(attempt, 1000);
	                }
	            };
	            attempt();
	        });
	        this.loadResourcePromises.set(path, promise);
	        return promise;
	    }
	    /** Preloads an image at a given path. */
	    static loadImage(path, originalPath = path) {
	        if (this.loadedImages.get(path))
	            return Promise.resolve(this.loadedImages.get(path));
	        if (this.loadImagePromises.get(path))
	            return this.loadImagePromises.get(path);
	        let promise = new Promise(async (resolve, reject) => {
	            if (originalPath.toLowerCase().endsWith('.dds')) {
	                // DDS images can't be loaded normally, so let's do it ourselves:
	                let arrayBuffer = await this.readBlobAsArrayBuffer(await this.loadResource(path));
	                try {
	                    let image = await DdsParser.toImage(arrayBuffer);
	                    resolve(image);
	                }
	                catch (e) {
	                    reject(e);
	                }
	                return;
	            }
	            let image = new Image();
	            image.src = path;
	            image.onload = () => {
	                imageCacheElement.appendChild(image);
	                this.loadedImages.set(path, image);
	                this.loadImagePromises.delete(path);
	                resolve(image);
	                image.onload = null; // GC requires me to do this
	            };
	            image.onerror = (e) => {
	                reject(e);
	            };
	        });
	        this.loadImagePromises.set(path, promise);
	        return promise;
	    }
	    static loadImages(paths) {
	        return Promise.all(paths.map((path) => this.loadImage(path)));
	    }
	    static getImageFromCache(path) {
	        return this.loadedImages.get(path) || null;
	    }
	    static readBlobAsText(blob, encoding) {
	        if (blob.text)
	            return blob.text();
	        else
	            return new Promise((resolve) => {
	                let reader = new FileReader();
	                reader.onload = (e) => resolve(e.target.result);
	                reader.readAsText(blob, encoding);
	            });
	    }
	    static async readBlobAsJson(blob, encoding) {
	        let text = await this.readBlobAsText(blob, encoding);
	        return JSON.parse(text);
	    }
	    static readBlobAsArrayBuffer(blob) {
	        if (blob.arrayBuffer)
	            return blob.arrayBuffer();
	        else
	            return new Promise((resolve) => {
	                let reader = new FileReader();
	                reader.onload = (e) => resolve(e.target.result);
	                reader.readAsArrayBuffer(blob);
	            });
	    }
	    static readBlobAsDataUrl(blob) {
	        return new Promise((resolve) => {
	            let reader = new FileReader();
	            reader.onload = (e) => resolve(e.target.result);
	            reader.readAsDataURL(blob);
	        });
	    }
	    /** Converts a blob to a temporary URL. Returns a cached URL whenever possible. */
	    static getUrlToBlob(blob) {
	        if (this.urlCache.get(blob))
	            return this.urlCache.get(blob);
	        let url = URL.createObjectURL(blob);
	        this.urlCache.set(blob, url);
	        return url;
	    }
	    /** Fetches a URL until a response a received. */
	    static retryFetch(input, init) {
	        return new Promise(resolve => {
	            const attempt = async () => {
	                try {
	                    let response = await fetch(input, init);
	                    if (response.status === 404) {
	                        resolve(null);
	                        return;
	                    }
	                    let blob = await response.blob();
	                    resolve(blob);
	                }
	                catch (e) {
	                    setTimeout(attempt, 1000);
	                }
	            };
	            attempt();
	        });
	    }
	}
	ResourceManager.textureCache = new Map();
	ResourceManager.loadTexturePromises = new Map();
	/** The structure in the assets/data directory. Used mainly to look up file extensions. */
	ResourceManager.dataDirectoryStructure = {};
	ResourceManager.dataMbpDirectoryStructure = {};
	ResourceManager.loadResourcePromises = new Map();
	ResourceManager.cachedResources = new Map();
	ResourceManager.loadImagePromises = new Map();
	ResourceManager.loadedImages = new Map();
	ResourceManager.urlCache = new Map();

	var BlendingType;
	(function (BlendingType) {
	    BlendingType[BlendingType["Normal"] = 0] = "Normal";
	    BlendingType[BlendingType["Additive"] = 1] = "Additive";
	    BlendingType[BlendingType["Subtractve"] = 2] = "Subtractve";
	})(BlendingType || (BlendingType = {}));
	const DEFAULT_CONTEXT_OPTIONS = {
	    alpha: false,
	    desynchronized: false
	};
	/** The renderer is the central keeper of the WebGL rendering context and performs the actual rendering of a scene. */
	class Renderer {
	    constructor(options) {
	        this.currentProgram = null;
	        /** Maps #define chunks, which uniquely identify a shader, to the program containing that shader. */
	        this.materialShaders = new Map();
	        this.pixelRatio = 1;
	        this.currentFramebuffer = null;
	        this.debugMode = 0;
	        this.extensions = {
	            EXT_texture_filter_anisotropic: null,
	            EXT_frag_depth: null,
	            OES_element_index_uint: null,
	            WEBGL_depth_texture: null,
	            OES_standard_derivatives: null,
	            KHR_parallel_shader_compile: null,
	            OES_texture_float: null,
	            OES_vertex_array_object: null
	        };
	        options = { ...DEFAULT_CONTEXT_OPTIONS, ...options };
	        this.options = options;
	        let ctxOptions = {
	            desynchronized: options.desynchronized,
	            depth: true,
	            stencil: true,
	            antialias: false,
	            powerPreference: 'high-performance',
	            alpha: options.alpha,
	            premultipliedAlpha: true
	        };
	        this.gl = options.canvas.getContext('webgl2', ctxOptions);
	        if (!this.gl)
	            this.gl = options.canvas.getContext('webgl', ctxOptions);
	        let { gl } = this;
	        // Get all the extensions we need; many of these are enabled in WebGL2 by default:
	        this.extensions.EXT_texture_filter_anisotropic =
	            gl.getExtension('EXT_texture_filter_anisotropic') ||
	                gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
	                gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
	        this.extensions.EXT_frag_depth = gl.getExtension('EXT_frag_depth');
	        this.extensions.OES_element_index_uint = gl.getExtension('OES_element_index_uint');
	        this.extensions.WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');
	        this.extensions.OES_standard_derivatives = gl.getExtension('OES_standard_derivatives');
	        this.extensions.KHR_parallel_shader_compile = gl.getExtension('KHR_parallel_shader_compile');
	        this.extensions.OES_texture_float = gl.getExtension('OES_texture_float');
	        this.extensions.OES_vertex_array_object = gl.getExtension('OES_vertex_array_object');
	        this.shadowMapProgram = new Program(this, shadowMapVert, shadowMapFrag);
	        this.particleProgram = new Program(this, particleVert, particleFrag);
	        gl.clearColor(0.0, 0.0, 0.0, Number(!options.alpha));
	        gl.clearDepth(1.0);
	        gl.enable(gl.DEPTH_TEST);
	        gl.depthFunc(gl.LEQUAL);
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.BACK);
	        gl.frontFace(gl.CCW);
	    }
	    setSize(width, height) {
	        this.width = width;
	        this.height = height;
	        this.updateCanvasDimensions();
	    }
	    setPixelRatio(pixelRatio) {
	        this.pixelRatio = pixelRatio;
	        this.updateCanvasDimensions();
	    }
	    updateCanvasDimensions() {
	        this.options.canvas.setAttribute('width', Math.ceil(this.width * this.pixelRatio).toString());
	        this.options.canvas.setAttribute('height', Math.ceil(this.height * this.pixelRatio).toString());
	    }
	    setClearColor(r, g, b, a) {
	        this.gl.clearColor(r, g, b, a);
	    }
	    /** Renders a scene to a framebuffer (or the canvas) from the perspective of a camera. */
	    render(scene, camera, framebuffer = null, clearColorBuffer = true) {
	        if (!scene.compiled)
	            throw new Error("Scene not compiled! Can't render it.");
	        if (!scene.preparedForRender)
	            throw new Error("Scene not prepared for render! Can't render it.");
	        let { gl } = this;
	        this.drawCalls = 0;
	        if (framebuffer) {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);
	            gl.viewport(0, 0, framebuffer.width, framebuffer.height);
	        }
	        else {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	            gl.viewport(0, 0, Math.ceil(this.width * this.pixelRatio), Math.ceil(this.height * this.pixelRatio));
	        }
	        this.currentFramebuffer = framebuffer;
	        gl.depthMask(true);
	        gl.clear(gl.DEPTH_BUFFER_BIT);
	        if (clearColorBuffer)
	            gl.clear(gl.COLOR_BUFFER_BIT);
	        // Precompute some uniform values
	        let uViewMatrix = new Float32Array(camera.matrixWorldInverse.elements);
	        let uProjectionMatrix = new Float32Array(camera.projectionMatrix.elements);
	        let uInverseProjectionMatrix = new Float32Array(camera.projectionMatrix.clone().invert().elements);
	        let uLogDepthBufFC = 2.0 / (Math.log(camera.far + 1.0) / Math.LN2); // Used for logarithmic depth buffer
	        let uEyePosition = new Float32Array(camera.position.toArray());
	        // Init the uniforms needed by all programs
	        for (let defineChunk of scene.allDefineChunks) {
	            let program = this.materialShaders.get(defineChunk);
	            program.use();
	            gl.uniformMatrix4fv(program.getUniformLocation('viewMatrix'), false, uViewMatrix);
	            gl.uniformMatrix4fv(program.getUniformLocation('projectionMatrix'), false, uProjectionMatrix);
	            gl.uniformMatrix4fv(program.getUniformLocation('inverseProjectionMatrix'), false, uInverseProjectionMatrix);
	            gl.uniform1f(program.getUniformLocation('logDepthBufFC'), uLogDepthBufFC);
	            gl.uniform3fv(program.getUniformLocation('eyePosition'), uEyePosition);
	            gl.uniform1i(program.getUniformLocation('meshInfoTextureWidth'), scene.meshInfoTextureWidth);
	            gl.uniform1i(program.getUniformLocation('meshInfoTextureHeight'), scene.meshInfoTextureHeight);
	            gl.uniform3fv(program.getUniformLocation('ambientLight'), scene.ambientLightBuffer);
	            gl.uniform3fv(program.getUniformLocation('directionalLightColor'), scene.directionalLightColorBuffer);
	            gl.uniform3fv(program.getUniformLocation('directionalLightDirection'), scene.directionalLightDirectionBuffer);
	            gl.uniformMatrix4fv(program.getUniformLocation('directionalLightTransform'), false, scene.directionalLightTransformBuffer);
	            gl.uniform1i(program.getUniformLocation('meshInfos'), 7);
	            this.bindTexture(scene.meshInfoTexture, 7, gl.TEXTURE_2D);
	            gl.uniform1i(program.getUniformLocation('diffuseMap'), 0);
	            gl.uniform1i(program.getUniformLocation('envMap'), 1);
	            gl.uniform1i(program.getUniformLocation('directionalLightShadowMap'), 2);
	            gl.uniform1i(program.getUniformLocation('normalMap'), 3);
	            gl.uniform1i(program.getUniformLocation('specularMap'), 4);
	            gl.uniform1i(program.getUniformLocation('noiseMap'), 5);
	            gl.uniform1i(program.getUniformLocation('debugMode'), Number(this.debugMode));
	        }
	        // First, we draw all opaque objects
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, scene.opaqueIndexBuffer);
	        gl.disable(gl.BLEND);
	        this.renderMaterialGroups(scene, scene.opaqueMaterialGroups, scene.opaqueIndexBuffer, true);
	        // Then, we draw all transparent objects
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, scene.transparentIndexBuffer);
	        gl.enable(gl.BLEND);
	        this.renderMaterialGroups(scene, scene.transparentMaterialGroups, scene.transparentIndexBuffer, false);
	        // Lastly, we render particles
	        if (scene.particleManager)
	            this.renderParticles(scene.particleManager, camera);
	    }
	    renderMaterialGroups(scene, groups, indexBuffer, skipTransparent) {
	        var _a, _b, _c, _d, _e, _f;
	        let { gl } = this;
	        for (let group of groups) {
	            if (group.indexGroups.length === 0 || group.indexGroups[0].indices.length === 0)
	                continue; // No need to waste gl calls on an empty material group
	            let material = group.material;
	            if (!material.visible)
	                continue;
	            let program = this.materialShaders.get(group.defineChunk);
	            program.use();
	            program.bindVertexBufferGroup(scene.bufferGroup); // Bind the VAO, this will automatically set up all vertex attribute pointers
	            // Set uniforms related to the material
	            gl.uniform1i(program.getUniformLocation('skipTransparent'), Number(skipTransparent));
	            gl.uniform1f(program.getUniformLocation('materialOpacity'), material.opacity);
	            gl.uniform1f(program.getUniformLocation('specularIntensity'), material.specularIntensity);
	            gl.uniform1f(program.getUniformLocation('shininess'), material.shininess);
	            gl.uniform1f(program.getUniformLocation('reflectivity'), material.reflectivity);
	            gl.uniform1f(program.getUniformLocation('secondaryMapUvFactor'), material.secondaryMapUvFactor);
	            if (material.blending === BlendingType.Normal)
	                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // Premultiplied alpha
	            else if (material.blending === BlendingType.Additive)
	                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	            else if (material.blending === BlendingType.Subtractve)
	                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // I actually dunno if this one's correct
	            gl.depthMask(material.depthWrite);
	            // Bind all textures
	            if (material.receiveShadows || material.isShadow)
	                (_a = scene.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.bindShadowMap(); // Will bind to texture unit 2
	            this.bindTexture((_b = material.diffuseMap) === null || _b === void 0 ? void 0 : _b.getGLTexture(this), 0, gl.TEXTURE_2D);
	            this.bindTexture((_c = material.envMap) === null || _c === void 0 ? void 0 : _c.glTexture, 1, gl.TEXTURE_CUBE_MAP);
	            this.bindTexture((_d = material.normalMap) === null || _d === void 0 ? void 0 : _d.getGLTexture(this), 3, gl.TEXTURE_2D);
	            this.bindTexture((_e = material.specularMap) === null || _e === void 0 ? void 0 : _e.getGLTexture(this), 4, gl.TEXTURE_2D);
	            this.bindTexture((_f = material.noiseMap) === null || _f === void 0 ? void 0 : _f.getGLTexture(this), 5, gl.TEXTURE_2D);
	            // And now, draw all objects with this material in a single draw call :)
	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	            gl.drawElements(gl.TRIANGLES, group.count, gl.UNSIGNED_INT, group.offset * Uint32Array.BYTES_PER_ELEMENT);
	            this.drawCalls++;
	        }
	    }
	    renderParticles(particleManager, camera) {
	        let { gl } = this;
	        let program = this.particleProgram;
	        program.use();
	        program.bindVertexBufferGroup(particleManager.bufferGroup);
	        // Set up the uniforms we need
	        let uViewMatrix = new Float32Array(camera.matrixWorldInverse.elements);
	        let uProjectionMatrix = new Float32Array(camera.projectionMatrix.elements);
	        let uLogDepthBufFC = 2.0 / (Math.log(camera.far + 1.0) / Math.LN2);
	        gl.uniformMatrix4fv(program.getUniformLocation('viewMatrix'), false, uViewMatrix);
	        gl.uniformMatrix4fv(program.getUniformLocation('projectionMatrix'), false, uProjectionMatrix);
	        gl.uniform1f(program.getUniformLocation('logDepthBufFC'), uLogDepthBufFC);
	        gl.uniform1i(program.getUniformLocation('diffuseMap'), 0);
	        gl.uniform1f(program.getUniformLocation('time'), particleManager.currentRenderTime); // Since the particle is simulated in-shader, the shader needs to know the current simulation time
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, particleManager.indexBuffer);
	        gl.depthMask(false);
	        gl.enable(gl.BLEND);
	        // Now draw all particle groups
	        for (let [options, group] of particleManager.particleGroups) {
	            if (group.particles.length === 0)
	                continue;
	            let diffuseMap = ResourceManager.getTextureFromCache(options.texture);
	            this.bindTexture(diffuseMap.getGLTexture(this), 0, gl.TEXTURE_2D);
	            if (options.blending === BlendingType.Normal)
	                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // No premultiplied alpha
	            else if (options.blending === BlendingType.Additive)
	                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	            else if (options.blending === BlendingType.Subtractve)
	                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	            // Bind uniforms describing the particle simulation
	            gl.uniform1f(program.getUniformLocation('acceleration'), group.uniforms.acceleration);
	            gl.uniform1f(program.getUniformLocation('spinSpeed'), group.uniforms.spinSpeed);
	            gl.uniform1f(program.getUniformLocation('dragCoefficient'), group.uniforms.dragCoefficient);
	            gl.uniform4fv(program.getUniformLocation('times'), group.uniforms.times);
	            gl.uniform4fv(program.getUniformLocation('sizes'), group.uniforms.sizes);
	            gl.uniformMatrix4fv(program.getUniformLocation('colors'), false, group.uniforms.colors);
	            program.bindVertexBuffer(group.vertexBuffer);
	            gl.drawElements(gl.TRIANGLES, 6 * group.particles.length, gl.UNSIGNED_INT, 0);
	            this.drawCalls++;
	        }
	    }
	    /** Binds a texture to a specific texture unit and texture target. If the texture doesn't exist, it unbinds the texture from the unit. */
	    bindTexture(texture, unit, target) {
	        var _a;
	        let { gl } = this;
	        gl.activeTexture(gl.TEXTURE0 + unit);
	        if (((_a = this.currentFramebuffer) === null || _a === void 0 ? void 0 : _a.colorTexture) === texture || !texture)
	            gl.bindTexture(target, null);
	        else
	            gl.bindTexture(target, texture);
	    }
	    /** Wrapper around createVertexArray[OES]. */
	    createVertexArray() {
	        let { gl } = this;
	        let ext = this.extensions.OES_vertex_array_object;
	        return (gl instanceof WebGLRenderingContext) ? ext.createVertexArrayOES() : gl.createVertexArray();
	    }
	    /** Wrapper around bindVertexArray[OES]. */
	    bindVertexArray(vao) {
	        let { gl } = this;
	        let ext = this.extensions.OES_vertex_array_object;
	        if (gl instanceof WebGLRenderingContext)
	            ext.bindVertexArrayOES(vao);
	        else
	            gl.bindVertexArray(vao);
	    }
	    /** Wrapper around deleteVertexArray[OES]. */
	    deleteVertexArray(vao) {
	        let { gl } = this;
	        let ext = this.extensions.OES_vertex_array_object;
	        if (gl instanceof WebGLRenderingContext)
	            ext.deleteVertexArrayOES(vao);
	        else
	            gl.deleteVertexArray(vao);
	    }
	    cleanUp() {
	        for (let [, program] of this.materialShaders)
	            program.cleanUp();
	    }
	}

	const mainCanvas = document.querySelector('#main-canvas');
	let mainRenderer;
	const initMainRenderer = () => {
	    mainRenderer = new Renderer({
	        canvas: mainCanvas,
	        desynchronized: StorageManager.data.settings.canvasDesynchronized
	    });
	    resize(false);
	};
	const MIN_WIDTH = 640;
	const MIN_HEIGHT = 600;
	/** Ratio by which the entire body gets scaled by, while still fitting into the screen. */
	let SCALING_RATIO = 1;
	const computeUiScalingRatio = (width, height) => {
	    return Math.max(1, MIN_WIDTH / width, MIN_HEIGHT / height);
	};
	const resize = async (wait = true) => {
	    var _a, _b;
	    if (wait)
	        await Util.wait(100); // Sometimes you gotta give browser UI elements a little time to update
	    let ratio = computeUiScalingRatio(window.innerWidth, window.innerHeight);
	    document.body.style.width = Math.ceil(window.innerWidth * ratio) + 'px';
	    document.body.style.height = Math.ceil(window.innerHeight * ratio) + 'px';
	    document.body.style.transform = `scale(${1 / ratio})`;
	    SCALING_RATIO = ratio;
	    if (state.level && state.level.offline)
	        return; // Disable the resizing logic below when we're rendering an offline level
	    let pixelRatio = Math.min(window.devicePixelRatio, [0.5, 1.0, 1.5, 2.0, Infinity][(_a = StorageManager.data) === null || _a === void 0 ? void 0 : _a.settings.pixelRatio]);
	    mainCanvas.style.width = '100%';
	    mainCanvas.style.height = '100%';
	    mainRenderer === null || mainRenderer === void 0 ? void 0 : mainRenderer.setSize(window.innerWidth, window.innerHeight);
	    mainRenderer === null || mainRenderer === void 0 ? void 0 : mainRenderer.setPixelRatio(pixelRatio);
	    (_b = state.level) === null || _b === void 0 ? void 0 : _b.onResize(window.innerWidth, window.innerHeight, Math.max(pixelRatio, 1));
	};
	window.addEventListener('resize', resize);
	resize();
	/** Becomes true when the user has closed the fullscreen enforcer. */
	let dislikesFullscreen = false;
	const fullscreenEnforcer = document.querySelector('#fullscreen-enforcer');
	fullscreenEnforcer.addEventListener('click', () => {
	    document.documentElement.requestFullscreen();
	});
	fullscreenEnforcer.querySelector('img').addEventListener('click', (e) => {
	    dislikesFullscreen = true;
	    fullscreenEnforcer.classList.add('hidden');
	    e.stopPropagation();
	});
	const enterFullscreenButton = document.querySelector('#enter-fullscreen');
	enterFullscreenButton.addEventListener('click', () => {
	    document.documentElement.requestFullscreen();
	    dislikesFullscreen = false; // They changed their mind, yay
	});
	let fullscreenButtonVisibility = true;
	const setEnterFullscreenButtonVisibility = (state) => {
	    fullscreenButtonVisibility = state;
	    if (state && Util.isTouchDevice && !Util.isSafari() && !Util.isInFullscreen())
	        enterFullscreenButton.classList.remove('hidden');
	    else
	        enterFullscreenButton.classList.add('hidden');
	};
	// Periodically, check if the mobile user has left fullscreen and if so, remind them to re-enter it.
	let lastImmunityTime = -Infinity;
	setInterval(() => {
	    var _a, _b;
	    if (((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.tagName) === 'INPUT')
	        lastImmunityTime = performance.now();
	    if (Util.isTouchDevice && !Util.isSafari()) {
	        if (Util.isInFullscreen()) {
	            // They're in fullscreen, hide the overlay
	            fullscreenEnforcer.classList.add('hidden');
	        }
	        else if (!dislikesFullscreen && ((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.tagName) !== 'INPUT' && performance.now() - lastImmunityTime > 666) {
	            // They're not in fullscreen, show the overlay
	            fullscreenEnforcer.classList.remove('hidden');
	        }
	    }
	    setEnterFullscreenButtonVisibility(fullscreenButtonVisibility);
	}, 250);
	// Disable image dragging in Firefox
	window.addEventListener('dragstart', (e) => {
	    var _a;
	    if (((_a = e.target.nodeName) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === 'IMG') {
	        e.preventDefault();
	    }
	});

	const currentMousePosition = {
	    x: 0,
	    y: 0
	};
	window.addEventListener('mousemove', (e) => {
	    var _a;
	    currentMousePosition.x = e.clientX * SCALING_RATIO;
	    currentMousePosition.y = e.clientY * SCALING_RATIO;
	    (_a = state.level) === null || _a === void 0 ? void 0 : _a.onMouseMove(e);
	});
	window.addEventListener('touchstart', (e) => {
	    let touch = e.changedTouches[0];
	    currentMousePosition.x = touch.clientX * SCALING_RATIO;
	    currentMousePosition.y = touch.clientY * SCALING_RATIO;
	});
	window.addEventListener('touchmove', (e) => {
	    let touch = e.changedTouches[0];
	    currentMousePosition.x = touch.clientX * SCALING_RATIO;
	    currentMousePosition.y = touch.clientY * SCALING_RATIO;
	});
	window.addEventListener('mousedown', (e) => {
	    if (!StorageManager.data)
	        return;
	    // Request pointer lock if we're currently in-game
	    if (state.level && !state.level.offline && !state.level.paused && !state.level.finishTime && !Util.isTouchDevice)
	        Util.requestPointerLock();
	    let buttonName = ["LMB", "MMB", "RMB"][e.button];
	    if (buttonName && document.pointerLockElement) {
	        // Check if the mouse button is mapped to something
	        for (let button in StorageManager.data.settings.gameButtonMapping) {
	            let key = button;
	            if (buttonName !== StorageManager.data.settings.gameButtonMapping[key])
	                continue;
	            setPressed(key, buttonName, true);
	            if (state.level) {
	                if (key === 'jump' && isPressedOnce(key))
	                    state.level.jumpQueued = true;
	                if (key === 'use' && isPressedOnce(key))
	                    state.level.useQueued = true;
	                if (key === 'blast' && isPressedOnce(key))
	                    state.level.blastQueued = true;
	            }
	        }
	    }
	});
	window.addEventListener('mouseup', (e) => {
	    if (!StorageManager.data)
	        return;
	    let buttonName = ["LMB", "MMB", "RMB"][e.button];
	    if (buttonName) {
	        for (let button in StorageManager.data.settings.gameButtonMapping) {
	            let key = button;
	            if (buttonName !== StorageManager.data.settings.gameButtonMapping[key])
	                continue;
	            setPressed(key, buttonName, false);
	        }
	    }
	});
	window.addEventListener('keydown', (e) => {
	    if (!StorageManager.data)
	        return;
	    // Check if the key button is mapped to something
	    for (let button in StorageManager.data.settings.gameButtonMapping) {
	        let key = button;
	        if (e.code !== StorageManager.data.settings.gameButtonMapping[key])
	            continue;
	        setPressed(key, e.code, true);
	        if (state.level) {
	            if (key === 'jump' && isPressedOnce(key))
	                state.level.jumpQueued = true;
	            if (key === 'use' && isPressedOnce(key))
	                state.level.useQueued = true;
	        }
	    }
	});
	window.addEventListener('keyup', (e) => {
	    if (!StorageManager.data)
	        return;
	    for (let button in StorageManager.data.settings.gameButtonMapping) {
	        let key = button;
	        if (e.code !== StorageManager.data.settings.gameButtonMapping[key])
	            continue;
	        setPressed(key, e.code, false);
	    }
	});
	window.addEventListener('contextmenu', (e) => e.preventDefault()); // Disable right click context menu for good
	window.addEventListener('beforeunload', (e) => {
	    // Ask the user if they're sure about closing the tab if they're currently in game
	    if (state.level) {
	        e.preventDefault();
	        e.returnValue = '';
	    }
	});
	document.addEventListener('pointerlockchange', () => {
	    var _a;
	    // When pointer lock is left, we pause.
	    if (!document.pointerLockElement)
	        (_a = state.level) === null || _a === void 0 ? void 0 : _a.pause();
	});
	/** For each game button, a list of the keys/buttons corresponding to it that are currently pressed. */
	const gameButtons = {
	    up: [],
	    down: [],
	    left: [],
	    right: [],
	    jump: [],
	    use: [],
	    cameraUp: [],
	    cameraDown: [],
	    cameraLeft: [],
	    cameraRight: [],
	    freeLook: [],
	    restart: [],
	    pause: [],
	    blast: []
	};
	/** For each game button, a flag indicating whether it has been pressed since the flag was reset. Used to prevent things like entering and immediately leaving the pause menu. */
	const pressedSinceFlag = {
	    up: false,
	    down: false,
	    left: false,
	    right: false,
	    jump: false,
	    use: false,
	    cameraUp: false,
	    cameraDown: false,
	    cameraLeft: false,
	    cameraRight: false,
	    freeLook: false,
	    restart: false,
	    pause: false,
	    blast: false
	};
	/** Set a button's state based on a presser. */
	const setPressed = (buttonName, presser, state) => {
	    let incl = gameButtons[buttonName].includes(presser);
	    if (!state && incl) {
	        gameButtons[buttonName] = gameButtons[buttonName].filter(x => x !== presser);
	    }
	    else if (state && !incl) {
	        gameButtons[buttonName].push(presser);
	        pressedSinceFlag[buttonName] = true;
	    }
	};
	/** Determine if a button is pressed. */
	const isPressed = (buttonName) => {
	    return (gameButtons[buttonName].length > 0);
	};
	/** Determine if a button is pressed by a gamepad. */
	const isPressedByGamepad = (buttonName) => {
	    return gameButtons[buttonName].find(x => x.startsWith('gamepadButton')) !== undefined;
	};
	/** Determine if a button is only pressed by one presser. */
	const isPressedOnce = (buttonName) => {
	    return (gameButtons[buttonName].length === 1);
	};
	/** Return whether a presser has pressed the button since the flag was reset. */
	const getPressedFlag = (buttonName) => {
	    return pressedSinceFlag[buttonName];
	};
	/** Reset the pressed flag for a button. */
	const resetPressedFlag = (buttonName) => {
	    pressedSinceFlag[buttonName] = false;
	};
	const releaseAllButtons = () => {
	    for (let key in gameButtons) {
	        if (key !== 'pause')
	            gameButtons[key] = [];
	    }
	};
	/** The current position (-1 to 1) of the marble and camera axes. */
	const gamepadAxes = {
	    marbleX: 0.0,
	    marbleY: 0.0,
	    cameraX: 0.0,
	    cameraY: 0.0
	};
	/** TODO: Make this configurable */
	const gamepadAxisMappings = ['marbleX', 'marbleY', 'cameraX', 'cameraY'];
	const gamepadButtonMappings = ['jump', 'use', 'blast', '', '', 'blast', 'jump', 'use', 'restart', 'pause', '', '', 'up', 'down', 'left', 'right', '', ''];
	/** The most recent controller a button was pressed on, used to select the controller to poll */
	let mostRecentGamepad = 0;
	/** Referring to the button state of the controller. */
	const previousButtonState = [false, false, false, false, false, false, false, false, false, false, false, false, false, false];
	/** Update the input from the gamepad, if it is connected. */
	const updateGamepadInput = () => {
	    var _a, _b;
	    let gamepads = 'getGamepads' in navigator ? [...navigator.getGamepads()].filter(x => x) : [];
	    if (gamepads.length === 0) {
	        // No gamepad active
	        for (let key in gamepadAxes)
	            gamepadAxes[key] = 0.0;
	        return;
	    }
	    // Update the most recent gamepad
	    for (let i = 0; i < gamepads.length; i++) {
	        for (let j = 0; j < gamepads[i].buttons.length; j++) {
	            if (gamepads[i].buttons[j].value > 0.5) {
	                mostRecentGamepad = i;
	                break;
	            }
	        }
	    }
	    for (let i = 0; i < gamepads[mostRecentGamepad].buttons.length && i < 18; i++) {
	        let state = (gamepads[mostRecentGamepad].buttons[i].value > 0.5);
	        let presser = 'gamepadButton' + i;
	        let buttonName = gamepadButtonMappings[i];
	        if (buttonName !== '')
	            setPressed(buttonName, presser, state);
	    }
	    for (let i = 0; i < gamepads[mostRecentGamepad].axes.length && i < 4; i++) {
	        let axisName = gamepadAxisMappings[i];
	        if (axisName !== '') {
	            gamepadAxes[axisName] = gamepads[mostRecentGamepad].axes[i];
	            // Dead zone
	            if (Math.abs(gamepadAxes[axisName]) < 0.1)
	                gamepadAxes[axisName] = 0;
	        }
	    }
	    // Check for input on the level select screen
	    if (((_a = state.menu) === null || _a === void 0 ? void 0 : _a.levelSelect) && !state.menu.levelSelect.div.classList.contains('hidden'))
	        state.menu.levelSelect.handleControllerInput(gamepads[mostRecentGamepad]);
	    if ((_b = state.level) === null || _b === void 0 ? void 0 : _b.paused)
	        state.menu.pauseScreen.handleGamepadInput(gamepads[mostRecentGamepad]);
	    for (let i = 0; i < gamepads[mostRecentGamepad].buttons.length && i < 18; i++) {
	        previousButtonState[i] = (gamepads[mostRecentGamepad].buttons[i].value > 0.5);
	    }
	};
	window.setInterval(updateGamepadInput, 4);
	/* TOUCH STUFF: */
	const touchInputContainer = document.querySelector('#touch-input-container');
	const movementAreaElement = document.querySelector('#movement-area');
	const cameraAreaElement = document.querySelector('#camera-area');
	const movementJoystick = document.querySelector('#movement-joystick');
	const movementJoystickHandle = document.querySelector('#movement-joystick-handle');
	const actionButtonContainer = document.querySelector('#action-buttons');
	const jumpButton = document.querySelector('#jump-button');
	const useButton = document.querySelector('#use-button');
	const blastButton = document.querySelector('#blast-button');
	const pauseButton = document.querySelector('#pause-button');
	const restartButton = document.querySelector('#restart-button');
	const freeLookButton = document.querySelector('#free-look-button');
	const JOYSTICK_HANDLE_SIZE_FACTOR = 2 / 5;
	let joystickPosition = null;
	let normalizedJoystickHandlePosition = null;
	let movementAreaTouchIdentifier = null;
	let cameraAreaTouchIdentifier = null;
	let lastCameraTouch = null;
	let joystickAsCameraTouches = [];
	let useEnabled = false;
	let blastEnabled = false;
	const setUseEnabled = (value) => {
	    useEnabled = value;
	};
	const getUseEnabledOpacityAndEnabled = () => {
	    return {
	        opacity: useEnabled ? '0.5' : '0.2',
	        enabled: useEnabled
	    };
	};
	const getBlastEnabledOpacityAndEnabled = () => {
	    return {
	        opacity:  '0.2',
	        enabled: blastEnabled
	    };
	};
	let touchendFuncs = [];
	const setupTouchButton = (element, button, onStart, onEnd, getOpacityAndEnabled) => {
	    let touchId = null;
	    element.addEventListener('touchstart', (e) => {
	        var _a;
	        let touch = e.changedTouches[0];
	        touchId = touch.identifier;
	        let oaenabled = (_a = getOpacityAndEnabled === null || getOpacityAndEnabled === void 0 ? void 0 : getOpacityAndEnabled().enabled) !== null && _a !== void 0 ? _a : true;
	        if (oaenabled)
	            element.style.opacity = '0.9';
	        else
	            element.style.opacity = '0.4';
	        setPressed(button, 'touch', true);
	        onStart === null || onStart === void 0 ? void 0 : onStart(touch);
	    });
	    touchendFuncs.push((touch, force) => {
	        var _a;
	        if (force || touch.identifier === touchId) {
	            touchId = null;
	            element.style.opacity = (_a = getOpacityAndEnabled === null || getOpacityAndEnabled === void 0 ? void 0 : getOpacityAndEnabled().opacity) !== null && _a !== void 0 ? _a : '';
	            setPressed(button, 'touch', false);
	            onEnd === null || onEnd === void 0 ? void 0 : onEnd(touch);
	        }
	    });
	};
	const startCameraMovement = (touch) => {
	    cameraAreaTouchIdentifier = touch.identifier;
	    lastCameraTouch = touch;
	};
	const startCameraMovementFromButton = (touch) => {
	    startCameraMovement(touch);
	    joystickAsCameraTouches.push(touch);
	};
	const endCameraMovementFromButton = (touch) => {
	    joystickAsCameraTouches.splice(joystickAsCameraTouches.indexOf(touch), 1);
	};
	setupTouchButton(jumpButton, 'jump', startCameraMovementFromButton, endCameraMovementFromButton);
	setupTouchButton(useButton, 'use', startCameraMovementFromButton, endCameraMovementFromButton, getUseEnabledOpacityAndEnabled);
	setupTouchButton(blastButton, 'blast', startCameraMovementFromButton, endCameraMovementFromButton, getBlastEnabledOpacityAndEnabled);
	setupTouchButton(pauseButton, 'pause');
	setupTouchButton(restartButton, 'restart');
	setupTouchButton(freeLookButton, 'freeLook');
	const hideTouchControls = () => {
	    touchInputContainer.style.display = 'none';
	};
	const maybeShowTouchControls = () => {
	    touchInputContainer.style.display = Util.isTouchDevice ? 'block' : 'none';
	};
	const setTouchControlMode = (mode) => {
	    if (mode === 'normal') {
	        [movementJoystick, jumpButton, useButton, blastButton, freeLookButton].forEach(x => x.style.display = '');
	    }
	    else if (mode === 'replay') {
	        // Hide everything but pause and replay buttons
	        [movementJoystick, jumpButton, useButton, blastButton, freeLookButton].forEach(x => x.style.display = 'none');
	    }
	};
	movementAreaElement.addEventListener('touchstart', (e) => {
	    let touch = e.changedTouches[0];
	    movementAreaTouchIdentifier = touch.identifier;
	    let x, y;
	    let joystickSize = StorageManager.data.settings.joystickSize;
	    if (StorageManager.data.settings.joystickPosition === 0) {
	        // Fixed
	        x = StorageManager.data.settings.joystickLeftOffset + joystickSize / 2;
	        y = window.innerHeight * (1 - StorageManager.data.settings.joystickVerticalPosition) * SCALING_RATIO;
	    }
	    else {
	        // Dynamic
	        x = Util.clamp(touch.clientX * SCALING_RATIO, joystickSize / 2, (window.innerWidth * SCALING_RATIO - joystickSize) / 2);
	        y = Util.clamp(touch.clientY * SCALING_RATIO, joystickSize / 2, window.innerHeight * SCALING_RATIO - joystickSize / 2);
	    }
	    movementJoystick.style.visibility = 'visible';
	    movementJoystick.style.left = x - joystickSize / 2 + 'px';
	    movementJoystick.style.top = y - joystickSize / 2 + 'px';
	    joystickPosition = { x: x, y: y };
	    normalizedJoystickHandlePosition = { x: 0, y: 0 };
	    updateJoystickHandlePosition(touch);
	});
	movementAreaElement.addEventListener('touchmove', (e) => {
	    let touch = [...e.changedTouches].find(x => x.identifier === movementAreaTouchIdentifier);
	    if (!touch)
	        return;
	    if (touch.identifier === movementAreaTouchIdentifier) {
	        updateJoystickHandlePosition(touch);
	    }
	});
	const updateJoystickHandlePosition = (touch) => {
	    let joystickSize = StorageManager.data.settings.joystickSize;
	    let joystickHandleSize = JOYSTICK_HANDLE_SIZE_FACTOR * StorageManager.data.settings.joystickSize;
	    let innerRadius = (joystickSize - joystickHandleSize) / 2;
	    normalizedJoystickHandlePosition.x = Util.clamp((touch.clientX * SCALING_RATIO - joystickPosition.x) / innerRadius, -1, 1);
	    normalizedJoystickHandlePosition.y = Util.clamp((touch.clientY * SCALING_RATIO - joystickPosition.y) / innerRadius, -1, 1);
	    movementJoystickHandle.style.left = (normalizedJoystickHandlePosition.x) * innerRadius + joystickSize / 2 - joystickHandleSize / 2 + 'px';
	    movementJoystickHandle.style.top = (normalizedJoystickHandlePosition.y) * innerRadius + joystickSize / 2 - joystickHandleSize / 2 + 'px';
	};
	window.addEventListener('touchend', (e) => {
	    for (let touch of e.changedTouches) {
	        if (touch.identifier === movementAreaTouchIdentifier) {
	            movementAreaTouchIdentifier = null;
	            movementJoystick.style.visibility = 'hidden';
	            normalizedJoystickHandlePosition = null;
	        }
	        if (touch.identifier === cameraAreaTouchIdentifier) {
	            cameraAreaTouchIdentifier = null;
	        }
	        for (let func of touchendFuncs)
	            func(touch, false);
	    }
	    if (e.touches.length === 0) {
	        // Just to be sure, end all the things. To prevent stuff from being stuck on screen forever
	        movementAreaTouchIdentifier = null;
	        movementJoystick.style.visibility = 'hidden';
	        normalizedJoystickHandlePosition = null;
	        cameraAreaTouchIdentifier = null;
	        for (let func of touchendFuncs)
	            func(null, true);
	    }
	});
	cameraAreaElement.addEventListener('touchstart', (e) => {
	    let touch = e.changedTouches[0];
	    startCameraMovement(touch);
	});
	// Put this on touchInputContainer instead of cameraAreaElement so it also works when you start the drag on a button
	touchInputContainer.addEventListener('touchmove', (e) => {
	    let touch = [...e.changedTouches].find(x => x.identifier === cameraAreaTouchIdentifier);
	    let level = state.level;
	    if (!touch)
	        return;
	    if (touch.identifier === cameraAreaTouchIdentifier) {
	        let movementX = (touch.clientX - lastCameraTouch.clientX) * SCALING_RATIO;
	        let movementY = (touch.clientY - lastCameraTouch.clientY) * SCALING_RATIO;
	        let factor = Util.lerp(1 / 1500, 1 / 50, StorageManager.data.settings.mouseSensitivity) * ((joystickAsCameraTouches.length !== 0) ? StorageManager.data.settings.actionButtonAsJoystickMultiplier : 1);
	        let yFactor = (StorageManager.data.settings.invertMouse & 0b10) ? -1 : 1;
	        let freeLook = StorageManager.data.settings.alwaysFreeLook || isPressed('freeLook');
	        level.yaw -= movementX * factor;
	        if (freeLook)
	            level.pitch += movementY * factor * yFactor;
	        lastCameraTouch = touch;
	    }
	});

	const OFFLINE_CONTEXT_SAMPLE_RATE = 48000;
	const audioBufferCachePromises = new Map();
	const audioBufferCache = new Map();
	/** A class used as an utility for sound playback. */
	class AudioManager {
	    constructor() {
	        /** Stores a list of all currently playing audio sources. */
	        this.audioSources = [];
	        /** Can be set to schedule audio events to happen at a specific time. Useful for offline audio rendering. */
	        this.currentTimeOverride = null;
	    }
	    get currentTime() {
	        var _a;
	        return (_a = this.currentTimeOverride) !== null && _a !== void 0 ? _a : this.context.currentTime;
	    }
	    init(offline) {
	        if (window.AudioContext) {
	            if (!offline) {
	                this.context = new AudioContext();
	            }
	            else {
	                this.context = new OfflineAudioContext(2, offline.duration * OFFLINE_CONTEXT_SAMPLE_RATE, OFFLINE_CONTEXT_SAMPLE_RATE);
	            }
	        }
	        else {
	            // Safari
	            if (!offline) {
	                this.context = new window.webkitAudioContext;
	            }
	            else {
	                this.context = new window.webkitOfflineAudioContext(2, offline.duration * OFFLINE_CONTEXT_SAMPLE_RATE, OFFLINE_CONTEXT_SAMPLE_RATE);
	            }
	        }
	        this.masterGain = this.context.createGain();
	        this.masterGain.gain.value = 1;
	        this.masterGain.connect(this.context.destination);
	        this.soundGain = this.context.createGain();
	        this.soundGain.gain.value = 0; // These values will be overwritten by the options anyway
	        this.soundGain.connect(this.masterGain);
	        this.musicGain = this.context.createGain();
	        this.musicGain.gain.value = 0;
	        this.musicGain.connect(this.masterGain);
	        if (!offline)
	            this.updateVolumes();
	        window.onfocus = () => {
	            if (Util.isTouchDevice)
	                this.masterGain.gain.value = 1;
	        };
	        window.onblur = () => {
	            // If we're on a touch device, mute the site when we blur it
	            if (Util.isTouchDevice)
	                this.masterGain.gain.value = 0;
	        };
	    }
	    setAssetPath(path) {
	        this.assetPath = path;
	    }
	    toFullPath(path) {
	        let fullPath = this.assetPath + path;
	        return fullPath;
	    }
	    /** Loads an audio buffer from a path. Returns the cached version whenever possible. */
	    async loadBuffer(path) {
	        var _a;
	        let fullPath = this.toFullPath(path);
	        // If there's a current level, see if there's a sound file for this path contained in it
	        let mission = (_a = state.level) === null || _a === void 0 ? void 0 : _a.mission;
	        let zipFile;
	        if (mission && mission.zipDirectory && mission.zipDirectory.files['data/sound/' + path]) {
	            zipFile = mission.zipDirectory.files['data/sound/' + path];
	        }
	        else {
	            // Return the cached version if there is one
	            await audioBufferCachePromises.get(fullPath);
	            if (audioBufferCache.has(fullPath))
	                return audioBufferCache.get(fullPath);
	        }
	        let promise = (async () => {
	            let blob = zipFile ? await zipFile.async('blob') : await ResourceManager.loadResource(fullPath);
	            let arrayBuffer = await ResourceManager.readBlobAsArrayBuffer(blob);
	            let audioBuffer;
	            if (path.endsWith('.ogg') && Util.isSafari()) {
	                // Safari can't deal with .ogg. Apparently Firefox can't deal with some of them either??
	                audioBuffer = await oggDecoder.decodeOggData(arrayBuffer);
	            }
	            else if (window.AudioContext) {
	                try {
	                    // Since decoding an ArrayBuffer detaches it, but we might need it later in this function, we need
	                    // to clone the buffer here.
	                    let clonedBuffer = arrayBuffer.slice(0, arrayBuffer.byteLength);
	                    audioBuffer = await this.context.decodeAudioData(clonedBuffer);
	                }
	                catch (e) {
	                    // Firefox should hit this case sometimes
	                    audioBuffer = await oggDecoder.decodeOggData(arrayBuffer);
	                }
	            }
	            else {
	                audioBuffer = await new Promise((res, rej) => {
	                    this.context.decodeAudioData(arrayBuffer, buff => res(buff), err => rej(err));
	                });
	            }
	            audioBufferCache.set(fullPath, audioBuffer);
	            audioBufferCachePromises.delete(fullPath);
	            return audioBuffer;
	        })();
	        if (!zipFile)
	            audioBufferCachePromises.set(fullPath, promise);
	        return promise;
	    }
	    loadBuffers(paths) {
	        return Promise.all(paths.map((path) => this.loadBuffer(path)));
	    }
	    /**
	     * Creates an audio source.
	     * @param path The path of the audio resource. If it's an array, a random one will be selected.
	     * @param destination The destination node of the audio.
	     * @param position Optional: The position of the audio source in 3D space.
	     * @param preferStreaming If true, uses a normal <audio> element instead of play the audio as quickly as possible.
	     */
	    createAudioSource(path, destination = this.soundGain, position, preferStreaming = false) {
	        let chosenPath = (typeof path === "string") ? path : Util.randomFromArray(path);
	        let fullPath = this.toFullPath(chosenPath);
	        let audioSource;
	        if (chosenPath.endsWith('.ogg') && Util.isSafari())
	            preferStreaming = false; // We can't
	        if (preferStreaming) {
	            if (audioBufferCache.has(fullPath)) {
	                // We already got the buffer, prefer that over streaming
	                preferStreaming = false;
	            }
	            else {
	                let audioElement = new Audio();
	                audioElement.src = fullPath;
	                audioElement.preload = 'auto';
	                audioSource = new AudioSource(this, audioElement, destination, position);
	            }
	        }
	        if (!preferStreaming) {
	            let bufferPromise = this.loadBuffer(chosenPath);
	            audioSource = new AudioSource(this, bufferPromise, destination, position);
	        }
	        if (position) {
	            // Mute the sound by default to avoid any weird audible artifacts.
	            audioSource.gain.gain.setValueAtTime(0, this.currentTime);
	        }
	        this.audioSources.push(audioSource);
	        return audioSource;
	    }
	    /** Utility method for creating an audio source and playing it immediately. */
	    play(path, volume = 1, destination = this.soundGain, position) {
	        let audioSource = this.createAudioSource(path, destination, position);
	        audioSource.gain.gain.setValueAtTime(position ? 0 : volume, this.currentTime);
	        audioSource.play();
	    }
	    /** Updates the pan and volume of positional audio sources based on the listener's location. */
	    updatePositionalAudio(time, listenerPos, listenerYaw) {
	        let quat = state.level.getOrientationQuat(time);
	        quat.conjugate();
	        for (let source of this.audioSources) {
	            if (!source.position)
	                continue;
	            // Get the relative position of the audio source from the listener's POV
	            let relativePosition = source.position.clone().sub(listenerPos);
	            relativePosition.applyQuaternion(quat);
	            relativePosition.applyAxisAngle(new Vector3(0, 0, 1), -listenerYaw);
	            relativePosition.normalize();
	            relativePosition.z = 0;
	            let distance = source.position.distanceTo(listenerPos);
	            let panRemoval = Util.clamp(distance / 1, 0, 1); // If the listener is very close to the center, start moving the audio source to the center.
	            source.setPannerValue(-relativePosition.y * 0.7 * panRemoval);
	            source.gain.gain.setValueAtTime(Util.clamp(1 - distance / 30, 0, 1) * source.gainFactor, this.currentTime);
	        }
	    }
	    updateVolumes() {
	        // Quadratic because it feels better
	        this.musicGain.gain.linearRampToValueAtTime(StorageManager.data.settings.musicVolume ** 2, this.currentTime + 0.01);
	        this.soundGain.gain.linearRampToValueAtTime(StorageManager.data.settings.soundVolume ** 2, this.currentTime + 0.01);
	    }
	    stopAllAudio() {
	        for (let source of this.audioSources.slice()) {
	            source.stop();
	        }
	    }
	    /** Normalizes the volume of positional audio sources based on the sounds around them to prevent the user's permanent loss of hearing. */
	    normalizePositionalAudioVolume() {
	        let sources = this.audioSources.filter(x => x.position); // Get all positional sources
	        for (let i = 0; i < sources.length; i++) {
	            let source = sources[i];
	            let receivedVolume = 0;
	            // Accumulate the total received volume at this point
	            for (let j = 0; j < sources.length; j++) {
	                if (i === j)
	                    continue;
	                let otherSource = sources[j];
	                let distance = source.position.distanceTo(otherSource.position);
	                let preceivedVolume = Util.clamp(1 - distance / 30, 0, 1);
	                receivedVolume += preceivedVolume;
	            }
	            // Normalize it
	            source.gainFactor = Math.min(1 / receivedVolume, 1);
	        }
	    }
	}
	/** A small wrapper around audio nodes that are used to play a sound. */
	class AudioSource {
	    constructor(manager, source, destination, position) {
	        this.stopped = false;
	        this.playing = false;
	        this.gainFactor = 1;
	        this.loop = false;
	        this.playbackRate = 1;
	        this.manager = manager;
	        if (source instanceof Promise) {
	            this.promise = source;
	        }
	        else {
	            this.audioElement = source;
	            this.promise = new Promise(resolve => {
	                source.addEventListener('canplaythrough', () => resolve());
	            });
	        }
	        this.destination = destination;
	        this.position = position;
	        this.gain = this.manager.context.createGain();
	        if (this.manager.context.createStereoPanner)
	            this.panner = this.manager.context.createStereoPanner();
	        else
	            this.panner = this.manager.context.createPanner();
	        this.gain.connect(this.panner);
	        this.panner.connect(this.destination);
	        if (source instanceof Promise) {
	            this.node = this.manager.context.createBufferSource();
	        }
	        else {
	            this.node = this.manager.context.createMediaElementSource(source);
	        }
	        this.node.connect(this.gain);
	    }
	    setPannerValue(value) {
	        if (this.manager.context.createStereoPanner) {
	            this.panner.pan.setValueAtTime(value, this.manager.currentTime);
	        }
	        else {
	            // https://stackoverflow.com/a/59545726
	            this.panner.panningModel = 'equalpower';
	            this.panner.setPosition(value, 0, 1 - Math.abs(value)); // Can't schedule it
	        }
	    }
	    setLoop(loop) {
	        if (this.audioElement)
	            this.audioElement.loop = loop;
	        else
	            this.node.loop = loop;
	        this.loop = loop;
	    }
	    setPlaybackRate(playbackRate) {
	        if (this.audioElement)
	            this.audioElement.playbackRate = playbackRate;
	        else
	            this.node.playbackRate.setValueAtTime(playbackRate, this.manager.currentTime);
	        this.playbackRate = playbackRate;
	    }
	    async play() {
	        var _a, _b;
	        if (this.playing)
	            return;
	        if (this.stopped) {
	            this.stopped = false;
	            if (this.node instanceof AudioBufferSourceNode) {
	                // Gotta recreate this stuff
	                this.node = this.manager.context.createBufferSource();
	                this.node.connect(this.gain);
	                this.node.loop = this.loop;
	                this.node.playbackRate.setValueAtTime(this.playbackRate, this.manager.currentTime);
	                this.stopped = false;
	                this.manager.audioSources.push(this);
	            }
	        }
	        let maybeBuffer = await this.promise;
	        if (this.stopped)
	            return;
	        if (this.node instanceof AudioBufferSourceNode) {
	            if (this.node.buffer)
	                return; // Async stuff idk, could happen
	            this.node.buffer = maybeBuffer;
	            this.node.start(this.manager.currentTime);
	            this.node.onended = () => {
	                this.stop(); // Call .stop for clean-up purposes
	            };
	        }
	        else {
	            (_a = this.audioElement) === null || _a === void 0 ? void 0 : _a.play();
	            (_b = this.audioElement) === null || _b === void 0 ? void 0 : _b.addEventListener('ended', () => this.stop());
	        }
	        this.playing = true;
	    }
	    stop() {
	        if (this.stopped)
	            return;
	        this.stopped = true;
	        this.playing = false;
	        try {
	            if (this.audioElement) {
	                this.audioElement.pause();
	                // https://stackoverflow.com/questions/40843798/hide-html5-audio-video-notification-in-android-chrome
	                // Okay this doesn't seem to be working actually
	                this.audioElement.currentTime = 0;
	                this.audioElement.load();
	            }
	            else {
	                this.node.stop(this.manager.currentTime);
	            }
	        }
	        catch (e) { }
	        Util.removeFromArray(this.manager.audioSources, this);
	    }
	}
	const oggDecoder = OggdecModule();
	const mainAudioManager = new AudioManager();

	/** Stores and handles operations on the online leaderboard. */
	class Leaderboard {
	    static async init() {
	        // The first time we do this, the main purpose is to update the value of `latestTimestamp`.
	        await this.syncLeaderboard();
	    }
	    /** Loads the scores of all missions in the vicinity of the current mission. */
	    static loadLocal() {
	        let missionPaths = new Set();
	        let currentLevelArray = state.menu.levelSelect.sortedMissionArray;
	        for (let i = -5; i <= 5; i++) {
	            let index = state.menu.levelSelect.getCycleMissionIndex(i);
	            let mission = currentLevelArray[index];
	            if (mission)
	                missionPaths.add(mission.path);
	        }
	        for (let mission of state.menu.levelSelect.getNextShuffledMissions())
	            missionPaths.add(mission.path);
	        this.loadForMissions([...missionPaths]);
	    }
	    /** Loads all scores for the given missions. */
	    static async loadForMissions(missionPaths) {
	        missionPaths = missionPaths.filter(x => !this.loading.has(x) && !this.scores.has(x)); // Filter out loaded or loading missions
	        if (missionPaths.length === 0)
	            return;
	        missionPaths.forEach(x => this.loading.add(x));
	        this.registerLeaderboardChange(missionPaths);
	        // Get all the scores
	        let blob = await ResourceManager.retryFetch('./api/scores', {
	            method: 'POST',
	            body: JSON.stringify({
	                missions: missionPaths
	            })
	        });
	        let data = await ResourceManager.readBlobAsJson(blob);
	        for (let missionPath in data) {
	            // Update the scores
	            this.scores.set(missionPath, data[missionPath]);
	            this.loading.delete(missionPath);
	        }
	        this.registerLeaderboardChange(missionPaths);
	    }
	    static isLoading(missionPath) {
	        return this.loading.has(missionPath);
	    }
	    /** Submits a new score to the leaderboard. */
	    static async submitScore(missionPath, score) {
	        StorageManager.data.bestTimeSubmissionQueue.push({
	            missionPath,
	            score
	        });
	        StorageManager.store();
	        this.syncLeaderboard();
	    }
	    /** Synchronizes the leaderboard: Uploads new personal best times and gets all new/changed online scores and updates the leaderboard accordingly. */
	    static async syncLeaderboard() {
	        var _a;
	        let queue = StorageManager.data.bestTimeSubmissionQueue;
	        let payloadScores = [];
	        let payloadReplays = {};
	        // Go over all scores in the submission queue
	        for (let { missionPath, score } of queue) {
	            let payloadScore = {
	                id: score[2],
	                missionPath,
	                score: [score[0], score[1]]
	            };
	            payloadScores.push(payloadScore);
	            let onlineScore = (_a = this.scores.get(missionPath)) === null || _a === void 0 ? void 0 : _a[0];
	            if (!onlineScore || score[1] < onlineScore[1]) {
	                // This score is better than the top online score, therefore assume this is a new world record and prepare the replay for upload.
	                let replayData = await StorageManager.databaseGet('replays', score[2]);
	                if (!replayData)
	                    continue;
	                // Convert to base64 because we can't ship binary data over JSON
	                let base64 = await Util.arrayBufferToBase64(replayData);
	                payloadReplays[payloadScore.id] = base64;
	            }
	        }
	        let payload = {
	            randomId: StorageManager.data.randomId,
	            scores: Object.keys(queue).length ? await Util.arrayBufferToBase64(await executeOnWorker('compress', JSON.stringify(payloadScores))) : null,
	            latestTimestamp: this.latestTimestamp,
	            replays: payloadReplays,
	            version: StorageManager.data.lastSeenVersion
	        };
	        let blob = await ResourceManager.retryFetch('./api/submit', {
	            method: 'POST',
	            body: JSON.stringify(payload)
	        });
	        let data = await ResourceManager.readBlobAsJson(blob);
	        this.latestTimestamp = data.latestTimestamp;
	        // Update the leaderboard with the new scores
	        for (let missionPath in data.scores) {
	            if (!this.scores.has(missionPath))
	                continue;
	            let storedScores = this.scores.get(missionPath);
	            let newScores = data.scores[missionPath];
	            storedScores = storedScores.filter(x => !newScores.some(y => y[0] === x[0])); // Remove old scores with same usernames
	            storedScores.push(...newScores);
	            storedScores.sort((a, b) => a[1] - b[1]); // Sort by time
	            this.scores.set(missionPath, storedScores);
	        }
	        this.registerLeaderboardChange(Object.keys(data.scores));
	        // Since a response arrived, empty the queue
	        StorageManager.data.bestTimeSubmissionQueue = [];
	        StorageManager.store();
	    }
	    /** Communicates that the given missions' leaderboards have changed somehow. Causes a visual update to the leaderboard if the missions are currently being viewed. */
	    static registerLeaderboardChange(changedMissions) {
	        var _a;
	        let localScoreRemoved = false;
	        let submissionQueue = StorageManager.data.bestTimeSubmissionQueue;
	        for (let missionPath of changedMissions) {
	            let onlineScores = this.scores.get(missionPath);
	            let localScore = (_a = StorageManager.data.bestTimes[missionPath]) === null || _a === void 0 ? void 0 : _a[0];
	            if (!onlineScores || !localScore || submissionQueue.some(x => x.missionPath === missionPath)) {
	                continue;
	            }
	            let onlineScore = onlineScores[0];
	            // Splice all submitted local scores that are faster than the current WR for that level. We do this because the existence of those scores makes no sense (they can happen when the leaderboard is purged server-side)
	            while (localScore && (!onlineScore || localScore[1] < Number(onlineScore[1]))) {
	                StorageManager.data.bestTimes[missionPath].splice(0, 1);
	                localScore = StorageManager.data.bestTimes[missionPath][0];
	                localScoreRemoved = true;
	            }
	            if (StorageManager.data.bestTimes[missionPath].length === 0)
	                delete StorageManager.data.bestTimes[missionPath];
	        }
	        if (localScoreRemoved)
	            StorageManager.storeBestTimes();
	        // Maybe redraw the leaderboard
	        let currentMission = state.menu.levelSelect.currentMission;
	        if (changedMissions.includes(currentMission === null || currentMission === void 0 ? void 0 : currentMission.path))
	            state.menu.levelSelect.displayBestTimes();
	    }
	}
	/** The scores for each mission. */
	Leaderboard.scores = new Map();
	/** Whether a mission's scores are currently loading. */
	Leaderboard.loading = new Set();
	/** The latest score timestamp received from the user. Will be used to get any scores newer than this. */
	Leaderboard.latestTimestamp = null;

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Class representing a 4D vector. */
	class Vector4 {
	    constructor(x = 0, y = 0, z = 0, w = 1) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    get width() {
	        return this.z;
	    }
	    set width(value) {
	        this.z = value;
	    }
	    get height() {
	        return this.w;
	    }
	    set height(value) {
	        this.w = value;
	    }
	    /** Sets the x, y, z and w components of this vector. */
	    set(x, y, z, w) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	        return this;
	    }
	    /** Sets the x, y, z and w values of this vector both equal to scalar. */
	    setScalar(scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        this.z = scalar;
	        this.w = scalar;
	        return this;
	    }
	    /** Replaces this vector's x value with x. */
	    setX(x) {
	        this.x = x;
	        return this;
	    }
	    /** Replaces this vector's y value with y. */
	    setY(y) {
	        this.y = y;
	        return this;
	    }
	    /** Replaces this vector's z value with z. */
	    setZ(z) {
	        this.z = z;
	        return this;
	    }
	    /** Replaces this vector's w value with w. */
	    setW(w) {
	        this.w = w;
	        return this;
	    }
	    /** If index equals 0 set x to value. If index equals 1 set y to value. If index equals 2 set z to value. If index equals 3 set w to value. */
	    setComponent(index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            case 2:
	                this.z = value;
	                break;
	            case 3:
	                this.w = value;
	                break;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	        return this;
	    }
	    /** If index equals 0 returns the x value. If index equals 1 returns the y value. If index equals 2 returns the z value. If index equals 3 returns the w value. */
	    getComponent(index) {
	        switch (index) {
	            case 0:
	                return this.x;
	            case 1:
	                return this.y;
	            case 2:
	                return this.z;
	            case 3:
	                return this.w;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	    }
	    /** Returns a new Vector4 with the same x, y, z and w values as this one. */
	    clone() {
	        return new Vector4(this.x, this.y, this.z, this.w);
	    }
	    /** Copies the values of the passed Vector4's x, y, z and w properties to this Vector4. */
	    copy(v) {
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        this.w = v.w !== undefined ? v.w : 1;
	        return this;
	    }
	    /** Adds v to this vector. */
	    add(v) {
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;
	        this.w += v.w;
	        return this;
	    }
	    /** Adds the scalar value s to this vector's x, y, z and w values. */
	    addScalar(s) {
	        this.x += s;
	        this.y += s;
	        this.z += s;
	        this.w += s;
	        return this;
	    }
	    /** Sets this vector to a + b. */
	    addVectors(a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        this.w = a.w + b.w;
	        return this;
	    }
	    /** Adds the multiple of v and s to this vector. */
	    addScaledVector(v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        this.z += v.z * s;
	        this.w += v.w * s;
	        return this;
	    }
	    /** Subtracts v from this vector. */
	    sub(v) {
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        this.w -= v.w;
	        return this;
	    }
	    /** Subtracts s from this vector's x, y, z and w compnents. */
	    subScalar(s) {
	        this.x -= s;
	        this.y -= s;
	        this.z -= s;
	        this.w -= s;
	        return this;
	    }
	    /** Sets this vector to a - b. */
	    subVectors(a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        this.w = a.w - b.w;
	        return this;
	    }
	    /** Multiplies this vector by v. */
	    multiply(v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z;
	        this.w *= v.w;
	        return this;
	    }
	    /** Multiplies this vector by scalar s. */
	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        this.z *= scalar;
	        this.w *= scalar;
	        return this;
	    }
	    /** Multiplies this vector by 4 x 4 m. */
	    applyMatrix4(m) {
	        const x = this.x, y = this.y, z = this.z, w = this.w;
	        const e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
	        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
	        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
	        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
	        return this;
	    }
	    /** Divides this vector by scalar s. */
	    divideScalar(scalar) {
	        return this.multiplyScalar(1 / scalar);
	    }
	    /** Sets the x, y and z components of this vector to the quaternion's axis and w to the angle. */
	    setAxisAngleFromQuaternion(q) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	        // q is assumed to be normalized
	        this.w = 2 * Math.acos(q.w);
	        const s = Math.sqrt(1 - q.w * q.w);
	        if (s < 0.0001) {
	            this.x = 1;
	            this.y = 0;
	            this.z = 0;
	        }
	        else {
	            this.x = q.x / s;
	            this.y = q.y / s;
	            this.z = q.z / s;
	        }
	        return this;
	    }
	    /** Sets the x, y and z to the axis of rotation and w to the angle. */
	    setAxisAngleFromRotationMatrix(m) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        let angle, x, y, z; // variables for result
	        const epsilon = 0.01, // margin to allow for rounding errors
	        epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
	        te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
	        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
	            // singularity found
	            // first check for identity matrix which must have +1 for all terms
	            // in leading diagonal and zero in other terms
	            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
	                // this singularity is identity matrix so angle = 0
	                this.set(1, 0, 0, 0);
	                return this; // zero angle, arbitrary axis
	            }
	            // otherwise this singularity is angle = 180
	            angle = Math.PI;
	            const xx = (m11 + 1) / 2;
	            const yy = (m22 + 1) / 2;
	            const zz = (m33 + 1) / 2;
	            const xy = (m12 + m21) / 4;
	            const xz = (m13 + m31) / 4;
	            const yz = (m23 + m32) / 4;
	            if (xx > yy && xx > zz) {
	                // m11 is the largest diagonal term
	                if (xx < epsilon) {
	                    x = 0;
	                    y = 0.707106781;
	                    z = 0.707106781;
	                }
	                else {
	                    x = Math.sqrt(xx);
	                    y = xy / x;
	                    z = xz / x;
	                }
	            }
	            else if (yy > zz) {
	                // m22 is the largest diagonal term
	                if (yy < epsilon) {
	                    x = 0.707106781;
	                    y = 0;
	                    z = 0.707106781;
	                }
	                else {
	                    y = Math.sqrt(yy);
	                    x = xy / y;
	                    z = yz / y;
	                }
	            }
	            else {
	                // m33 is the largest diagonal term so base result on this
	                if (zz < epsilon) {
	                    x = 0.707106781;
	                    y = 0.707106781;
	                    z = 0;
	                }
	                else {
	                    z = Math.sqrt(zz);
	                    x = xz / z;
	                    y = yz / z;
	                }
	            }
	            this.set(x, y, z, angle);
	            return this; // return 180 deg rotation
	        }
	        // as we have reached here there are no singularities so we can handle normally
	        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
	        if (Math.abs(s) < 0.001)
	            s = 1;
	        // prevent divide by zero, should not happen if matrix is orthogonal and should be
	        // caught by singularity test above, but I've left it in just in case
	        this.x = (m32 - m23) / s;
	        this.y = (m13 - m31) / s;
	        this.z = (m21 - m12) / s;
	        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
	        return this;
	    }
	    /** If this vector's x, y, z or w value is greater than v's x, y, z or w value, replace that value with the corresponding min value. */
	    min(v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);
	        this.w = Math.min(this.w, v.w);
	        return this;
	    }
	    /** If this vector's x, y, z or w value is less than v's x, y, z or w value, replace that value with the corresponding max value. */
	    max(v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);
	        this.w = Math.max(this.w, v.w);
	        return this;
	    }
	    /** If this vector's x, y, z or w value is greater than the max vector's x, y, z or w value, it is replaced by the corresponding value. If this vector's x, y, z or w value is less than the min vector's x, y, z or w value, it is replaced by the corresponding value. */
	    clamp(min, max) {
	        // assumes min < max, componentwise
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        this.z = Math.max(min.z, Math.min(max.z, this.z));
	        this.w = Math.max(min.w, Math.min(max.w, this.w));
	        return this;
	    }
	    /** If this vector's x, y, z or w values are greater than the max value, they are replaced by the max value. If this vector's x, y, z or w values are less than the min value, they are replaced by the min value. */
	    clampScalar(minVal, maxVal) {
	        this.x = Math.max(minVal, Math.min(maxVal, this.x));
	        this.y = Math.max(minVal, Math.min(maxVal, this.y));
	        this.z = Math.max(minVal, Math.min(maxVal, this.z));
	        this.w = Math.max(minVal, Math.min(maxVal, this.w));
	        return this;
	    }
	    /** If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value. */
	    clampLength(min, max) {
	        const length = this.length();
	        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	    }
	    /** The components of this vector are rounded down to the nearest integer value. */
	    floor() {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        this.z = Math.floor(this.z);
	        this.w = Math.floor(this.w);
	        return this;
	    }
	    /** The components of this vector are rounded up to the nearest integer value. */
	    ceil() {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        this.z = Math.ceil(this.z);
	        this.w = Math.ceil(this.w);
	        return this;
	    }
	    /** The components of this vector are rounded to the nearest integer value. */
	    round() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        this.z = Math.round(this.z);
	        this.w = Math.round(this.w);
	        return this;
	    }
	    /** The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value. */
	    roundToZero() {
	        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
	        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
	        return this;
	    }
	    /** Inverts this vector - i.e. sets x = -x, y = -y, z = -z and w = -w. */
	    negate() {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        this.w = -this.w;
	        return this;
	    }
	    /** Calculates the dot product of this vector and v. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    }
	    /** Computes the square of the Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w). */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	    }
	    /** Computes the Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w). */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    }
	    /** Computes the Manhattan length of this vector. */
	    manhattanLength() {
	        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	    }
	    /** Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1. */
	    normalize() {
	        return this.divideScalar(this.length() || 1);
	    }
	    /** Sets this vector to a vector with the same direction as this one, but length l. */
	    setLength(length) {
	        return this.normalize().multiplyScalar(length);
	    }
	    /** Linearly interpolates between this vector and v, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v. */
	    lerp(v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        this.z += (v.z - this.z) * alpha;
	        this.w += (v.w - this.w) * alpha;
	        return this;
	    }
	    /** Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2. */
	    lerpVectors(v1, v2, alpha) {
	        this.x = v1.x + (v2.x - v1.x) * alpha;
	        this.y = v1.y + (v2.y - v1.y) * alpha;
	        this.z = v1.z + (v2.z - v1.z) * alpha;
	        this.w = v1.w + (v2.w - v1.w) * alpha;
	        return this;
	    }
	    /** Returns true if the components of this vector and v are strictly equal; false otherwise. */
	    equals(v) {
	        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
	    }
	    /** Sets this vector's x value to be array[offset + 0], y value to be array[offset + 1] z value to be array[offset + 2] and w value to be array[offset + 3]. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        this.w = array[offset + 3];
	        return this;
	    }
	    /** Returns an array [x, y, z, w], or copies x, y, z and w into the provided array. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.w;
	        return array;
	    }
	    /** Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1. */
	    random() {
	        this.x = Math.random();
	        this.y = Math.random();
	        this.z = Math.random();
	        this.w = Math.random();
	        return this;
	    }
	    *[Symbol.iterator]() {
	        yield this.x;
	        yield this.y;
	        yield this.z;
	        yield this.w;
	    }
	}

	var MissionElementType;
	(function (MissionElementType) {
	    MissionElementType[MissionElementType["SimGroup"] = 0] = "SimGroup";
	    MissionElementType[MissionElementType["ScriptObject"] = 1] = "ScriptObject";
	    MissionElementType[MissionElementType["MissionArea"] = 2] = "MissionArea";
	    MissionElementType[MissionElementType["Sky"] = 3] = "Sky";
	    MissionElementType[MissionElementType["Sun"] = 4] = "Sun";
	    MissionElementType[MissionElementType["InteriorInstance"] = 5] = "InteriorInstance";
	    MissionElementType[MissionElementType["StaticShape"] = 6] = "StaticShape";
	    MissionElementType[MissionElementType["Item"] = 7] = "Item";
	    MissionElementType[MissionElementType["Path"] = 8] = "Path";
	    MissionElementType[MissionElementType["Marker"] = 9] = "Marker";
	    MissionElementType[MissionElementType["PathedInterior"] = 10] = "PathedInterior";
	    MissionElementType[MissionElementType["Trigger"] = 11] = "Trigger";
	    MissionElementType[MissionElementType["AudioProfile"] = 12] = "AudioProfile";
	    MissionElementType[MissionElementType["MessageVector"] = 13] = "MessageVector";
	    MissionElementType[MissionElementType["TSStatic"] = 14] = "TSStatic";
	    MissionElementType[MissionElementType["ParticleEmitterNode"] = 15] = "ParticleEmitterNode";
	})(MissionElementType || (MissionElementType = {}));
	const elementHeadRegEx = /new\s+(\w+)\((.*?)\)\s*{/g;
	const blockCommentRegEx = /\/\*(.|\n)*?\*\//g;
	const lineCommentRegEx = /\/\/.*/g;
	const assignmentRegEx = /(\$(?:\w|\d)+)\s*=\s*(.+?);/g;
	const marbleAttributesRegEx = /setMarbleAttributes\("(\w+)",\s*(.+?)\);/g;
	const activatePackageRegEx = /activatePackage\((.+?)\);/g;
	const materialPropertyRegEx = /new MaterialProperty *\( *(.+?) *\)\s*{\s*((?:\w+ *= *(\d|\.)+;\s*)*)}/gi;
	const addMaterialMappingRegEx = /addMaterialMapping *\( *"(.+?)" *, *(.+?) *\)/gi;
	const keyValuePairRegEx = /([^\s]+?)\s*=\s*"(.*?)"\s*;/g;
	/** A parser for .mis files, which hold mission information. */
	class MisParser {
	    constructor(text) {
	        this.index = 0;
	        this.currentElementId = 0;
	        this.text = text;
	    }
	    parse() {
	        // This is dirty, but prepend all material definitions to the top of the file so we can parse them incase any custom material of this level uses them.
	        this.text = materialPropertyDefinition + '\n\n' + this.text;
	        let objectWriteBeginIndex = this.text.indexOf("//--- OBJECT WRITE BEGIN ---");
	        let objectWriteEndIndex = this.text.lastIndexOf("//--- OBJECT WRITE END ---");
	        let outsideText = this.text.slice(0, objectWriteBeginIndex) + this.text.slice(objectWriteEndIndex);
	        // Find all specified variables
	        this.variables = { "$usermods": '""' }; // Just make $usermods point to nothing
	        assignmentRegEx.lastIndex = 0;
	        let match = null;
	        while ((match = assignmentRegEx.exec(outsideText)) !== null) {
	            // Only use the first variable found. This is because the variable is likely to be modified later on with conditional statements and that's too complex to parse right now.
	            if (!this.variables[match[1]])
	                this.variables[match[1]] = match[2];
	        }
	        // Parse any custom marble attributes specified at the top of the file
	        let marbleAttributes = {};
	        match = null;
	        marbleAttributesRegEx.lastIndex = 0;
	        while ((match = marbleAttributesRegEx.exec(outsideText)) !== null) {
	            marbleAttributes[match[1]] = this.resolveExpression(match[2]);
	        }
	        // Parse any packages that the mission file activates
	        let activatedPackages = [];
	        match = null;
	        activatePackageRegEx.lastIndex = 0;
	        while ((match = activatePackageRegEx.exec(outsideText)) !== null) {
	            activatedPackages.push(this.resolveExpression(match[1]));
	        }
	        let materialProperties = {};
	        match = null;
	        materialPropertyRegEx.lastIndex = 0;
	        while ((match = materialPropertyRegEx.exec(outsideText)) !== null) {
	            let pairs = match[2].split(';').filter(x => x.trim()).map(x => x.split('=').map(x => x.trim()));
	            materialProperties[match[1]] = {};
	            for (let pair of pairs) {
	                materialProperties[match[1]][pair[0]] = Number(pair[1]);
	            }
	        }
	        let materialMappings = {};
	        match = null;
	        addMaterialMappingRegEx.lastIndex = 0;
	        while ((match = addMaterialMappingRegEx.exec(outsideText)) !== null) {
	            materialMappings[match[1]] = match[2];
	        }
	        // Trim away the outside text
	        if (objectWriteBeginIndex !== -1 && objectWriteEndIndex !== -1) {
	            this.text = this.text.slice(objectWriteBeginIndex, objectWriteEndIndex);
	        }
	        // Remove all block and line comments to make parsing easier
	        let currentIndex = 0;
	        while (true) {
	            blockCommentRegEx.lastIndex = currentIndex;
	            lineCommentRegEx.lastIndex = currentIndex;
	            let blockMatch = blockCommentRegEx.exec(this.text);
	            let lineMatch = lineCommentRegEx.exec(this.text);
	            // The detected "comment" might be inside a string literal, in which case we ignore it 'cause it ain't no comment.
	            if (blockMatch && Util.indexIsInStringLiteral(this.text, blockMatch.index))
	                blockMatch = null;
	            if (lineMatch && Util.indexIsInStringLiteral(this.text, lineMatch.index))
	                lineMatch = null;
	            if (!blockMatch && !lineMatch)
	                break;
	            else if (!lineMatch || (blockMatch && lineMatch && blockMatch.index < lineMatch.index)) {
	                this.text = this.text.slice(0, blockMatch.index) + this.text.slice(blockMatch.index + blockMatch[0].length);
	                currentIndex = blockMatch.index;
	            }
	            else {
	                this.text = this.text.slice(0, lineMatch.index) + this.text.slice(lineMatch.index + lineMatch[0].length);
	                currentIndex = lineMatch.index;
	            }
	        }
	        let indexOfMissionGroup = this.text.indexOf('new SimGroup(MissionGroup)');
	        if (indexOfMissionGroup !== -1)
	            this.index = indexOfMissionGroup;
	        // Read out all elements (we're expecting exactly one!)
	        let elements = [];
	        while (this.hasNextElement()) {
	            let element = this.readElement();
	            if (!element)
	                continue;
	            elements.push(element);
	        }
	        if (elements.length !== 1) {
	            // We expect there to be only one outer element; the MissionGroup SimGroup.
	            console.log(elements);
	            throw new Error("Mission file doesn't have exactly 1 outer element!");
	        }
	        return {
	            root: elements[0],
	            marbleAttributes,
	            activatedPackages,
	            materialProperties,
	            materialMappings
	        };
	    }
	    readElement() {
	        // Get information about the head
	        elementHeadRegEx.lastIndex = this.index;
	        let head = elementHeadRegEx.exec(this.text);
	        this.index = head.index + head[0].length;
	        let type = head[1];
	        let name = head[2];
	        this.index = head.index + head[0].length;
	        let element = null;
	        switch (type) {
	            case "SimGroup":
	                element = this.readSimGroup(name);
	                break;
	            case "ScriptObject":
	                element = this.readScriptObject(name);
	                break;
	            case "MissionArea":
	                element = this.readMissionArea(name);
	                break;
	            case "Sky":
	                element = this.readSky(name);
	                break;
	            case "Sun":
	                element = this.readSun(name);
	                break;
	            case "InteriorInstance":
	                element = this.readInteriorInstance(name);
	                break;
	            case "StaticShape":
	                element = this.readStaticShape(name);
	                break;
	            case "Item":
	                element = this.readItem(name);
	                break;
	            case "Path":
	                element = this.readPath(name);
	                break;
	            case "Marker":
	                element = this.readMarker(name);
	                break;
	            case "PathedInterior":
	                element = this.readPathedInterior(name);
	                break;
	            case "Trigger":
	                element = this.readTrigger(name);
	                break;
	            case "AudioProfile":
	                element = this.readAudioProfile(name);
	                break;
	            case "MessageVector":
	                element = this.readMessageVector(name);
	                break;
	            case "TSStatic":
	                element = this.readTSStatic(name);
	                break;
	            case "ParticleEmitterNode":
	                element = this.readParticleEmitterNode(name);
	                break;
	            default: {
	                console.warn("Unknown element type! " + type);
	                // Still advance the index
	                let endingBraceIndex = Util.indexOfIgnoreStringLiterals(this.text, '};', this.index);
	                if (endingBraceIndex === -1)
	                    endingBraceIndex = this.text.length;
	                this.index = endingBraceIndex + 2;
	            }
	        }
	        if (element)
	            element._id = this.currentElementId++;
	        return element;
	    }
	    /** Checks if there's another element coming in the current scope. */
	    hasNextElement() {
	        elementHeadRegEx.lastIndex = this.index;
	        let head = elementHeadRegEx.exec(this.text);
	        if (!head)
	            return false;
	        if (Util.indexOfIgnoreStringLiterals(this.text.slice(this.index, head.index), '}') !== -1)
	            return false;
	        return true;
	    }
	    readSimGroup(name) {
	        let elements = [];
	        let keyValuePairs = {}; // Possible optional key-value pairs also included with the sim group
	        // Read in all elements
	        while (true) {
	            elementHeadRegEx.lastIndex = this.index;
	            keyValuePairRegEx.lastIndex = this.index;
	            let head = elementHeadRegEx.exec(this.text);
	            let keyValue = keyValuePairRegEx.exec(this.text);
	            let index = Math.min(head === null || head === void 0 ? void 0 : head.index, keyValue === null || keyValue === void 0 ? void 0 : keyValue.index);
	            if (!isFinite(index))
	                break;
	            if (Util.indexOfIgnoreStringLiterals(this.text.slice(this.index, index), '}') !== -1)
	                break;
	            if (index === (head === null || head === void 0 ? void 0 : head.index)) {
	                let element = this.readElement();
	                if (!element)
	                    continue;
	                elements.push(element);
	            }
	            else {
	                keyValuePairs[keyValue[1]] = this.resolveExpression(keyValue[2]);
	                this.index += keyValue[0].length;
	            }
	        }
	        let endingBraceIndex = Util.indexOfIgnoreStringLiterals(this.text, '};', this.index);
	        if (endingBraceIndex === -1)
	            endingBraceIndex = this.text.length;
	        this.index = endingBraceIndex + 2;
	        if (!elements)
	            return null;
	        return Object.assign(keyValuePairs, {
	            _type: MissionElementType.SimGroup,
	            _name: name,
	            elements: elements
	        });
	    }
	    /** Reads the key/value pairs of an element. */
	    readValues() {
	        var _a;
	        // Values are either strings or string arrays.
	        let obj = {};
	        let endingBraceIndex = Util.indexOfIgnoreStringLiterals(this.text, '};', this.index);
	        if (endingBraceIndex === -1)
	            endingBraceIndex = this.text.length;
	        let section = this.text.slice(this.index, endingBraceIndex).trim();
	        let statements = Util.splitIgnoreStringLiterals(section, ';').map(x => x.trim()); // Get a list of all statements
	        for (let statement of statements) {
	            if (!statement)
	                continue;
	            let splitIndex = statement.indexOf('=');
	            if (splitIndex === -1)
	                continue;
	            let parts = [statement.slice(0, splitIndex), statement.slice(splitIndex + 1)].map((part) => part.trim());
	            if (parts.length !== 2)
	                continue;
	            let key = parts[0];
	            key = key.toLowerCase(); // TorqueScript is case-insensitive here
	            if (key.endsWith(']')) {
	                // The key is specifying array data, so handle that case.
	                let openingIndex = key.indexOf('[');
	                let arrayName = key.slice(0, openingIndex);
	                let array = ((_a = obj[arrayName]) !== null && _a !== void 0 ? _a : (obj[arrayName] = [])); // Create a new array or use the existing one
	                let index = Number(key.slice(openingIndex + 1, -1));
	                array[index] = this.resolveExpression(parts[1]);
	            }
	            else {
	                obj[key] = this.resolveExpression(parts[1]);
	            }
	        }
	        this.index = endingBraceIndex + 2;
	        return obj;
	    }
	    /** Resolves a TorqueScript rvalue expression. Currently only supports the concatenation @ operator. */
	    resolveExpression(expr) {
	        let parts = Util.splitIgnoreStringLiterals(expr, '@').map(x => {
	            x = x.trim();
	            if (x.startsWith('$') && this.variables[x] !== undefined) {
	                // Replace the variable with its value
	                x = this.resolveExpression(this.variables[x]);
	            }
	            else if (x.startsWith('"') && x.endsWith('"')) {
	                x = Util.unescape(x.slice(1, -1)); // It's a string literal, so remove " "
	            }
	            return x;
	        });
	        return parts.join('');
	    }
	    readScriptObject(name) {
	        return Object.assign({
	            _type: MissionElementType.ScriptObject,
	            _name: name
	        }, this.readValues());
	    }
	    readMissionArea(name) {
	        return Object.assign({
	            _type: MissionElementType.MissionArea,
	            _name: name
	        }, this.readValues());
	    }
	    readSky(name) {
	        return Object.assign({
	            _type: MissionElementType.Sky,
	            _name: name
	        }, this.readValues());
	    }
	    readSun(name) {
	        return Object.assign({
	            _type: MissionElementType.Sun,
	            _name: name
	        }, this.readValues());
	    }
	    readInteriorInstance(name) {
	        return Object.assign({
	            _type: MissionElementType.InteriorInstance,
	            _name: name
	        }, this.readValues());
	    }
	    readStaticShape(name) {
	        return Object.assign({
	            _type: MissionElementType.StaticShape,
	            _name: name
	        }, this.readValues());
	    }
	    readItem(name) {
	        return Object.assign({
	            _type: MissionElementType.Item,
	            _name: name
	        }, this.readValues());
	    }
	    readPath(name) {
	        let simGroup = this.readSimGroup(name);
	        simGroup['markers'] = simGroup.elements.sort((a, b) => MisParser.parseNumber(a.seqnum) - MisParser.parseNumber(b.seqnum)); // Make sure they're sorted sequentially
	        delete simGroup['elements'];
	        simGroup._type = MissionElementType.Path;
	        return simGroup;
	    }
	    readMarker(name) {
	        return Object.assign({
	            _type: MissionElementType.Marker,
	            _name: name
	        }, this.readValues());
	    }
	    readPathedInterior(name) {
	        return Object.assign({
	            _type: MissionElementType.PathedInterior,
	            _name: name
	        }, this.readValues());
	    }
	    readTrigger(name) {
	        return Object.assign({
	            _type: MissionElementType.Trigger,
	            _name: name
	        }, this.readValues());
	    }
	    readAudioProfile(name) {
	        return Object.assign({
	            _type: MissionElementType.AudioProfile,
	            _name: name
	        }, this.readValues());
	    }
	    readMessageVector(name) {
	        return Object.assign({
	            _type: MissionElementType.MessageVector,
	            _name: name
	        }, this.readValues());
	    }
	    readTSStatic(name) {
	        return Object.assign({
	            _type: MissionElementType.TSStatic,
	            _name: name
	        }, this.readValues());
	    }
	    readParticleEmitterNode(name) {
	        return Object.assign({
	            _type: MissionElementType.ParticleEmitterNode,
	            _name: name
	        }, this.readValues());
	    }
	    /** Loads and parses a .mis file. Returns a cached version if already loaded. */
	    static async loadFile(path) {
	        if (this.cachedFiles.get(path))
	            return this.cachedFiles.get(path);
	        let blob = await ResourceManager.loadResource(path);
	        let text = await ResourceManager.readBlobAsText(blob);
	        let parser = new MisParser(text);
	        let result = parser.parse();
	        this.cachedFiles.set(path, result);
	        return result;
	    }
	    /** Parses a 3-component vector from a string of three numbers. */
	    static parseVector3(string) {
	        if (!string)
	            return new Vector3();
	        let parts = string.split(' ').map((part) => Number(part));
	        if (parts.length < 3)
	            return new Vector3();
	        if (parts.find(x => !isFinite(x)) !== undefined)
	            return new Vector3();
	        return new Vector3(parts[0], parts[1], parts[2]);
	    }
	    /** Parses a 4-component vector from a string of four numbers. */
	    static parseVector4(string) {
	        if (!string)
	            return new Vector4();
	        let parts = string.split(' ').map((part) => Number(part));
	        if (parts.length < 4)
	            return new Vector4();
	        if (parts.find(x => !isFinite(x)) !== undefined)
	            return new Vector4();
	        return new Vector4(parts[0], parts[1], parts[2], parts[3]);
	    }
	    /** Returns a quaternion based on a rotation specified from 4 numbers. */
	    static parseRotation(string) {
	        if (!string)
	            return new Quaternion();
	        let parts = string.split(' ').map((part) => Number(part));
	        if (parts.length < 4)
	            return new Quaternion();
	        if (parts.find(x => !isFinite(x)) !== undefined)
	            return new Quaternion();
	        let quaternion = new Quaternion();
	        // The first 3 values represent the axis to rotate on, the last represents the negative angle in degrees.
	        quaternion.setFromAxisAngle(new Vector3(parts[0], parts[1], parts[2]), -Util.degToRad(parts[3]));
	        return quaternion;
	    }
	    /** Parses a numeric value. */
	    static parseNumber(string) {
	        if (!string || typeof string !== 'string')
	            return 0;
	        // Strange thing here, apparently you can supply lists of numbers. In this case tho, we just take the first value.
	        let val = Number(string.split(',')[0]);
	        if (isNaN(val))
	            return 0;
	        return val;
	    }
	    /** Parses a list of space-separated numbers. */
	    static parseNumberList(string) {
	        let parts = string.split(' ');
	        let result = [];
	        for (let part of parts) {
	            let number = Number(part);
	            if (!isNaN(number)) {
	                // The number parsed without issues; simply add it to the array.
	                result.push(number);
	            }
	            else {
	                // Since we got NaN, we assume the number did not parse correctly and we have a case where the space between multiple numbers are missing. So "0.0000000 1.0000000" turning into "0.00000001.0000000".
	                const assumedDecimalPlaces = 7; // Reasonable assumption
	                // Scan the part to try to find all numbers contained in it
	                while (part.length > 0) {
	                    let dotIndex = part.indexOf('.');
	                    if (dotIndex === -1)
	                        break;
	                    let section = part.slice(0, Math.min(dotIndex + assumedDecimalPlaces + 1, part.length));
	                    result.push(Number(section));
	                    part = part.slice(dotIndex + assumedDecimalPlaces + 1);
	                }
	            }
	        }
	        return result;
	    }
	    /** Parses a boolean value. */
	    static parseBoolean(string) {
	        if (!string)
	            return false;
	        if (string === "0")
	            return false;
	        return true;
	    }
	}
	MisParser.cachedFiles = new Map();
	/** The source string, taken from PQ, where all default frictions and materials are defined. */
	const materialPropertyDefinition = `
new MaterialProperty(GrassFrictionMaterial) {
	friction = 1.50;
	restitution = 0.35;
};

new MaterialProperty(TarmacFrictionMaterial) {
	friction = 0.35;
	restitution = 0.7;
};

new MaterialProperty(RugFrictionMaterial) {
	friction = 6;
	restitution = 0.5;
};

new MaterialProperty(IceFrictionMaterial) {
	friction = 0.03;
	restitution = 0.95;
};

new MaterialProperty(CarpetFrictionMaterial) {
	friction = 6;
	restitution = 0.5;
};

new MaterialProperty(SandFrictionMaterial) {
	friction = 4;
	restitution = 0.1;
};

new MaterialProperty(WaterFrictionMaterial) {
	friction = 6;
	restitution = 0;
};

new MaterialProperty(BouncyFrictionMaterial) {
	friction = 0.2;
	restitution = 0;
	force = 15;
};

new MaterialProperty(RandomForceMaterial) {
	friction = -1;
	restitution = 1;
};

// MBU/O values...

new MaterialProperty(HighFrictionMultiplayerMaterial) {
	friction = 6;
	restitution = 0.3;
};

// added to stop the game from popping an error in the console log that it cannot find the
// material property even though the game runs fine without that minor piece of code
// so these lines of code are an extra to shut the game up and you can remove them if you wish

new MaterialProperty(DefaultMaterial) {
	friction = 1;
	restitution = 1;
};

// these values are for a balanced game play with Mini Marble Golf (the levels)
// they might be a tad different to their MBP equivalent and are more realistic

new MaterialProperty(MMGGrassMaterial) {
	friction = 0.9;
	restitution = 0.5;
};

new MaterialProperty(MMGSandMaterial) {
	friction = 6;
	restitution = 0.1;
};

new MaterialProperty(MMGWaterMaterial) {
	friction = 6;
	restitution = 0;
};

new MaterialProperty(MMGIceMaterial) {
	friction = 0.03;
	restitution = 0.95;
};

new MaterialProperty(MMGIceShadowMaterial) {
	friction = 0.2;
	restitution = 0.95;
};

// These are some old values

new MaterialProperty(BumperMaterial) {
	friction = 0.5;
	restitution = 0;
	force = 15;
};

new MaterialProperty(ButtonMaterial) {
	friction = 1;
	restitution = 1;
};

// MBG Values for their frictions. MBP ones still rock, though.

// Space

new MaterialProperty(NoFrictionMaterial) {
	friction = 0.01;
	restitution = 0.5;
};

// Mud

new MaterialProperty(LowFrictionMaterial) {
	friction = 0.20;
	restitution = 0.5;
};

// Grass

new MaterialProperty(HighFrictionMaterial) {
	friction = 1.50;
	restitution = 0.5;
};

// Yellow ramps with arrows from Three Fold Maze and Escher's Race

new MaterialProperty(VeryHighFrictionMaterial) {
	friction = 2;
	restitution = 1;
};

// Normal floor

new MaterialProperty(RubberFloorMaterial) {
	friction = 1;
	restitution = 1;
};

// Oil Slick

new MaterialProperty(IceMaterial) {
	friction = 0.05;
	restitution = 0.5;
};

new MaterialProperty(XmasSnowMaterial) {
	friction = 3;
	restitution = 0.2;
};

// PlatinumQuest frictions

new MaterialProperty(PQSpaceMaterial) {
	friction = 0.01;
	restitution = 0.35;
};

// It's elite
new MaterialProperty(PQIceMaterial) {
	friction = 0.07331;
	restitution = 0.75;
};

new MaterialProperty(PQMudMaterial) {
	friction = 0.30;
	restitution = 0.5;
};

// Match 3FM/ER friction
new MaterialProperty(PQGrassMaterial) {
	friction = 2;
	restitution = 0.5;
};

// Tad higher on rest. now
new MaterialProperty(PQSandMaterial) {
	friction = 4;
	restitution = 0.15;
};

new MaterialProperty(PQBouncyMaterial) {
	friction = 0.2;
	restitution = 0;
	force = 15;
};

new MaterialProperty(IceShardMaterial) {
	friction = 0;
	restitution = 0;
	force = 0;
};

new MaterialProperty(MORepulsionMaterial) {
	friction = 1;
	restitution = 1;
	force = 10;
};

new MaterialProperty(MOWeakRepulsionMaterial) {
	friction = 1;
	restitution = 1;
	force = 5;
};

// Spooky!!

new MaterialProperty(SpookyWaterMaterial) {
	friction = 6;
	restitution = 0;
};

new MaterialProperty(SpookyDirtMaterial) {
	friction = 6;
	restitution = 0.3;
};

new MaterialProperty(SpookyGrassMaterial) {
	friction = 2;
	restitution = 0.75;
};`;

	/** An abstract class with common methods used to parse binary files. */
	class BinaryFileParser {
	    constructor(arrayBuffer) {
	        /** The current index of reading. */
	        this.index = 0;
	        this.buffer = arrayBuffer;
	        this.view = new DataView(arrayBuffer);
	    }
	    readU8() {
	        return this.view.getUint8(this.index++);
	    }
	    readU16() {
	        return this.view.getUint16((this.index = this.index + 2) - 2, true);
	    }
	    readU32() {
	        return this.view.getUint32((this.index = this.index + 4) - 4, true);
	    }
	    readS8() {
	        return this.view.getInt8(this.index++);
	    }
	    readS16() {
	        return this.view.getInt16((this.index = this.index + 2) - 2, true);
	    }
	    readS32() {
	        return this.view.getInt32((this.index = this.index + 4) - 4, true);
	    }
	    readF32() {
	        return this.view.getFloat32((this.index = this.index + 4) - 4, true);
	    }
	    readBool() {
	        return this.readU8() === 1;
	    }
	    readPoint3F() {
	        let x = this.readF32(), y = this.readF32(), z = this.readF32();
	        return { x, y, z };
	    }
	    readBox3F() {
	        let min = this.readPoint3F(), max = this.readPoint3F();
	        return { min, max };
	    }
	    readSphereF() {
	        let center = this.readPoint3F(), radius = this.readF32();
	        return { center, radius };
	    }
	    readPlaneF() {
	        let x = this.readF32(), y = this.readF32(), z = this.readF32(), d = this.readF32();
	        return { x, y, z, d };
	    }
	    readString() {
	        // The length of the string is given in the first byte
	        let length = this.readU8();
	        let result = "";
	        for (let i = 0; i < length; i++) {
	            result += String.fromCharCode(this.readU8());
	        }
	        while (result.charCodeAt(result.length - 1) === 0)
	            result = result.slice(0, -1); // Trim off NUL bytes from the end (thank you, HiGuy)
	        return result;
	    }
	}

	/* eslint-disable @typescript-eslint/no-unused-vars */
	var MeshType;
	(function (MeshType) {
	    MeshType[MeshType["Standard"] = 0] = "Standard";
	    MeshType[MeshType["Skin"] = 1] = "Skin";
	    MeshType[MeshType["Decal"] = 2] = "Decal";
	    MeshType[MeshType["Sorted"] = 3] = "Sorted";
	    MeshType[MeshType["Null"] = 4] = "Null";
	})(MeshType || (MeshType = {}));
	/** A helper construct used by the DTS parser. It keeps 3 indices into one data buffer for reading a stream of 32-bit, 16-bit and 8-bit values, respectively. */
	class Alloc {
	    constructor(buf, start32, start16, start8) {
	        this.lastGuardValue = 0;
	        this.buf = buf;
	        this.view = new DataView(this.buf);
	        this.index32 = start32;
	        this.index16 = start32 + start16 * 4;
	        this.index8 = start32 + start8 * 4;
	    }
	    readU32() {
	        let val = this.view.getUint32(this.index32, true);
	        this.index32 += 4;
	        return val;
	    }
	    readS32() {
	        let val = this.view.getInt32(this.index32, true);
	        this.index32 += 4;
	        return val;
	    }
	    readF32() {
	        let val = this.view.getFloat32(this.index32, true);
	        this.index32 += 4;
	        return val;
	    }
	    readPoint2F() {
	        return {
	            x: this.readF32(),
	            y: this.readF32()
	        };
	    }
	    readPoint3F() {
	        return {
	            x: this.readF32(),
	            y: this.readF32(),
	            z: this.readF32()
	        };
	    }
	    readBoxF() {
	        return {
	            min: this.readPoint3F(),
	            max: this.readPoint3F()
	        };
	    }
	    readU16() {
	        let val = this.view.getUint16(this.index16, true);
	        this.index16 += 2;
	        return val;
	    }
	    readS16() {
	        let val = this.view.getInt16(this.index16, true);
	        this.index16 += 2;
	        return val;
	    }
	    readU8() {
	        let val = this.view.getUint8(this.index8);
	        this.index8 += 1;
	        return val;
	    }
	    readQuat16() {
	        return {
	            x: this.readS16(),
	            y: this.readS16(),
	            z: this.readS16(),
	            w: this.readS16()
	        };
	    }
	    readMatrixF() {
	        return new Array(16).fill(null).map(() => this.readF32());
	    }
	    /** Guards are sequentially increasing numbers in all three buffers which are used to check data integrity. */
	    guard() {
	        let guard32 = this.readU32();
	        let guard16 = this.readU16();
	        let guard8 = this.readU8();
	        if (!(guard32 === guard16 && guard16 === guard8 && guard8 === this.lastGuardValue)) {
	            throw new Error("Guard fail! Expected " + this.lastGuardValue + " but got " + guard32 + " for 32, " + guard16 + " for 16 and " + guard8 + " for 8.");
	        }
	        this.lastGuardValue++;
	    }
	}
	/** Class used for old DTS versions. Is used to build a new buffer in the modern DTS format which is then parsed as usual. */
	class OldAlloc {
	    constructor(sourceView, sourceIndex) {
	        this.sourceIndex = 0;
	        this.index32 = 0;
	        this.index16 = 0;
	        this.index8 = 0;
	        this.nextGuard = 0;
	        this.sourceView = sourceView;
	        this.sourceIndex = sourceIndex;
	        this.buffer32 = new DataView(new ArrayBuffer(25000));
	        this.buffer16 = new DataView(new ArrayBuffer(25000));
	        this.buffer8 = new DataView(new ArrayBuffer(25000));
	    }
	    skip(bytes) {
	        this.sourceIndex += bytes;
	    }
	    allocate32(words) {
	        this.index32 += words * 4;
	    }
	    allocate16(words) {
	        this.index16 += words * 2;
	    }
	    allocate8(words) {
	        this.index8 += words * 1;
	    }
	    copyInto32(count) {
	        for (let i = 0; i < count; i++) {
	            this.buffer32.setUint32(this.index32 + i * 4, this.sourceView.getUint32(this.sourceIndex + i * 4, true), true);
	        }
	        this.sourceIndex += count * 4;
	        this.index32 += count * 4;
	    }
	    copyInto16(count) {
	        for (let i = 0; i < count; i++) {
	            this.buffer16.setUint16(this.index16 + i * 2, this.sourceView.getUint16(this.sourceIndex + i * 2, true), true);
	        }
	        this.sourceIndex += count * 2;
	        this.index16 += count * 2;
	    }
	    copyInto8(count) {
	        for (let i = 0; i < count * 1; i++) {
	            this.buffer8.setUint8(this.index8 + i * 1, this.sourceView.getUint8(this.sourceIndex + i * 1));
	        }
	        this.sourceIndex += count * 1;
	        this.index8 += count * 1;
	    }
	    readS32(storeIndex = this.index32 / 4) {
	        let val = this.sourceView.getInt32(this.sourceIndex, true);
	        this.sourceIndex += 4;
	        if (storeIndex !== null) {
	            this.buffer32.setInt32(storeIndex * 4, val, true);
	            if (storeIndex * 4 === this.index32)
	                this.index32 += 4;
	        }
	        return val;
	    }
	    writeS32(value) {
	        this.buffer32.setInt32(this.index32, value, true);
	        this.index32 += 4;
	    }
	    writeU8(value) {
	        this.buffer8.setUint8(this.index8, value);
	        this.index8 += 1;
	    }
	    guard() {
	        this.buffer32.setUint32(this.index32, this.nextGuard, true);
	        this.buffer16.setUint16(this.index16, this.nextGuard, true);
	        this.buffer8.setUint8(this.index8, this.nextGuard);
	        this.nextGuard++;
	        this.index32 += 4;
	        this.index16 += 2;
	        this.index8 += 1;
	    }
	    createBuffer() {
	        // Make sure they're all a multiple of 4 long
	        this.index16 = Math.ceil(this.index16 / 4) * 4;
	        this.index8 = Math.ceil(this.index8 / 4) * 4;
	        let buffer = new ArrayBuffer(this.index32 + this.index16 + this.index8);
	        let typed = new Uint8Array(buffer);
	        let index = 0;
	        // Concat everything
	        for (let i = 0; i < this.index32; i++) {
	            typed[index++] = this.buffer32.getUint8(i);
	        }
	        for (let i = 0; i < this.index16; i++) {
	            typed[index++] = this.buffer16.getUint8(i);
	        }
	        for (let i = 0; i < this.index8; i++) {
	            typed[index++] = this.buffer8.getUint8(i);
	        }
	        return { buffer, start16: this.index32 / 4, start8: (this.index32 + this.index16) / 4 };
	    }
	}
	/** A parser for .dts files, used for static shapes and items. Main resources are http://docs.garagegames.com/torque-3d/official/content/documentation/Artist%20Guide/Formats/dts_format.html#:~:text=DTS%20is%20the%20native%20binary,and%20(optionally)%20sequence%20data.&text=The%20DTS%20file%20format%20stores,loading%20on%20non%2DIntel%20platforms. and the Torque 3D source. */
	class DtsParser extends BinaryFileParser {
	    parse(stopAfterMaterials = false) {
	        let version = this.readU16();
	        let exporterVersion = this.readU16();
	        let memBuffer;
	        let start32;
	        let start16;
	        let start8;
	        let sequences;
	        let materialList;
	        if (version < 19) {
	            // We're dealing with an old DTS version; create a new buffer first.
	            let result = this.readOldShape(version);
	            memBuffer = result.bufferInfo.buffer;
	            start32 = 0;
	            start16 = result.bufferInfo.start16;
	            start8 = result.bufferInfo.start8;
	            sequences = result.sequences;
	            materialList = result.materialList;
	        }
	        else {
	            let sizeMemBuffer = this.readU32();
	            memBuffer = this.buffer;
	            start16 = this.readU32();
	            start8 = this.readU32();
	            start32 = this.index;
	            this.index += sizeMemBuffer * 4;
	            let numSequences = this.readS32();
	            sequences = [];
	            for (let i = 0; i < numSequences; i++) {
	                sequences.push(this.parseSequence());
	            }
	            materialList = this.parseMaterialList(version);
	        }
	        let shape = {};
	        if (!stopAfterMaterials) {
	            let alloc = new Alloc(memBuffer, start32, start16, start8);
	            shape = this.assembleShape(alloc, version);
	        }
	        let obj = {
	            version,
	            exporterVersion,
	            sequences
	        };
	        obj = Object.assign(obj, materialList); // Merge in the material list
	        obj = Object.assign(obj, shape); // Merge the rest of the shape data
	        return obj; // The type is fucked anyway, just go with any.
	    }
	    assembleShape(alloc, version) {
	        let numNodes = alloc.readS32();
	        let numObjects = alloc.readS32();
	        let numDecals = alloc.readS32();
	        let numSubShapes = alloc.readS32();
	        let numIflMaterials = alloc.readS32();
	        let numNodeRots;
	        let numNodeTrans;
	        let numNodeUniformScales;
	        let numNodeAlignedScales;
	        let numNodeArbitraryScales;
	        if (version < 22) {
	            numNodeRots = numNodeTrans = alloc.readS32() - numNodes;
	            numNodeUniformScales = numNodeAlignedScales = numNodeArbitraryScales = 0;
	        }
	        else {
	            numNodeRots = alloc.readS32();
	            numNodeTrans = alloc.readS32();
	            numNodeUniformScales = alloc.readS32();
	            numNodeAlignedScales = alloc.readS32();
	            numNodeArbitraryScales = alloc.readS32();
	        }
	        let numGroundFrames = 0;
	        if (version > 23)
	            numGroundFrames = alloc.readS32();
	        let numObjectStates = alloc.readS32();
	        let numDecalStates = alloc.readS32();
	        let numTriggers = alloc.readS32();
	        let numDetails = alloc.readS32();
	        let numMeshes = alloc.readS32();
	        let numSkins = 0; // Skins are apparently deprecated
	        if (version < 23)
	            numSkins = alloc.readS32();
	        let numNames = alloc.readS32();
	        let smallestVisibleSize = alloc.readF32();
	        let smallestVisibleDL = alloc.readS32();
	        alloc.guard();
	        let radius = alloc.readF32();
	        let tubeRadius = alloc.readF32();
	        let center = alloc.readPoint3F();
	        let bounds = alloc.readBoxF();
	        alloc.guard();
	        let nodeIndex = 0;
	        let nodes = Array(numNodes).fill(null).map(() => {
	            return {
	                index: nodeIndex++,
	                nameIndex: alloc.readS32(),
	                parentIndex: alloc.readS32(),
	                firstObject: alloc.readS32(),
	                firstChild: alloc.readS32(),
	                nextSibling: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let objects = Array(numObjects).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                numMeshes: alloc.readS32(),
	                startMeshIndex: alloc.readS32(),
	                nodeIndex: alloc.readS32(),
	                nextSibling: alloc.readS32(),
	                firstDecal: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let decals = Array(numDecals).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                numMeshes: alloc.readS32(),
	                startMeshIndex: alloc.readS32(),
	                objectIndex: alloc.readS32(),
	                nextSibling: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let iflMaterials = Array(numIflMaterials).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                materialSlot: alloc.readS32(),
	                firstFrame: alloc.readS32(),
	                firstFrameOffTimeIndex: alloc.readS32(),
	                numFrames: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let subShapeFirstNode = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeFirstObject = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeFirstDecal = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        alloc.guard();
	        let subShapeNumNodes = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeNumObjects = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeNumDecals = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        alloc.guard();
	        //let subShapeFirstTranslucentObject = Array(numSubShapes).fill(null).map(() => alloc.getS32());
	        // Works only without? Confus!!
	        let defaultRotations = Array(numNodes).fill(null).map(() => alloc.readQuat16());
	        let defaultTranslations = Array(numNodes).fill(null).map(() => alloc.readPoint3F());
	        let nodeRotations = Array(numNodeRots).fill(null).map(() => alloc.readQuat16());
	        let nodeTranslations = Array(numNodeTrans).fill(null).map(() => alloc.readPoint3F());
	        alloc.guard();
	        let nodeUniformScales = [];
	        let nodeAlignedScales = [];
	        let nodeArbScaleFactors = [];
	        let nodeArbScaleRots = [];
	        if (version > 21) {
	            nodeUniformScales = Array(numNodeUniformScales).fill(null).map(() => alloc.readF32());
	            nodeAlignedScales = Array(numNodeAlignedScales).fill(null).map(() => alloc.readPoint3F());
	            nodeArbScaleFactors = Array(numNodeArbitraryScales).fill(null).map(() => alloc.readPoint3F());
	            nodeArbScaleRots = Array(numNodeArbitraryScales).fill(null).map(() => alloc.readQuat16());
	            alloc.guard();
	        }
	        // Super old version stuff would go here
	        let groundTranslations = Array(numGroundFrames).fill(null).map(() => alloc.readPoint3F());
	        let groundRotations = Array(numGroundFrames).fill(null).map(() => alloc.readQuat16());
	        if (version > 23)
	            alloc.guard(); // 😂
	        let objectStates = Array(numObjectStates).fill(null).map(() => {
	            return {
	                vis: alloc.readF32(),
	                frameIndex: alloc.readS32(),
	                matFrame: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let decalStates = Array(numDecalStates).fill(null).map(() => alloc.readS32());
	        alloc.guard();
	        let triggers = Array(numTriggers).fill(null).map(() => {
	            return {
	                state: alloc.readU32(),
	                pos: alloc.readF32()
	            };
	        });
	        alloc.guard();
	        let details = Array(numDetails).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                subShapeNum: alloc.readS32(),
	                objectDetailNum: alloc.readS32(),
	                size: alloc.readF32(),
	                averageError: alloc.readF32(),
	                maxError: alloc.readF32(),
	                polyCount: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let meshes = [];
	        for (let i = 0; i < numMeshes; i++) {
	            let type = alloc.readU32();
	            if (type === MeshType.Null) {
	                // Null meshes are simply skipped
	                meshes.push(null);
	                continue;
	            }
	            alloc.guard();
	            let numFrames = alloc.readS32();
	            let numMatFrames = alloc.readS32();
	            let parentMesh = alloc.readS32();
	            let bounds = alloc.readBoxF();
	            let center = alloc.readPoint3F();
	            let radius = alloc.readF32();
	            let numVerts = alloc.readS32();
	            let verts = (parentMesh < 0) ? Array(numVerts).fill(null).map(() => alloc.readPoint3F()) : meshes[parentMesh].verts;
	            let numTVerts = alloc.readS32();
	            let tverts = (parentMesh < 0) ? Array(numTVerts).fill(null).map(() => alloc.readPoint2F()) : meshes[parentMesh].tverts;
	            let norms = (parentMesh < 0) ? Array(numVerts).fill(null).map(() => alloc.readPoint3F()) : meshes[parentMesh].norms;
	            let encodedNorms = [];
	            if (version > 21)
	                encodedNorms = (parentMesh < 0) ? Array(numVerts).fill(null).map(() => alloc.readU8()) : meshes[parentMesh].encodedNorms;
	            let numPrimitives = alloc.readS32();
	            let primitives = Array(numPrimitives).fill(null).map(() => {
	                return {
	                    start: alloc.readU16(),
	                    numElements: alloc.readU16(),
	                    matIndex: alloc.readU32()
	                };
	            });
	            let numIndices = alloc.readS32();
	            let indices = Array(numIndices).fill(null).map(() => alloc.readS16());
	            let numMergeIndices = alloc.readS32();
	            let mergeIndices = Array(numMergeIndices).fill(null).map(() => alloc.readS16());
	            let vertsPerFrame = alloc.readS32();
	            let flags = alloc.readS32();
	            alloc.guard();
	            let mesh = {
	                type,
	                numFrames,
	                numMatFrames,
	                parentMesh,
	                bounds,
	                center,
	                radius,
	                verts,
	                tverts,
	                norms,
	                encodedNorms,
	                primitives,
	                indices,
	                mergeIndices,
	                vertsPerFrame,
	                flags
	            };
	            if (type === MeshType.Skin) {
	                // A skinned mesh comes with additional properties describing the bones and skin of the mesh.
	                let numInitialVerts = alloc.readS32();
	                let initialVerts = Array(numInitialVerts).fill(null).map(() => alloc.readPoint3F());
	                let initialNorms = Array(numInitialVerts).fill(null).map(() => alloc.readPoint3F());
	                let encodedNorms = Array(numInitialVerts).fill(null).map(() => alloc.readU8());
	                let numInitialTransforms = alloc.readS32();
	                let initialTransforms = Array(numInitialTransforms).fill(null).map(() => alloc.readMatrixF());
	                let numVertIndices = alloc.readS32();
	                let vertIndices = Array(numVertIndices).fill(null).map(() => alloc.readS32());
	                let boneIndices = Array(numVertIndices).fill(null).map(() => alloc.readS32());
	                let weights = Array(numVertIndices).fill(null).map(() => alloc.readF32());
	                let numNodeIndices = alloc.readS32();
	                let nodeIndices = Array(numNodeIndices).fill(null).map(() => alloc.readS32());
	                mesh.verts = initialVerts;
	                mesh.norms = initialNorms;
	                mesh.encodedNorms = encodedNorms;
	                mesh.initialTransforms = initialTransforms;
	                mesh.vertIndices = vertIndices;
	                mesh.boneIndices = boneIndices;
	                mesh.weights = weights;
	                mesh.nodeIndices = nodeIndices;
	                alloc.guard();
	            }
	            meshes.push(mesh);
	        }
	        alloc.guard();
	        let names = [];
	        for (let i = 0; i < numNames; i++) {
	            let str = "";
	            while (true) {
	                let newCharCode = alloc.readU8();
	                if (newCharCode === 0)
	                    break; // Null-terminated string
	                str += String.fromCharCode(newCharCode);
	            }
	            names.push(str);
	        }
	        alloc.guard();
	        let alphaIn = new Array(numDetails).fill(null).map(() => alloc.readF32());
	        let alphaOut = new Array(numDetails).fill(null).map(() => alloc.readF32());
	        return {
	            smallestVisibleSize,
	            radius,
	            tubeRadius,
	            center,
	            bounds,
	            nodes,
	            objects,
	            decals,
	            iflMaterials,
	            subShapeFirstNode,
	            subShapeFirstObject,
	            subShapeFirstDecal,
	            subShapeNumNodes,
	            subShapeNumObjects,
	            subShapeNumDecals,
	            defaultRotations,
	            defaultTranslations,
	            nodeRotations,
	            nodeTranslations,
	            nodeUniformScales,
	            nodeAlignedScales,
	            nodeArbScaleFactors,
	            nodeArbScaleRots,
	            groundTranslations,
	            groundRotations,
	            objectStates,
	            decalStates,
	            triggers,
	            details,
	            meshes,
	            names,
	            alphaIn,
	            alphaOut
	        };
	    }
	    parseSequence() {
	        /// A Sequence holds all the information necessary to perform a particular animation (sequence).
	        ///
	        /// Sequences index a range of keyframes. Keyframes are assumed to be equally spaced in time.
	        ///
	        /// Each node and object is either a member of the sequence or not.  If not, they are set to
	        /// default values when we switch to the sequence unless they are members of some other active sequence.
	        /// Blended sequences "add" a transform to the current transform of a node.  Any object animation of
	        /// a blended sequence over-rides any existing object state.  Blended sequences are always
	        /// applied after non-blended sequences.
	        let nameIndex = this.readS32();
	        let flags = this.readU32();
	        let numKeyframes = this.readS32();
	        let duration = this.readF32();
	        let priority = this.readS32();
	        let firstGroundFrame = this.readS32();
	        let numGroundFrames = this.readS32();
	        let baseRotation = this.readS32();
	        let baseTranslation = this.readS32();
	        let baseScale = this.readS32();
	        let baseObjectState = this.readS32();
	        let baseDecalState = this.readS32();
	        let firstTrigger = this.readS32();
	        let numTriggers = this.readS32();
	        let toolBegin = this.readF32();
	        let rotationMatters = this.readBitSet();
	        let translationMatters = this.readBitSet();
	        let scaleMatters = this.readBitSet();
	        let decalMatters = this.readBitSet();
	        let iflMatters = this.readBitSet();
	        let visMatters = this.readBitSet();
	        let frameMatters = this.readBitSet();
	        let matFrameMatters = this.readBitSet();
	        return {
	            nameIndex,
	            flags,
	            numKeyframes,
	            duration,
	            priority,
	            firstGroundFrame,
	            numGroundFrames,
	            baseRotation,
	            baseTranslation,
	            baseScale,
	            baseObjectState,
	            baseDecalState,
	            firstTrigger,
	            numTriggers,
	            toolBegin,
	            rotationMatters,
	            translationMatters,
	            scaleMatters,
	            decalMatters,
	            iflMatters,
	            visMatters,
	            frameMatters,
	            matFrameMatters
	        };
	    }
	    /** Parses a Torque MaterialList. */
	    parseMaterialList(version) {
	        let matStreamType = this.readS8(); // Should be 1 always
	        let numMaterials = this.readS32();
	        let matNames = Array(numMaterials).fill(null).map(x => this.readString());
	        let matFlags = Array(numMaterials).fill(null).map(x => this.readU32());
	        let matReflectanceMaps = Array(numMaterials).fill(null).map(x => this.readS32());
	        let matBumpMaps = Array(numMaterials).fill(null).map(x => this.readS32());
	        let matDetailMaps = Array(numMaterials).fill(null).map(x => this.readS32());
	        if (version === 25)
	            Array(numMaterials).fill(null).map(x => this.readS32()); // dummy
	        let matDetailScales = Array(numMaterials).fill(null).map(x => this.readF32());
	        let matReflectance = Array(numMaterials).fill(null).map(x => this.readF32());
	        return {
	            matNames,
	            matFlags,
	            matReflectanceMaps,
	            matBumpMaps,
	            matDetailMaps,
	            matDetailScales,
	            matReflectance
	        };
	    }
	    readBitSet() {
	        this.index += 4; // dummy
	        let numWords = this.readS32();
	        let words = [];
	        for (let i = 0; i < numWords; i++) {
	            words.push(this.readU32());
	        }
	        return words;
	    }
	    /** Reads an old shape. Creates a new buffer in the new DTS format that is then fed into the regular parser. Refer to the TGE source for more detail. */
	    readOldShape(version) {
	        let oldAlloc = new OldAlloc(this.view, this.index);
	        oldAlloc.allocate32(15);
	        oldAlloc.guard();
	        oldAlloc.copyInto32(1); // Radius
	        oldAlloc.copyInto32(1); // Tube radius
	        oldAlloc.copyInto32(3); // Center
	        oldAlloc.copyInto32(6); // Bounds
	        oldAlloc.guard();
	        let numNodes = oldAlloc.readS32(0);
	        for (let i = 0; i < numNodes; i++) {
	            oldAlloc.copyInto32(2);
	            oldAlloc.allocate32(3);
	        }
	        oldAlloc.guard();
	        let numObjects = oldAlloc.readS32(1);
	        for (let i = 0; i < numObjects; i++) {
	            oldAlloc.copyInto32(4);
	            oldAlloc.allocate32(2);
	        }
	        oldAlloc.guard();
	        let numDecals = oldAlloc.readS32(2);
	        for (let i = 0; i < numDecals; i++) {
	            oldAlloc.copyInto32(4);
	            oldAlloc.allocate32(1);
	        }
	        oldAlloc.guard();
	        let numIflMaterials = oldAlloc.readS32(4);
	        for (let i = 0; i < numIflMaterials; i++) {
	            oldAlloc.copyInto32(2);
	            oldAlloc.allocate32(3);
	        }
	        oldAlloc.guard();
	        let numSubShapes = oldAlloc.readS32(3);
	        let subShapeFirstStart = oldAlloc.index32;
	        oldAlloc.copyInto32(numSubShapes); // subShapeFirstNode
	        oldAlloc.skip(4); // toss
	        oldAlloc.copyInto32(numSubShapes); // subShapeFirstObject
	        oldAlloc.skip(4); // toss
	        oldAlloc.copyInto32(numSubShapes); // subShapeFirstDecal
	        oldAlloc.guard();
	        let subShapeNumStart = oldAlloc.index32;
	        oldAlloc.allocate32(3 * numSubShapes);
	        oldAlloc.guard();
	        // compute subShapeNum* vectors
	        let prev, first;
	        for (let i = 0; i < 3; i++) {
	            prev = ((i === 0) ? numNodes : (i === 1 ? numObjects : numDecals));
	            for (let j = numSubShapes - 1; j >= 0; j--) {
	                first = oldAlloc.buffer32.getInt32(subShapeFirstStart + j * 4, true);
	                oldAlloc.buffer32.setInt32(subShapeNumStart + j * 4, prev - first, true);
	                prev = first;
	            }
	            subShapeFirstStart += numSubShapes;
	            subShapeNumStart += numSubShapes;
	        }
	        let numNodeStates = oldAlloc.readS32(5);
	        for (let i = 0; i < numNodeStates; i++) {
	            oldAlloc.copyInto16(4); // read Quat16....rotation
	            oldAlloc.copyInto32(3); // read Point3F...translation
	        }
	        oldAlloc.guard();
	        let numObjectStates = oldAlloc.readS32(6);
	        oldAlloc.copyInto32(numObjectStates * 3);
	        oldAlloc.guard();
	        let numDecalStates = oldAlloc.readS32(7);
	        oldAlloc.copyInto32(numDecalStates);
	        oldAlloc.guard();
	        let numTriggers = oldAlloc.readS32(8);
	        oldAlloc.copyInto32(numTriggers * 2);
	        oldAlloc.guard();
	        let numDetails = oldAlloc.readS32(9);
	        for (let i = 0; i < numDetails; i++) {
	            oldAlloc.copyInto32(4);
	            oldAlloc.allocate32(3);
	        }
	        // There's some added detail filling-up code here, but we don't use these anyways. Screw it.
	        oldAlloc.guard();
	        this.index = oldAlloc.sourceIndex;
	        let numSequences = this.readS32();
	        let sequences = [];
	        for (let i = 0; i < numSequences; i++) {
	            let sequence = this.parseSequence();
	            sequences.push(sequence);
	        }
	        oldAlloc.sourceIndex = this.index;
	        let numMeshes = oldAlloc.readS32(10);
	        for (let i = 0; i < numMeshes; i++) {
	            let meshType = oldAlloc.readS32();
	            this.readAllocMesh(oldAlloc, meshType);
	        }
	        oldAlloc.guard();
	        let numNames = oldAlloc.readS32(12);
	        for (let i = 0; i < numNames; i++) {
	            let length = oldAlloc.readS32(null);
	            oldAlloc.copyInto8(length);
	            oldAlloc.writeU8(0); // end the string
	        }
	        oldAlloc.guard();
	        let materialList = null;
	        this.index = oldAlloc.sourceIndex;
	        let gotList = this.readS32();
	        if (gotList) {
	            materialList = this.parseMaterialList(version);
	        }
	        oldAlloc.sourceIndex = this.index;
	        // Note: There would still be some skinned mesh or whatever code following this, but really, that's totally unnecessary. To prevent stupid "read out of range" errors when reading this buffer, we just add some extra bit to the end. Done.
	        oldAlloc.allocate32(16);
	        return {
	            bufferInfo: oldAlloc.createBuffer(),
	            sequences: sequences,
	            materialList: materialList
	        };
	    }
	    readAllocMesh(oldAlloc, meshType) {
	        if (meshType === MeshType.Null)
	            return;
	        oldAlloc.guard();
	        // numFrames, numMatFrames
	        oldAlloc.copyInto32(2);
	        // parentMesh
	        oldAlloc.writeS32(-1);
	        // allocate memory for mBounds,mCenter, and mRadius...just filler, will be computed later
	        oldAlloc.allocate32(10);
	        // read in verts
	        let numVerts = oldAlloc.readS32();
	        oldAlloc.copyInto32(numVerts * 3);
	        // read in tverts
	        let numTverts = oldAlloc.readS32();
	        oldAlloc.copyInto32(numTverts * 2);
	        // read in normals
	        let numNormals = oldAlloc.readS32(null); // we could assume same as verts, but apparently in file.
	        oldAlloc.copyInto32(numNormals * 3);
	        // read in primitives
	        let numPrimitives = oldAlloc.readS32();
	        for (let i = 0; i < numPrimitives; i++) {
	            oldAlloc.copyInto16(2);
	            oldAlloc.copyInto32(1);
	        }
	        // read in indices
	        let numIndices = oldAlloc.readS32();
	        oldAlloc.copyInto16(numIndices);
	        // mergeIndices...none
	        oldAlloc.writeS32(0);
	        // vertsPerFrame, flags
	        oldAlloc.copyInto32(2);
	        oldAlloc.guard();
	        if (meshType === MeshType.Skin) {
	            let numInitialVerts = oldAlloc.readS32();
	            oldAlloc.copyInto32(numInitialVerts * 3);
	            let numInitialNorms = oldAlloc.readS32(null); // we assume same as verts
	            oldAlloc.copyInto32(numInitialNorms * 3);
	            let numInitialTransforms = oldAlloc.readS32();
	            oldAlloc.copyInto32(numInitialTransforms * 16);
	            let numVertIndices = oldAlloc.readS32();
	            oldAlloc.copyInto32(numVertIndices);
	            let numBoneIndices = oldAlloc.readS32(null);
	            oldAlloc.copyInto32(numBoneIndices);
	            let weightStart = oldAlloc.index32;
	            oldAlloc.allocate32(numBoneIndices); // this is memory for the weights
	            let numNodeIndices = oldAlloc.readS32();
	            oldAlloc.copyInto32(numNodeIndices);
	            let returnToIndex = oldAlloc.index32;
	            let numWeights = oldAlloc.readS32(null);
	            oldAlloc.index32 = weightStart;
	            oldAlloc.copyInto32(numWeights);
	            oldAlloc.index32 = returnToIndex;
	            oldAlloc.guard();
	        }
	    }
	    /** Loads and parses a .dts file. Returns a cached version if already loaded. */
	    static async loadFile(path) {
	        await this.cachedFilePromises.get(path);
	        if (this.cachedFiles.get(path))
	            return this.cachedFiles.get(path);
	        let promise = (async () => {
	            let blob = await ResourceManager.loadResource(path);
	            if (!blob) {
	                throw new Error("Missing DTS resource: " + path);
	            }
	            let arrayBuffer = await ResourceManager.readBlobAsArrayBuffer(blob);
	            let parser = new DtsParser(arrayBuffer);
	            let result = parser.parse();
	            this.cachedFiles.set(path, result);
	            this.cachedFilePromises.delete(path);
	            return result;
	        })();
	        this.cachedFilePromises.set(path, promise);
	        return promise;
	    }
	}
	DtsParser.cachedFilePromises = new Map();
	DtsParser.cachedFiles = new Map();

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var hx_dif = createCommonjsModule(function (module, exports) {
	// Generated by Haxe 4.3.1
	(function ($hx_exports, $global) {$hx_exports["haxe"] = $hx_exports["haxe"] || {};
	$hx_exports["haxe"]["io"] = $hx_exports["haxe"]["io"] || {};
	$hx_exports["math"] = $hx_exports["math"] || {};
	var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
	class AISpecialNode {
		constructor(name,position) {
			this.name = name;
			this.position = position;
		}
		static read(io) {
			return new AISpecialNode(io.readStr(),math_Point3F.read(io));
		}
	}
	$hx_exports["AISpecialNode"] = AISpecialNode;
	AISpecialNode.__name__ = true;
	class AnimatedLight {
		constructor(nameIndex,stateIndex,stateCount,flags,duration) {
			this.nameIndex = nameIndex;
			this.stateIndex = stateIndex;
			this.stateCount = stateCount;
			this.flags = flags;
			this.duration = duration;
		}
		static read(io) {
			return new AnimatedLight(io.readInt32(),io.readInt32(),io.readInt16(),io.readInt16(),io.readInt32());
		}
	}
	$hx_exports["AnimatedLight"] = AnimatedLight;
	AnimatedLight.__name__ = true;
	class BSPNode {
		constructor(planeIndex,frontIndex,backIndex,isFrontLeaf,isFrontSolid,isBackLeaf,isBackSolid) {
			this.planeIndex = planeIndex;
			this.frontIndex = frontIndex;
			this.backIndex = backIndex;
			this.isFrontLeaf = isFrontLeaf;
			this.isFrontSolid = isFrontSolid;
			this.isBackLeaf = isBackLeaf;
			this.isBackSolid = isBackSolid;
		}
		static read(io,version) {
			let planeIndex = io.readUInt16();
			let frontIndex;
			let backIndex;
			let isfrontleaf = false;
			let isfrontsolid = false;
			let isbackleaf = false;
			let isbacksolid = false;
			if(version.interiorVersion >= 14) {
				frontIndex = io.readInt32();
				backIndex = io.readInt32();
				if((frontIndex & 524288) != 0) {
					frontIndex = frontIndex & -524289 | 32768;
					isfrontleaf = true;
				}
				if((frontIndex & 262144) != 0) {
					frontIndex = frontIndex & -262145 | 16384;
					isfrontsolid = true;
				}
				if((backIndex & 524288) != 0) {
					backIndex = backIndex & -524289 | 32768;
					isbackleaf = true;
				}
				if((backIndex & 262144) != 0) {
					backIndex = backIndex & -262145 | 16384;
					isbacksolid = true;
				}
			} else {
				frontIndex = io.readUInt16();
				backIndex = io.readUInt16();
				if((frontIndex & 32768) != 0) {
					isfrontleaf = true;
				}
				if((frontIndex & 16384) != 0) {
					isfrontsolid = true;
				}
				if((backIndex & 32768) != 0) {
					isbackleaf = true;
				}
				if((backIndex & 16384) != 0) {
					isbacksolid = true;
				}
			}
			return new BSPNode(planeIndex,frontIndex,backIndex,isfrontleaf,isfrontsolid,isbackleaf,isbacksolid);
		}
	}
	$hx_exports["BSPNode"] = BSPNode;
	BSPNode.__name__ = true;
	class BSPSolidLeaf {
		constructor(surfaceStart,surfaceCount) {
			this.surfaceStart = surfaceStart;
			this.surfaceCount = surfaceCount;
		}
		static read(io) {
			return new BSPSolidLeaf(io.readInt32(),io.readInt16());
		}
	}
	$hx_exports["BSPSolidLeaf"] = BSPSolidLeaf;
	BSPSolidLeaf.__name__ = true;
	class ConvexHull {
		constructor() {
			this.hullStart = 0;
			this.hullCount = 0;
			this.minX = 0;
			this.minY = 0;
			this.minZ = 0;
			this.maxX = 0;
			this.maxY = 0;
			this.maxZ = 0;
			this.surfaceStart = 0;
			this.surfaceCount = 0;
			this.planeStart = 0;
			this.polyListPlaneStart = 0;
			this.polyListPointStart = 0;
			this.polyListStringStart = 0;
			this.staticMesh = false;
		}
		static read(io,version) {
			let ret = new ConvexHull();
			ret.hullStart = io.readInt32();
			ret.hullCount = io.readUInt16();
			ret.minX = io.readFloat();
			ret.minY = io.readFloat();
			ret.minZ = io.readFloat();
			ret.maxX = io.readFloat();
			ret.maxY = io.readFloat();
			ret.maxZ = io.readFloat();
			ret.surfaceStart = io.readInt32();
			ret.surfaceCount = io.readUInt16();
			ret.planeStart = io.readInt32();
			ret.polyListPlaneStart = io.readInt32();
			ret.polyListPointStart = io.readInt32();
			ret.polyListStringStart = io.readInt32();
			if(version.interiorVersion >= 12) {
				ret.staticMesh = io.readByte() > 0;
			}
			return ret;
		}
	}
	$hx_exports["ConvexHull"] = ConvexHull;
	ConvexHull.__name__ = true;
	class CoordBin {
		constructor() {
			this.binStart = 0;
			this.binCount = 0;
		}
		static read(io) {
			let ret = new CoordBin();
			ret.binStart = io.readInt32();
			ret.binCount = io.readInt32();
			return ret;
		}
	}
	$hx_exports["CoordBin"] = CoordBin;
	CoordBin.__name__ = true;
	class Dif {
		constructor() {
			this.gameEntities = null;
			this.vehicleCollision = null;
		}
		static LoadFromBuffer(buffer) {
			let br = new io_BytesReader(buffer);
			return Dif.read(br);
		}
		static LoadFromArrayBuffer(buffer) {
			let br = new io_BytesReader(haxe_io_Bytes.ofData(buffer));
			return Dif.read(br);
		}
		static read(io) {
			let ret = new Dif();
			let version = new Version();
			version.difVersion = io.readInt32();
			ret.difVersion = version.difVersion;
			ret.previewIncluded = io.readByte();
			ret.interiors = ReaderExtensions.readArray(io,function(io) {
				return Interior.read(io,version);
			});
			ret.subObjects = ReaderExtensions.readArray(io,function(io) {
				return Interior.read(io,version);
			});
			ret.triggers = ReaderExtensions.readArray(io,Trigger.read);
			ret.interiorPathfollowers = ReaderExtensions.readArray(io,InteriorPathFollower.read);
			ret.forceFields = ReaderExtensions.readArray(io,ForceField.read);
			ret.aiSpecialNodes = ReaderExtensions.readArray(io,AISpecialNode.read);
			let readVehicleCollision = io.readInt32();
			if(readVehicleCollision == 1) {
				ret.vehicleCollision = VehicleCollision.read(io,version);
			}
			let readGameEntities = io.readInt32();
			if(readGameEntities == 2) {
				ret.gameEntities = ReaderExtensions.readArray(io,GameEntity.read);
			}
			return ret;
		}
	}
	$hx_exports["Dif"] = Dif;
	Dif.__name__ = true;
	class Edge {
		constructor(pointIndex0,pointIndex1,surfaceIndex0,surfaceIndex1) {
			this.pointIndex0 = pointIndex0;
			this.pointIndex1 = pointIndex1;
			this.surfaceIndex0 = surfaceIndex0;
			this.surfaceIndex1 = surfaceIndex1;
		}
		static read(io,version) {
			return new Edge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32());
		}
	}
	$hx_exports["Edge"] = Edge;
	Edge.__name__ = true;
	class Edge2 {
		constructor() {
			this.vertex0 = 0;
			this.vertex1 = 0;
			this.normal0 = 0;
			this.normal1 = 0;
			this.face0 = 0;
			this.face1 = 0;
		}
		static read(io,version) {
			let ret = new Edge2();
			ret.vertex0 = io.readInt32();
			ret.vertex1 = io.readInt32();
			ret.normal0 = io.readInt32();
			ret.normal1 = io.readInt32();
			if(version.interiorVersion >= 3) {
				ret.face0 = io.readInt32();
				ret.face1 = io.readInt32();
			}
			return ret;
		}
	}
	$hx_exports["Edge2"] = Edge2;
	Edge2.__name__ = true;
	class FFSurface {
		constructor() {
			this.windingStart = 0;
			this.windingCount = 0;
			this.planeIndex = 0;
			this.surfaceFlags = 0;
			this.fanMask = 0;
		}
		static read(io) {
			let ret = new FFSurface();
			ret.windingStart = io.readInt32();
			ret.windingCount = io.readByte();
			ret.planeIndex = io.readInt16();
			ret.surfaceFlags = io.readByte();
			ret.fanMask = io.readInt32();
			return ret;
		}
	}
	$hx_exports["FFSurface"] = FFSurface;
	FFSurface.__name__ = true;
	class ForceField {
		constructor() {
		}
		static read(io) {
			let ret = new ForceField();
			ret.forceFieldFileVersion = io.readInt32();
			ret.name = io.readStr();
			ret.triggers = ReaderExtensions.readArray(io,function(io) {
				return io.readStr();
			});
			ret.boundingBox = math_Box3F.read(io);
			ret.boundingSphere = math_Spheref.read(io);
			ret.normals = ReaderExtensions.readArray(io,math_Point3F.read);
			ret.planes = ReaderExtensions.readArray(io,Plane.read);
			ret.bspNodes = ReaderExtensions.readArray(io,function(io) {
				return BSPNode.read(io,new Version());
			});
			ret.bspSolidLeaves = ReaderExtensions.readArray(io,BSPSolidLeaf.read);
			ret.windings = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.surfaces = ReaderExtensions.readArray(io,FFSurface.read);
			ret.solidLeafSurfaces = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.color = ReaderExtensions.readColorF(io);
			return ret;
		}
	}
	$hx_exports["ForceField"] = ForceField;
	ForceField.__name__ = true;
	class GameEntity {
		constructor() {
			this.datablock = "";
			this.gameClass = "";
			this.position = new math_Point3F();
			this.properties = new haxe_ds_StringMap();
		}
		static read(io) {
			let ret = new GameEntity();
			ret.datablock = io.readStr();
			ret.gameClass = io.readStr();
			ret.position = math_Point3F.read(io);
			ret.properties = ReaderExtensions.readDictionary(io);
			return ret;
		}
	}
	$hx_exports["GameEntity"] = GameEntity;
	GameEntity.__name__ = true;
	class HxOverrides {
		static cca(s,index) {
			let x = s.charCodeAt(index);
			if(x != x) {
				return undefined;
			}
			return x;
		}
		static now() {
			return Date.now();
		}
	}
	HxOverrides.__name__ = true;
	class Interior {
		constructor() {
		}
		static read(io,version) {
			if(version.interiorType == "?") {
				version.interiorType = "tgea";
			}
			version.interiorVersion = io.readInt32();
			let it = new Interior();
			it.detailLevel = io.readInt32();
			it.minPixels = io.readInt32();
			it.boundingBox = math_Box3F.read(io);
			it.boundingSphere = math_Spheref.read(io);
			it.hasAlarmState = io.readByte();
			it.numLightStateEntries = io.readInt32();
			it.normals = ReaderExtensions.readArray(io,math_Point3F.read);
			it.planes = ReaderExtensions.readArray(io,Plane.read);
			it.points = ReaderExtensions.readArray(io,math_Point3F.read);
			if(version.interiorVersion == 4) {
				it.pointVisibilities = [];
			} else {
				it.pointVisibilities = ReaderExtensions.readArray(io,function(io) {
					return io.readByte();
				});
			}
			it.texGenEQs = ReaderExtensions.readArray(io,TexGenEQ.read);
			it.bspNodes = ReaderExtensions.readArray(io,function(io) {
				return BSPNode.read(io,version);
			});
			it.bspSolidLeaves = ReaderExtensions.readArray(io,BSPSolidLeaf.read);
			it.materialListVersion = io.readByte();
			it.materialList = ReaderExtensions.readArray(io,function(io) {
				return io.readStr();
			});
			it.windings = ReaderExtensions.readArrayAs(io,function(signed,param) {
				return param > 0;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readInt16();
			});
			it.windingIndices = ReaderExtensions.readArray(io,WindingIndex.read);
			if(version.interiorVersion >= 12) {
				it.edges = ReaderExtensions.readArray(io,function(io) {
					return Edge.read(io,version);
				});
			}
			it.zones = ReaderExtensions.readArray(io,function(io) {
				return Zone.read(io,version);
			});
			it.zoneSurfaces = ReaderExtensions.readArrayAs(io,function(signed,param) {
				return false;
			},function(io) {
				return io.readInt16();
			},function(io) {
				return io.readInt16();
			});
			if(version.interiorVersion >= 12) {
				it.zoneStaticMeshes = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			}
			it.zonePortalList = ReaderExtensions.readArrayAs(io,function(signed,param) {
				return false;
			},function(io) {
				return io.readInt16();
			},function(io) {
				return io.readInt16();
			});
			it.portals = ReaderExtensions.readArray(io,Portal.read);
			let pos = io.tell();
			try {
				it.surfaces = ReaderExtensions.readArray(io,function(io) {
					return Surface.read(io,version,it);
				});
				if(version.interiorType == "?") {
					version.interiorType = "tge";
				}
			} catch( _g ) {
				if(version.interiorType == "tgea") {
					version.interiorType = "tge";
				}
				io.seek(pos);
				try {
					it.surfaces = ReaderExtensions.readArray(io,function(io) {
						return Surface.read(io,version,it);
					});
				} catch( _g ) {
					version.useLargeLightmaps = true;
					io.seek(pos);
					try {
						it.surfaces = ReaderExtensions.readArray(io,function(io) {
							return Surface.read(io,version,it);
						});
					} catch( _g ) {
						let e = haxe_Exception.caught(_g);
						throw haxe_Exception.thrown(e);
					}
				}
			}
			if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
				it.edges2 = ReaderExtensions.readArray(io,function(io) {
					return Edge2.read(io,version);
				});
				if(version.interiorVersion >= 4 && version.interiorVersion <= 5) {
					it.normals2 = ReaderExtensions.readArray(io,math_Point3F.read);
					it.normalIndices = ReaderExtensions.readArrayAs(io,function(alt,param) {
						if(alt) {
							return param == 0;
						} else {
							return false;
						}
					},function(io) {
						return io.readUInt16();
					},function(io) {
						return io.readByte();
					});
				}
			}
			if(version.interiorVersion == 4) {
				it.normalLMapIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readByte();
				});
				it.alarmLMapIndices = [];
			} else if(version.interiorVersion >= 13) {
				it.normalLMapIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
				it.alarmLMapIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				it.normalLMapIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readByte();
				});
				it.alarmLMapIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readByte();
				});
			}
			it.nullSurfaces = ReaderExtensions.readArray(io,function(io) {
				return NullSurface.read(io,version);
			});
			if(version.interiorVersion != 4) {
				it.lightMaps = ReaderExtensions.readArray(io,function(io) {
					return LightMap.read(io,version);
				});
				if(it.lightMaps.length > 0 && version.interiorType == "mbg") {
					version.interiorType = "tge";
				}
			} else {
				it.lightMaps = [];
			}
			it.solidLeafSurfaces = ReaderExtensions.readArrayAs(io,function(alt,$void) {
				return alt;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
			it.animatedLights = ReaderExtensions.readArray(io,AnimatedLight.read);
			it.lightStates = ReaderExtensions.readArray(io,LightState.read);
			if(version.interiorVersion == 4) {
				it.stateDatas = [];
				it.stateDataFlags = 0;
				it.stateDataBuffers = [];
				it.subObjects = [];
			} else {
				it.stateDatas = ReaderExtensions.readArray(io,StateData.read);
				it.stateDataBuffers = ReaderExtensions.readArrayFlags(io,function(io) {
					return io.readByte();
				});
				it.nameBuffer = ReaderExtensions.readArray(io,function(io) {
					return io.readByte();
				});
				it.stateDataFlags = 0;
				it.subObjects = ReaderExtensions.readArray(io,function(io) {
					let soKey = io.readInt32();
					if(soKey == 1) {
						return MirrorSubObject.read(io,version);
					} else {
						throw new haxe_Exception("Unknown SubObject key: ");
					}
				});
			}
			it.convexHulls = ReaderExtensions.readArray(io,function(io) {
				return ConvexHull.read(io,version);
			});
			it.convexHullEmitStrings = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			if(version.interiorVersion == 0) {
				it.hullIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				it.hullIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
					return alt;
				},function(io) {
					return io.readInt32();
				},function(io) {
					return io.readUInt16();
				});
			}
			if(version.interiorVersion == 0) {
				it.hullPlaneIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readUInt16();
				});
			} else {
				it.hullPlaneIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
					return true;
				},function(io) {
					return io.readInt32();
				},function(io) {
					return io.readUInt16();
				});
			}
			if(version.interiorVersion == 0) {
				it.hullEmitStringIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				it.hullEmitStringIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
					return alt;
				},function(io) {
					return io.readInt32();
				},function(io) {
					return io.readUInt16();
				});
			}
			if(version.interiorVersion == 0) {
				it.hullSurfaceIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				it.hullSurfaceIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
					return alt;
				},function(io) {
					return io.readInt32();
				},function(io) {
					return io.readUInt16();
				});
			}
			if(version.interiorVersion == 0) {
				it.polyListPlanes = ReaderExtensions.readArray(io,function(io) {
					return io.readUInt16();
				});
			} else {
				it.polyListPlanes = ReaderExtensions.readArrayAs(io,function(alt,that) {
					return true;
				},function(io) {
					return io.readInt32();
				},function(io) {
					return io.readUInt16();
				});
			}
			if(version.interiorVersion == 0) {
				it.polyListPoints = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				it.polyListPoints = ReaderExtensions.readArrayAs(io,function(alt,that) {
					return alt;
				},function(io) {
					return io.readInt32();
				},function(io) {
					return io.readUInt16();
				});
			}
			it.polyListStrings = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.coordBins = [];
			let _g = 0;
			while(_g < 256) {
				let i = _g++;
				it.coordBins.push(CoordBin.read(io));
			}
			it.coordBinIndices = ReaderExtensions.readArrayAs(io,function(a,b) {
				return true;
			},function(io) {
				return io.readUInt16();
			},function(io) {
				return io.readUInt16();
			});
			it.coordBinMode = io.readInt32();
			if(version.interiorVersion == 4) {
				it.baseAmbientColor = [0,0,0,255];
				it.alarmAmbientColor = [0,0,0,255];
				it.extendedLightMapData = 0;
				it.lightMapBorderSize = 0;
			} else {
				it.baseAmbientColor = ReaderExtensions.readColorF(io);
				it.alarmAmbientColor = ReaderExtensions.readColorF(io);
				if(version.interiorVersion >= 10) {
					it.numStaticMeshes = io.readInt32();
				}
				if(version.interiorVersion >= 11) {
					it.texNormals = ReaderExtensions.readArray(io,math_Point3F.read);
					it.texMatrices = ReaderExtensions.readArray(io,TexMatrix.read);
					it.texMatIndices = ReaderExtensions.readArray(io,function(io) {
						return io.readInt32();
					});
				} else {
					io.readInt32();
					io.readInt32();
					io.readInt32();
				}
				it.extendedLightMapData = io.readInt32();
				if(it.extendedLightMapData > 0) {
					it.lightMapBorderSize = io.readInt32();
					io.readInt32();
				}
			}
			return it;
		}
	}
	$hx_exports["Interior"] = Interior;
	Interior.__name__ = true;
	class InteriorPathFollower {
		constructor() {
			this.name = "";
			this.datablock = "";
			this.interiorResIndex = 0;
			this.offset = new math_Point3F();
			this.properties = new haxe_ds_StringMap();
			this.triggerId = [];
			this.wayPoint = [];
			this.totalMS = 0;
		}
		static read(io) {
			let ret = new InteriorPathFollower();
			ret.name = io.readStr();
			ret.datablock = io.readStr();
			ret.interiorResIndex = io.readInt32();
			ret.offset = math_Point3F.read(io);
			ret.properties = ReaderExtensions.readDictionary(io);
			ret.triggerId = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.wayPoint = ReaderExtensions.readArray(io,WayPoint.read);
			ret.totalMS = io.readInt32();
			return ret;
		}
	}
	$hx_exports["InteriorPathFollower"] = InteriorPathFollower;
	InteriorPathFollower.__name__ = true;
	class LightMap {
		constructor() {
			this.lightmap = [];
			this.lightdirmap = [];
			this.keepLightMap = 0;
		}
		static read(io,version) {
			let ret = new LightMap();
			ret.lightmap = ReaderExtensions.readPNG(io);
			if(version.interiorType != "mbg" && version.interiorType != "tge") {
				ret.lightdirmap = ReaderExtensions.readPNG(io);
			}
			ret.keepLightMap = io.readByte();
			return ret;
		}
	}
	$hx_exports["LightMap"] = LightMap;
	LightMap.__name__ = true;
	class LightState {
		constructor(red,green,blue,activeTime,dataIndex,dataCount) {
			this.red = red;
			this.green = green;
			this.blue = blue;
			this.activeTime = activeTime;
			this.dataIndex = dataIndex;
			this.dataCount = dataCount;
		}
		static read(io) {
			return new LightState(io.readByte(),io.readByte(),io.readByte(),io.readInt32(),io.readInt32(),io.readInt16());
		}
	}
	$hx_exports["LightState"] = LightState;
	LightState.__name__ = true;
	Math.__name__ = true;
	class MirrorSubObject {
		constructor() {
			this.detailLevel = 0;
			this.zone = 0;
			this.alphaLevel = 0;
			this.surfaceCount = 0;
			this.surfaceStart = 0;
			this.centroid = new math_Point3F();
		}
		static read(io,version) {
			let ret = new MirrorSubObject();
			ret.detailLevel = io.readInt32();
			ret.zone = io.readInt32();
			ret.alphaLevel = io.readFloat();
			ret.surfaceCount = io.readInt32();
			ret.surfaceStart = io.readInt32();
			ret.centroid = math_Point3F.read(io);
			return ret;
		}
	}
	$hx_exports["MirrorSubObject"] = MirrorSubObject;
	MirrorSubObject.__name__ = true;
	class NullSurface {
		constructor() {
			this.windingStart = 0;
			this.planeIndex = 0;
			this.surfaceFlags = 0;
			this.windingCount = 0;
		}
		static read(io,version) {
			let ret = new NullSurface();
			ret.windingStart = io.readInt32();
			ret.planeIndex = io.readUInt16();
			ret.surfaceFlags = io.readByte();
			if(version.interiorVersion >= 13) {
				ret.windingCount = io.readInt32();
			} else {
				ret.windingCount = io.readByte();
			}
			return ret;
		}
	}
	$hx_exports["NullSurface"] = NullSurface;
	NullSurface.__name__ = true;
	class Plane {
		constructor(normalIndex,planeDistance) {
			this.normalIndex = normalIndex;
			this.planeDistance = planeDistance;
		}
		static read(io) {
			return new Plane(io.readInt16(),io.readFloat());
		}
	}
	$hx_exports["Plane"] = Plane;
	Plane.__name__ = true;
	class Polyhedron {
		constructor() {
			this.pointList = [];
			this.planeList = [];
			this.edgeList = [];
		}
		static read(io) {
			let ret = new Polyhedron();
			ret.pointList = ReaderExtensions.readArray(io,math_Point3F.read);
			ret.planeList = ReaderExtensions.readArray(io,math_PlaneF.read);
			ret.edgeList = ReaderExtensions.readArray(io,PolyhedronEdge.read);
			return ret;
		}
	}
	$hx_exports["Polyhedron"] = Polyhedron;
	Polyhedron.__name__ = true;
	class PolyhedronEdge {
		constructor(faceIndex0,faceIndex1,pointIndex0,pointIndex1) {
			this.pointIndex0 = pointIndex0;
			this.pointIndex1 = pointIndex1;
			this.faceIndex0 = faceIndex0;
			this.faceIndex1 = faceIndex1;
		}
		static read(io) {
			return new PolyhedronEdge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32());
		}
	}
	$hx_exports["PolyhedronEdge"] = PolyhedronEdge;
	PolyhedronEdge.__name__ = true;
	class Portal {
		constructor(planeIndex,triFanCount,triFanStart,zoneFront,zoneBack) {
			this.planeIndex = planeIndex;
			this.triFanCount = triFanCount;
			this.triFanStart = triFanStart;
			this.zoneFront = zoneFront;
			this.zoneBack = zoneBack;
		}
		static read(io) {
			return new Portal(io.readUInt16(),io.readUInt16(),io.readInt32(),io.readUInt16(),io.readUInt16());
		}
	}
	$hx_exports["Portal"] = Portal;
	Portal.__name__ = true;
	class ReaderExtensions {
		static readDictionary(io) {
			let len = io.readInt32();
			let dict = new haxe_ds_StringMap();
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				let name = io.readStr();
				let value = io.readStr();
				dict.h[name] = value;
			}
			return dict;
		}
		static readArray(io,readMethod) {
			let len = io.readInt32();
			let arr = [];
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				arr.push(readMethod(io));
			}
			return arr;
		}
		static readArrayAs(io,test,failMethod,passMethod) {
			let length = io.readInt32();
			let signed = false;
			let param = 0;
			if((length & -2147483648) == -2147483648) {
				length ^= -2147483648;
				signed = true;
				param = io.readByte();
			}
			let array = [];
			let _g = 0;
			let _g1 = length;
			while(_g < _g1) {
				let i = _g++;
				if(test(signed,param)) {
					array.push(passMethod(io));
				} else {
					array.push(failMethod(io));
				}
			}
			return array;
		}
		static readArrayFlags(io,readMethod) {
			let length = io.readInt32();
			let flags = io.readInt32();
			let array = [];
			let _g = 0;
			let _g1 = length;
			while(_g < _g1) {
				let i = _g++;
				array.push(readMethod(io));
			}
			return array;
		}
		static readPNG(io) {
			let footer = [73,69,78,68,174,66,96,130];
			let data = [];
			while(true) {
				data.push(io.readByte());
				if(data.length >= 8) {
					let match = true;
					let _g = 0;
					while(_g < 8) {
						let i = _g++;
						if(data[i + (data.length - 8)] != footer[i]) {
							match = false;
							break;
						}
					}
					if(match) {
						break;
					}
				}
			}
			return data;
		}
		static readColorF(io) {
			return [io.readByte(),io.readByte(),io.readByte(),io.readByte()];
		}
	}
	ReaderExtensions.__name__ = true;
	class StateData {
		constructor(surfaceIndex,mapIndex,lightStateIndex) {
			this.surfaceIndex = surfaceIndex;
			this.mapIndex = mapIndex;
			this.lightStateIndex = lightStateIndex;
		}
		static read(io) {
			return new StateData(io.readInt32(),io.readInt32(),io.readInt16());
		}
	}
	$hx_exports["StateData"] = StateData;
	StateData.__name__ = true;
	class Surface {
		constructor() {
			this.windingStart = 0;
			this.windingCount = 0;
			this.planeIndex = 0;
			this.textureIndex = 0;
			this.texGenIndex = 0;
			this.surfaceFlags = 0;
			this.fanMask = 0;
			this.lightMapFinalWord = 0;
			this.lightMapTexGenXD = 0;
			this.lightMapTexGenYD = 0;
			this.lightCount = 0;
			this.lightStateInfoStart = 0;
			this.mapOffsetX = 0;
			this.mapOffsetY = 0;
			this.mapSizeX = 0;
			this.mapSizeY = 0;
			this.brushId = 0;
		}
		static read(io,version,interior) {
			let ret = new Surface();
			ret.windingStart = io.readInt32();
			if(interior.windings.length <= ret.windingStart) {
				throw new haxe_Exception("DIF Type Error interior.windings.length <= ret.windingStart");
			}
			if(version.interiorVersion >= 13) {
				ret.windingCount = io.readInt32();
			} else {
				ret.windingCount = io.readByte();
			}
			if(ret.windingStart + ret.windingCount > interior.windings.length) {
				throw new haxe_Exception("DIF Type Error ret.windingStart + ret.windingCount > interior.windings.length");
			}
			let planeIndex = io.readInt16();
			ret.planeFlipped = planeIndex >> 15 != 0;
			let planeIndexTemp = planeIndex & -32769;
			if((planeIndexTemp & -32769) >= interior.planes.length) {
				throw new haxe_Exception("DIF Type Error (planeIndexTemp & ~0x8000) >= interior.planes.length");
			}
			ret.planeIndex = planeIndexTemp;
			ret.textureIndex = io.readInt16();
			if(ret.textureIndex >= interior.materialList.length) {
				throw new haxe_Exception("DIF Type Error ret.textureIndex >= interior.materialList.length");
			}
			ret.texGenIndex = io.readInt32();
			if(ret.texGenIndex >= interior.texGenEQs.length) {
				throw new haxe_Exception("DIF Type Error ret.texGenIndex >= interior.texGenEQs.length");
			}
			ret.surfaceFlags = io.readByte();
			ret.fanMask = io.readInt32();
			ret.lightMapFinalWord = io.readInt16();
			ret.lightMapTexGenXD = io.readFloat();
			ret.lightMapTexGenYD = io.readFloat();
			ret.lightCount = io.readInt16();
			ret.lightStateInfoStart = io.readInt32();
			if(version.interiorVersion >= 13) {
				ret.mapOffsetX = io.readInt32();
				ret.mapOffsetY = io.readInt32();
				ret.mapSizeX = io.readInt32();
				ret.mapSizeY = io.readInt32();
			} else if(version.interiorVersion == 0 && version.interiorType == "tge" && version.useLargeLightmaps) {
				ret.mapOffsetX = io.readUInt16();
				ret.mapOffsetY = io.readUInt16();
				ret.mapSizeX = io.readUInt16();
				ret.mapSizeY = io.readUInt16();
			} else {
				ret.mapOffsetX = io.readByte();
				ret.mapOffsetY = io.readByte();
				ret.mapSizeX = io.readByte();
				ret.mapSizeY = io.readByte();
			}
			if(version.interiorType != "tge" && version.interiorType != "mbg") {
				io.readByte();
				if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
					ret.brushId = io.readInt32();
				}
			}
			return ret;
		}
	}
	$hx_exports["Surface"] = Surface;
	Surface.__name__ = true;
	class TexGenEQ {
		constructor() {
			this.planeX = new math_PlaneF();
			this.planeY = new math_PlaneF();
		}
		static read(io) {
			let ret = new TexGenEQ();
			ret.planeX = math_PlaneF.read(io);
			ret.planeY = math_PlaneF.read(io);
			return ret;
		}
	}
	$hx_exports["TexGenEQ"] = TexGenEQ;
	TexGenEQ.__name__ = true;
	class TexMatrix {
		constructor() {
			this.t = 0;
			this.n = 0;
			this.b = 0;
		}
		static read(io) {
			let ret = new TexMatrix();
			ret.t = io.readInt32();
			ret.n = io.readInt32();
			ret.b = io.readInt32();
			return ret;
		}
	}
	$hx_exports["TexMatrix"] = TexMatrix;
	TexMatrix.__name__ = true;
	class Trigger {
		constructor() {
			this.name = "";
			this.datablock = "";
			this.offset = new math_Point3F();
			this.properties = new haxe_ds_StringMap();
			this.polyhedron = new Polyhedron();
		}
		static read(io) {
			let ret = new Trigger();
			ret.name = io.readStr();
			ret.datablock = io.readStr();
			ret.properties = ReaderExtensions.readDictionary(io);
			ret.polyhedron = Polyhedron.read(io);
			ret.offset = math_Point3F.read(io);
			return ret;
		}
	}
	$hx_exports["Trigger"] = Trigger;
	Trigger.__name__ = true;
	class VehicleCollision {
		constructor() {
		}
		static read(io,version) {
			let ret = new VehicleCollision();
			ret.vehicleCollisionFileVersion = io.readInt32();
			ret.convexHulls = ReaderExtensions.readArray(io,function(io) {
				return ConvexHull.read(io,version);
			});
			ret.convexHullEmitStrings = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			ret.hullIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.hullPlaneIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt16();
			});
			ret.hullEmitStringIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.hullSurfaceIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.polyListPlanes = ReaderExtensions.readArray(io,function(io) {
				return io.readInt16();
			});
			ret.polyListPoints = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.polyListStrings = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			ret.nullSurfaces = ReaderExtensions.readArray(io,function(io) {
				return NullSurface.read(io,new Version());
			});
			ret.points = ReaderExtensions.readArray(io,math_Point3F.read);
			ret.planes = ReaderExtensions.readArray(io,Plane.read);
			ret.windings = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			ret.windingIndices = ReaderExtensions.readArray(io,WindingIndex.read);
			return ret;
		}
	}
	$hx_exports["VehicleCollision"] = VehicleCollision;
	VehicleCollision.__name__ = true;
	class Version {
		constructor() {
			this.difVersion = 44;
			this.interiorVersion = 0;
			this.interiorType = "?";
			this.useLargeLightmaps = false;
		}
	}
	$hx_exports["Version"] = Version;
	Version.__name__ = true;
	class WayPoint {
		constructor(position,rotation,msToNext,smoothingType) {
			this.position = position;
			this.rotation = rotation;
			this.msToNext = msToNext;
			this.smoothingType = smoothingType;
		}
		static read(io) {
			return new WayPoint(math_Point3F.read(io),math_QuatF.read(io),io.readInt32(),io.readInt32());
		}
	}
	$hx_exports["WayPoint"] = WayPoint;
	WayPoint.__name__ = true;
	class WindingIndex {
		constructor(windingStart,windingCount) {
			this.windingStart = windingStart;
			this.windingCount = windingCount;
		}
		static read(io) {
			return new WindingIndex(io.readInt32(),io.readInt32());
		}
	}
	$hx_exports["WindingIndex"] = WindingIndex;
	WindingIndex.__name__ = true;
	class Zone {
		constructor() {
			this.portalStart = 0;
			this.portalCount = 0;
			this.surfaceStart = 0;
			this.surfaceCount = 0;
			this.staticMeshStart = 0;
			this.staticMeshCount = 0;
			this.flags = 0;
		}
		static read(io,version) {
			let ret = new Zone();
			ret.portalStart = io.readUInt16();
			ret.portalCount = io.readUInt16();
			ret.surfaceStart = io.readInt32();
			if(version.interiorType == "tgea" || version.interiorType == "tge") {
				if(version.interiorVersion >= 14 || version.interiorVersion == 0) {
					ret.surfaceCount = io.readUInt16();
				} else {
					ret.surfaceCount = io.readInt32();
				}
			} else {
				ret.surfaceCount = io.readInt32();
			}
			if(version.interiorVersion >= 12) {
				ret.staticMeshStart = io.readInt32();
				ret.staticMeshCount = io.readInt32();
			}
			if(version.interiorType == "tgea" || version.interiorType == "tge") {
				if(version.interiorVersion >= 14 || version.interiorVersion == 0) {
					ret.flags = io.readUInt16();
				}
			}
			return ret;
		}
	}
	$hx_exports["Zone"] = Zone;
	Zone.__name__ = true;
	class haxe_Exception extends Error {
		constructor(message,previous,native) {
			super(message);
			this.message = message;
			this.__previousException = previous;
			this.__nativeException = native != null ? native : this;
		}
		toString() {
			return this.get_message();
		}
		get_message() {
			return this.message;
		}
		get_native() {
			return this.__nativeException;
		}
		static caught(value) {
			if(((value) instanceof haxe_Exception)) {
				return value;
			} else if(((value) instanceof Error)) {
				return new haxe_Exception(value.message,null,value);
			} else {
				return new haxe_ValueException(value,null,value);
			}
		}
		static thrown(value) {
			if(((value) instanceof haxe_Exception)) {
				return value.get_native();
			} else if(((value) instanceof Error)) {
				return value;
			} else {
				let e = new haxe_ValueException(value);
				return e;
			}
		}
	}
	haxe_Exception.__name__ = true;
	class haxe__$Int64__$_$_$Int64 {
		constructor(high,low) {
			this.high = high;
			this.low = low;
		}
	}
	haxe__$Int64__$_$_$Int64.__name__ = true;
	class haxe_ValueException extends haxe_Exception {
		constructor(value,previous,native) {
			super(String(value),previous,native);
			this.value = value;
		}
	}
	haxe_ValueException.__name__ = true;
	class haxe_ds_StringMap {
		constructor() {
			this.h = Object.create(null);
		}
	}
	haxe_ds_StringMap.__name__ = true;
	class haxe_io_Bytes {
		constructor(data) {
			this.length = data.byteLength;
			this.b = new Uint8Array(data);
			this.b.bufferValue = data;
			data.hxBytes = this;
			data.bytes = this.b;
		}
		get(pos) {
			return this.b[pos];
		}
		set(pos,v) {
			this.b[pos] = v;
		}
		blit(pos,src,srcpos,len) {
			if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
				throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
			}
			if(srcpos == 0 && len == src.b.byteLength) {
				this.b.set(src.b,pos);
			} else {
				this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
			}
		}
		fill(pos,len,value) {
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				this.b[pos++] = value;
			}
		}
		sub(pos,len) {
			if(pos < 0 || len < 0 || pos + len > this.length) {
				throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
			}
			return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
		}
		compare(other) {
			let b1 = this.b;
			let b2 = other.b;
			let len = this.length < other.length ? this.length : other.length;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				if(b1[i] != b2[i]) {
					return b1[i] - b2[i];
				}
			}
			return this.length - other.length;
		}
		initData() {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
		}
		getDouble(pos) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			return this.data.getFloat64(pos,true);
		}
		getFloat(pos) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			return this.data.getFloat32(pos,true);
		}
		setDouble(pos,v) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			this.data.setFloat64(pos,v,true);
		}
		setFloat(pos,v) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			this.data.setFloat32(pos,v,true);
		}
		getUInt16(pos) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			return this.data.getUint16(pos,true);
		}
		setUInt16(pos,v) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			this.data.setUint16(pos,v,true);
		}
		getInt32(pos) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			return this.data.getInt32(pos,true);
		}
		setInt32(pos,v) {
			if(this.data == null) {
				this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
			}
			this.data.setInt32(pos,v,true);
		}
		getInt64(pos) {
			return new haxe__$Int64__$_$_$Int64(this.getInt32(pos + 4),this.getInt32(pos));
		}
		setInt64(pos,v) {
			this.setInt32(pos,v.low);
			this.setInt32(pos + 4,v.high);
		}
		getString(pos,len,encoding) {
			if(pos < 0 || len < 0 || pos + len > this.length) {
				throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
			}
			if(encoding == null) {
				encoding = haxe_io_Encoding.UTF8;
			}
			let s = "";
			let b = this.b;
			let i = pos;
			let max = pos + len;
			switch(encoding._hx_index) {
			case 0:
				while(i < max) {
					let c = b[i++];
					if(c < 128) {
						if(c == 0) {
							break;
						}
						s += String.fromCodePoint(c);
					} else if(c < 224) {
						let code = (c & 63) << 6 | b[i++] & 127;
						s += String.fromCodePoint(code);
					} else if(c < 240) {
						let c2 = b[i++];
						let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
						s += String.fromCodePoint(code);
					} else {
						let c2 = b[i++];
						let c3 = b[i++];
						let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
						s += String.fromCodePoint(u);
					}
				}
				break;
			case 1:
				while(i < max) {
					let c = b[i++] | b[i++] << 8;
					s += String.fromCodePoint(c);
				}
				break;
			}
			return s;
		}
		readString(pos,len) {
			return this.getString(pos,len);
		}
		toString() {
			return this.getString(0,this.length);
		}
		toHex() {
			let s_b = "";
			let chars = [];
			let str = "0123456789abcdef";
			let _g = 0;
			let _g1 = str.length;
			while(_g < _g1) {
				let i = _g++;
				chars.push(HxOverrides.cca(str,i));
			}
			let _g2 = 0;
			let _g3 = this.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let c = this.b[i];
				s_b += String.fromCodePoint(chars[c >> 4]);
				s_b += String.fromCodePoint(chars[c & 15]);
			}
			return s_b;
		}
		getData() {
			return this.b.bufferValue;
		}
		static alloc(length) {
			return new haxe_io_Bytes(new ArrayBuffer(length));
		}
		static ofString(s,encoding) {
			if(encoding == haxe_io_Encoding.RawNative) {
				let buf = new Uint8Array(s.length << 1);
				let _g = 0;
				let _g1 = s.length;
				while(_g < _g1) {
					let i = _g++;
					let c = s.charCodeAt(i);
					buf[i << 1] = c & 255;
					buf[i << 1 | 1] = c >> 8;
				}
				return new haxe_io_Bytes(buf.buffer);
			}
			let a = [];
			let i = 0;
			while(i < s.length) {
				let c = s.charCodeAt(i++);
				if(55296 <= c && c <= 56319) {
					c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
				}
				if(c <= 127) {
					a.push(c);
				} else if(c <= 2047) {
					a.push(192 | c >> 6);
					a.push(128 | c & 63);
				} else if(c <= 65535) {
					a.push(224 | c >> 12);
					a.push(128 | c >> 6 & 63);
					a.push(128 | c & 63);
				} else {
					a.push(240 | c >> 18);
					a.push(128 | c >> 12 & 63);
					a.push(128 | c >> 6 & 63);
					a.push(128 | c & 63);
				}
			}
			return new haxe_io_Bytes(new Uint8Array(a).buffer);
		}
		static ofData(b) {
			let hb = b.hxBytes;
			if(hb != null) {
				return hb;
			}
			return new haxe_io_Bytes(b);
		}
		static ofHex(s) {
			if((s.length & 1) != 0) {
				throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
			}
			let a = [];
			let i = 0;
			let len = s.length >> 1;
			while(i < len) {
				let high = s.charCodeAt(i * 2);
				let low = s.charCodeAt(i * 2 + 1);
				high = (high & 15) + ((high & 64) >> 6) * 9;
				low = (low & 15) + ((low & 64) >> 6) * 9;
				a.push((high << 4 | low) & 255);
				++i;
			}
			return new haxe_io_Bytes(new Uint8Array(a).buffer);
		}
		static fastGet(b,pos) {
			return b.bytes[pos];
		}
	}
	$hx_exports["haxe"]["io"]["Bytes"] = haxe_io_Bytes;
	haxe_io_Bytes.__name__ = true;
	var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
		,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
		,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
	};
	haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
	var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
		,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
		,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
		,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
		,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
	};
	haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
	class io_BytesReader {
		constructor(bytes) {
			this.bytes = bytes;
			this.position = 0;
		}
		readInt32() {
			let b = this.bytes.getInt32(this.position);
			this.position += 4;
			return b;
		}
		readInt16() {
			let b = this.bytes.getUInt16(this.position);
			this.position += 2;
			return b;
		}
		readUInt16() {
			let b = this.bytes.getUInt16(this.position);
			this.position += 2;
			return b;
		}
		readByte() {
			let b = this.bytes.b[this.position];
			this.position += 1;
			return b;
		}
		readStr() {
			let len = this.readByte();
			let str = "";
			let reading = true;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				let ch = this.readByte();
				if(ch == 0) {
					reading = false;
				}
				if(reading) {
					str += String.fromCodePoint(ch);
				}
			}
			return str;
		}
		readFloat() {
			let b = this.bytes.getFloat(this.position);
			this.position += 4;
			return b;
		}
		tell() {
			return this.position;
		}
		seek(pos) {
			this.position = pos;
		}
	}
	io_BytesReader.__name__ = true;
	class js_Boot {
		static __string_rec(o,s) {
			if(o == null) {
				return "null";
			}
			if(s.length >= 5) {
				return "<...>";
			}
			let t = typeof(o);
			if(t == "function" && (o.__name__ || o.__ename__)) {
				t = "object";
			}
			switch(t) {
			case "function":
				return "<function>";
			case "object":
				if(o.__enum__) {
					let e = $hxEnums[o.__enum__];
					let con = e.__constructs__[o._hx_index];
					let n = con._hx_name;
					if(con.__params__) {
						s = s + "\t";
						return n + "(" + ((function($this) {
							var $r;
							let _g = [];
							{
								let _g1 = 0;
								let _g2 = con.__params__;
								while(true) {
									if(!(_g1 < _g2.length)) {
										break;
									}
									let p = _g2[_g1];
									_g1 = _g1 + 1;
									_g.push(js_Boot.__string_rec(o[p],s));
								}
							}
							$r = _g;
							return $r;
						}())).join(",") + ")";
					} else {
						return n;
					}
				}
				if(((o) instanceof Array)) {
					let str = "[";
					s += "\t";
					let _g = 0;
					let _g1 = o.length;
					while(_g < _g1) {
						let i = _g++;
						str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
					}
					str += "]";
					return str;
				}
				let tostr;
				try {
					tostr = o.toString;
				} catch( _g ) {
					return "???";
				}
				if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
					let s2 = o.toString();
					if(s2 != "[object Object]") {
						return s2;
					}
				}
				let str = "{\n";
				s += "\t";
				let hasp = o.hasOwnProperty != null;
				let k = null;
				for( k in o ) {
				if(hasp && !o.hasOwnProperty(k)) {
					continue;
				}
				if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
					continue;
				}
				if(str.length != 2) {
					str += ", \n";
				}
				str += s + k + " : " + js_Boot.__string_rec(o[k],s);
				}
				s = s.substring(1);
				str += "\n" + s + "}";
				return str;
			case "string":
				return o;
			default:
				return String(o);
			}
		}
	}
	js_Boot.__name__ = true;
	class math_Box3F {
		constructor(minX,minY,minZ,maxX,maxY,maxZ) {
			if(maxZ == null) {
				maxZ = 0.0;
			}
			if(maxY == null) {
				maxY = 0.0;
			}
			if(maxX == null) {
				maxX = 0.0;
			}
			if(minZ == null) {
				minZ = 0.0;
			}
			if(minY == null) {
				minY = 0.0;
			}
			if(minX == null) {
				minX = 0.0;
			}
			this.minX = minX;
			this.minY = minY;
			this.minZ = minZ;
			this.maxX = maxX;
			this.maxY = maxY;
			this.maxZ = maxZ;
		}
		clone() {
			return new math_Box3F(this.minX,this.minY,this.minZ,this.maxX,this.maxY,this.maxZ);
		}
		center() {
			return new math_Point3F(this.minX + this.maxX,this.minY + this.maxY,this.minZ + this.maxZ).scalarDiv(2);
		}
		extend(box) {
			this.minX = Math.min(this.minX,box.minX);
			this.minY = Math.min(this.minY,box.minY);
			this.minZ = Math.min(this.minZ,box.minZ);
			this.maxX = Math.max(this.maxX,box.maxX);
			this.maxY = Math.max(this.maxY,box.maxY);
			this.maxZ = Math.max(this.maxZ,box.maxZ);
		}
		Expand(point) {
			if(this.minX > point.x) {
				this.minX = point.x;
			}
			if(this.minY > point.y) {
				this.minY = point.y;
			}
			if(this.minZ > point.z) {
				this.minZ = point.z;
			}
			if(this.maxX < point.x) {
				this.maxX = point.x;
			}
			if(this.maxY < point.y) {
				this.maxY = point.y;
			}
			if(this.maxZ < point.z) {
				this.maxZ = point.z;
			}
		}
		contains(p) {
			if(this.minX <= p.x && p.x <= this.maxX && this.minY <= p.y && p.y <= this.maxY && this.minZ <= p.z) {
				return p.z <= this.maxZ;
			} else {
				return false;
			}
		}
		getClosestPoint(point) {
			let closest = new math_Point3F();
			if(this.minX > point.x) {
				closest.x = this.minX;
			} else if(this.maxX < point.x) {
				closest.x = this.maxX;
			} else {
				closest.x = point.x;
			}
			if(this.minY > point.y) {
				closest.y = this.minY;
			} else if(this.maxY < point.y) {
				closest.y = this.maxY;
			} else {
				closest.y = point.y;
			}
			if(this.minZ > point.z) {
				closest.z = this.minZ;
			} else if(this.maxZ < point.z) {
				closest.z = this.maxZ;
			} else {
				closest.z = point.z;
			}
			return closest;
		}
		static PointBounds(point,size) {
			let ret = new math_Box3F();
			ret.minX = point.x;
			ret.minY = point.y;
			ret.minZ = point.z;
			ret.maxX = point.x + size.x;
			ret.maxY = point.y + size.y;
			ret.maxZ = point.z + size.z;
			return ret;
		}
		static read(io) {
			let ret = new math_Box3F();
			ret.minX = io.readFloat();
			ret.minY = io.readFloat();
			ret.minZ = io.readFloat();
			ret.maxX = io.readFloat();
			ret.maxY = io.readFloat();
			ret.maxZ = io.readFloat();
			return ret;
		}
	}
	$hx_exports["math"]["Box3F"] = math_Box3F;
	math_Box3F.__name__ = true;
	class math_PlaneF {
		constructor(x,y,z,d) {
			if(d == null) {
				d = 0.0;
			}
			if(z == null) {
				z = 0.0;
			}
			if(y == null) {
				y = 0.0;
			}
			if(x == null) {
				x = 0.0;
			}
			this.x = x;
			this.y = y;
			this.z = z;
			this.d = d;
		}
		static ThreePoints(a,b,c) {
			let v1 = a.sub(b);
			let v2 = c.sub(b);
			let res = v1.cross(v2);
			let ret = new math_PlaneF();
			let normal = res.normalized();
			ret.x = normal.x;
			ret.y = normal.y;
			ret.z = normal.z;
			ret.d = -b.dot(normal);
			return ret;
		}
		static NormalD(normal,d) {
			let ret = new math_PlaneF();
			ret.x = normal.x;
			ret.y = normal.y;
			ret.z = normal.z;
			ret.d = d;
			return ret;
		}
		static PointNormal(pt,n) {
			let ret = new math_PlaneF();
			let normal = n.normalized();
			ret.x = normal.x;
			ret.y = normal.y;
			ret.z = normal.z;
			ret.d = -pt.dot(normal);
			return ret;
		}
		static read(io) {
			let ret = new math_PlaneF();
			ret.x = io.readFloat();
			ret.y = io.readFloat();
			ret.z = io.readFloat();
			ret.d = io.readFloat();
			return ret;
		}
	}
	$hx_exports["math"]["PlaneF"] = math_PlaneF;
	math_PlaneF.__name__ = true;
	class math_Point3F {
		constructor(x,y,z) {
			if(z == null) {
				z = 0.0;
			}
			if(y == null) {
				y = 0.0;
			}
			if(x == null) {
				x = 0.0;
			}
			this.x = x;
			this.y = y;
			this.z = z;
		}
		get(dim) {
			if(dim == 0) {
				return this.x;
			}
			if(dim == 1) {
				return this.y;
			}
			if(dim == 2) {
				return this.z;
			}
			return -1;
		}
		set(dim,value) {
			if(dim == 0) {
				this.x = value;
			}
			if(dim == 1) {
				this.y = value;
			}
			if(dim == 2) {
				this.z = value;
			}
		}
		add(rhs) {
			return new math_Point3F(this.x + rhs.x,this.y + rhs.y,this.z + rhs.z);
		}
		sub(rhs) {
			return new math_Point3F(this.x - rhs.x,this.y - rhs.y,this.z - rhs.z);
		}
		scalar(rhs) {
			return new math_Point3F(this.x * rhs,this.y * rhs,this.z * rhs);
		}
		scalarDiv(rhs) {
			return new math_Point3F(this.x / rhs,this.y / rhs,this.z / rhs);
		}
		dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		}
		cross(rhs) {
			return new math_Point3F(this.y * rhs.z - this.z * rhs.y,this.z * rhs.x - this.x * rhs.z,this.x * rhs.y - this.y * rhs.x);
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}
		normalized() {
			if(this.length() != 0) {
				return this.scalarDiv(this.length());
			} else {
				return this;
			}
		}
		equal(other) {
			if(this.x == other.x && this.y == other.y) {
				return this.z == other.z;
			} else {
				return false;
			}
		}
		copy() {
			return new math_Point3F(this.x,this.y,this.z);
		}
		static read(io) {
			let ret = new math_Point3F();
			ret.x = io.readFloat();
			ret.y = io.readFloat();
			ret.z = io.readFloat();
			return ret;
		}
	}
	$hx_exports["math"]["Point3F"] = math_Point3F;
	math_Point3F.__name__ = true;
	class math_Point4F {
		constructor() {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		}
		static read(io) {
			let ret = new math_Point4F();
			ret.x = io.readFloat();
			ret.y = io.readFloat();
			ret.z = io.readFloat();
			ret.w = io.readFloat();
			return ret;
		}
	}
	$hx_exports["math"]["Point4F"] = math_Point4F;
	math_Point4F.__name__ = true;
	class math_QuatF {
		constructor() {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		}
		static read(io) {
			let ret = new math_QuatF();
			ret.x = io.readFloat();
			ret.y = io.readFloat();
			ret.z = io.readFloat();
			ret.w = io.readFloat();
			return ret;
		}
	}
	$hx_exports["math"]["QuatF"] = math_QuatF;
	math_QuatF.__name__ = true;
	class math_Spheref {
		constructor() {
			this.originX = 0;
			this.originY = 0;
			this.originZ = 0;
			this.radius = 0;
		}
		static read(io) {
			let ret = new math_Spheref();
			ret.originX = io.readFloat();
			ret.originY = io.readFloat();
			ret.originZ = io.readFloat();
			ret.radius = io.readFloat();
			return ret;
		}
	}
	$hx_exports["math"]["Spheref"] = math_Spheref;
	math_Spheref.__name__ = true;
	if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
		HxOverrides.now = performance.now.bind(performance);
	}
	if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); };
	{
		String.__name__ = true;
		Array.__name__ = true;
	}
	js_Boot.__toStr = ({ }).toString;
	})( exports );
	});

	/** Represents a playable mission. Contains all the necessary metadata, as well as methods for loading the mission and gettings its resources. */
	class Mission {
	    constructor(path, misFile) {
	        this.qualifyTime = Infinity;
	        this.goldTime = -Infinity; // Doubles as platinum time
	        this.ultimateTime = -Infinity;
	        this.type = 'custom';
	        this.zipDirectory = null;
	        this.fileToBlobPromises = new Map();
	        this.difCachePromises = new Map();
	        this.difCache = new Map();
	        this.isNew = false;
	        this.createdAt = 0;
	        this.hasEasterEgg = false;
	        this.hasBlast = false;
	        this.hasUltraMarble = false;
	        this.path = path;
	        this.misFile = misFile;
	        if (misFile) {
	            this.root = misFile.root;
	            this.initAllElements();
	        }
	    }
	    /** Creates a new Mission from a .mis file. */
	    static fromMisFile(path, misFile) {
	        var _a, _b;
	        let mission = new Mission(path, misFile);
	        let missionInfo = mission.allElements.find(element => element._type === MissionElementType.ScriptObject && element._name === 'MissionInfo');
	        mission.missionInfo = missionInfo;
	        mission.title = missionInfo.name;
	        mission.artist = (_a = missionInfo.artist) !== null && _a !== void 0 ? _a : '';
	        mission.description = (_b = missionInfo.desc) !== null && _b !== void 0 ? _b : '';
	        if (missionInfo.time && missionInfo.time !== "0")
	            mission.qualifyTime = MisParser.parseNumber(missionInfo.time);
	        if (missionInfo.goldtime)
	            mission.goldTime = MisParser.parseNumber(missionInfo.goldtime);
	        if (missionInfo.platinumtime)
	            mission.goldTime = MisParser.parseNumber(missionInfo.platinumtime);
	        if (missionInfo.ultimatetime)
	            mission.ultimateTime = MisParser.parseNumber(missionInfo.ultimatetime);
	        mission.type = missionInfo.type.toLowerCase();
	        mission.modification = path.startsWith('mbp/') ? 'platinum' : path.startsWith('mbu/') ? 'ultra' : 'gold';
	        mission.hasEasterEgg = mission.allElements.some(element => { var _a; return element._type === MissionElementType.Item && ((_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'easteregg'; });
	        mission.setUltraFlags();
	        return mission;
	    }
	    /** Creates a new mission from a CLA entry. */
	    static fromCustomLevelInfo(info, isNew) {
	        var _a, _b;
	        let path = 'custom/' + info.id;
	        if (info.modification === 'platinum')
	            path = 'mbp/' + path;
	        if (info.modification === 'ultra')
	            path = 'mbu/' + path;
	        let mission = new Mission(path);
	        mission.title = info.name.trim();
	        mission.artist = (_a = info.artist) !== null && _a !== void 0 ? _a : '';
	        mission.description = (_b = info.desc) !== null && _b !== void 0 ? _b : '';
	        if (info.qualifyingTime)
	            mission.qualifyTime = info.qualifyingTime;
	        if (info.goldTime)
	            mission.goldTime = info.goldTime;
	        if (info.platinumTime)
	            mission.goldTime = info.platinumTime;
	        if (info.ultimateTime)
	            mission.ultimateTime = info.ultimateTime;
	        mission.id = info.id;
	        mission.isNew = isNew;
	        mission.createdAt = info.addedAt;
	        mission.modification = info.modification;
	        mission.hasEasterEgg = info.hasEasterEgg;
	        return mission;
	    }
	    initAllElements() {
	        this.allElements = [];
	        const traverse = (simGroup) => {
	            for (let element of simGroup.elements) {
	                this.allElements.push(element);
	                if (element._type === MissionElementType.SimGroup)
	                    traverse(element);
	            }
	        };
	        traverse(this.root);
	    }
	    initSearchString() {
	        // Just the title and artist for now
	        this.searchString = Util.removeSpecialCharacters(Util.normalizeString(this.title + ' ' + this.artist)).toLowerCase().trim();
	    }
	    /** Loads this mission for gameplay. */
	    async load() {
	        if (this.misFile)
	            return; // We already have the .mis file, we don't need to do anything
	        if (this.type !== 'custom')
	            return; // Just a safety check
	        // Get the zip archive
	        let blob = await ResourceManager.loadResource(`./api/custom/${this.id}.zip`);
	        let arrayBuffer = await ResourceManager.readBlobAsArrayBuffer(blob);
	        let zip = await JSZip.loadAsync(arrayBuffer); // Unzip the thing
	        this.zipDirectory = zip;
	        // Normalize filenames within the zip
	        for (let filename in zip.files) {
	            let val = zip.files[filename];
	            delete zip.files[filename];
	            zip.files[filename.toLowerCase()] = val;
	            zip.files[filename.toLowerCase().replace('data/', 'data_mbp/')] = val; // Alias every data/ with a data_mbp/ entry
	            if (this.modification === 'gold' && filename.includes('interiors_mbg/')) {
	                // Create an alias in interiors
	                zip.files[filename.replace('interiors_mbg/', 'interiors/')] = val;
	            }
	        }
	        // Read the .mis file
	        let missionFileName = Object.keys(zip.files).find(x => x.endsWith('.mis'));
	        let text = await ResourceManager.readBlobAsText(await zip.files[missionFileName].async('blob'), 'ISO-8859-1');
	        let parser = new MisParser(text);
	        let misFile = parser.parse();
	        this.misFile = misFile;
	        this.root = misFile.root;
	        this.initAllElements();
	        // Set up some metadata
	        let missionInfo = this.allElements.find(x => x._type === MissionElementType.ScriptObject && x._name === "MissionInfo");
	        if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.time) {
	            this.qualifyTime = MisParser.parseNumber(missionInfo.time);
	            if (!this.qualifyTime)
	                this.qualifyTime = Infinity; // Catches both 0 and NaN cases
	        }
	        if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.goldtime) {
	            this.goldTime = MisParser.parseNumber(missionInfo.goldtime);
	            if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.platinumtime)
	                this.goldTime = MisParser.parseNumber(missionInfo.platinumtime);
	            if (!this.goldTime) { // Again, catches both 0 and NaN cases
	                this.goldTime = -Infinity;
	            }
	        }
	        if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.ultimatetime) {
	            this.ultimateTime = MisParser.parseNumber(missionInfo.ultimatetime);
	            if (!this.ultimateTime) { // Again again, catches both 0 and NaN cases
	                this.ultimateTime = -Infinity;
	            }
	        }
	        this.missionInfo = missionInfo;
	        this.setUltraFlags();
	    }
	    setUltraFlags() {
	        var _a, _b;
	        if (!MisParser.parseBoolean(this.missionInfo.noblast) && (MisParser.parseBoolean(this.missionInfo.blast) || ((_a = this.missionInfo.game) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'ultra'))
	            this.hasBlast = true;
	        if (((_b = this.missionInfo.game) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'ultra' || MisParser.parseBoolean(this.missionInfo.useultramarble))
	            this.hasUltraMarble = true;
	    }
	    getDirectoryMissionPath() {
	        if (this.modification === 'gold')
	            return 'missions/' + this.path;
	        if (this.modification === 'ultra')
	            return 'missions_mbu/' + this.path.slice(4);
	        if (this.modification === 'platinum')
	            return 'missions_mbp/' + this.path.slice(4);
	    }
	    /** Gets the path of the image of a mission. */
	    getImagePath() {
	        if (this.type !== 'custom') {
	            let directoryMissionPath = this.getDirectoryMissionPath();
	            if (state.modification !== 'gold')
	                directoryMissionPath = directoryMissionPath.replace('missions/', 'missions_mbg/');
	            let withoutExtension = directoryMissionPath.slice(0, -4);
	            let imagePaths = ResourceManager.getFullNamesOf(withoutExtension, state.modification !== 'gold');
	            let imagePath;
	            for (let path of imagePaths) {
	                if (!path.endsWith('.mis')) {
	                    imagePath = path;
	                    break;
	                }
	            }
	            let res = directoryMissionPath.slice(0, directoryMissionPath.lastIndexOf('/') + 1) + imagePath;
	            if (state.modification === 'gold')
	                return "./assets/data/" + res;
	            return "./assets/data_mbp/" + res;
	        }
	        else {
	            // Request the bitmap
	            return `./api/custom/${this.id}.jpg`;
	        }
	    }
	    /** Gets a DIF file from the mission resources.
	     * @param rawElementPath The raw path specified within the .mis file
	     */
	    async getDif(rawElementPath) {
	        rawElementPath = rawElementPath.toLowerCase();
	        let path = rawElementPath.slice(rawElementPath.indexOf('data/'));
	        if (this.modification === 'gold' && path.includes('interiors_mbg/'))
	            path = path.replace('interiors_mbg/', 'interiors/');
	        if (this.modification !== 'gold')
	            path = path.replace('data/', 'data_mbp/');
	        let dif = null;
	        await this.difCachePromises.get(path);
	        if (this.difCache.get(path)) {
	            dif = this.difCache.get(path); // We've already parsed the dif before
	        }
	        else {
	            let promise = (async () => {
	                let dif;
	                if (this.zipDirectory && this.zipDirectory.files[path]) {
	                    // Get it from the zip
	                    let arrayBuffer = await this.zipDirectory.files[path].async('arraybuffer');
	                    dif = hx_dif.Dif.LoadFromArrayBuffer(arrayBuffer);
	                }
	                else {
	                    let blob = await ResourceManager.loadResource('./assets/' + path);
	                    if (!blob) {
	                        dif = null;
	                    }
	                    else {
	                        let arrayBuffer = await ResourceManager.readBlobAsArrayBuffer(blob);
	                        dif = hx_dif.Dif.LoadFromArrayBuffer(arrayBuffer);
	                    }
	                }
	                this.difCache.set(path, dif);
	                this.difCachePromises.delete(path);
	                return dif;
	            })();
	            this.difCachePromises.set(path, promise);
	            dif = await promise;
	        }
	        return { dif, path };
	    }
	    /** Gets a DTS file from the mission resources. */
	    async getDts(path) {
	        let dts = null;
	        let base = (state.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files['data/' + path]) {
	            // Get it from the zip
	            let arrayBuffer = await this.zipDirectory.files['data/' + path].async('arraybuffer');
	            let parser = new DtsParser(arrayBuffer);
	            let result = parser.parse();
	            dts = result;
	        }
	        else {
	            dts = await DtsParser.loadFile('./assets/' + base + path);
	        }
	        return dts;
	    }
	    /** Same as `ResourceManager.getFullNamesOf`, but including custom mission resources. */
	    getFullNamesOf(path) {
	        path = path.toLowerCase();
	        let result = [];
	        let prepended = 'data/' + path;
	        if (this.zipDirectory) {
	            for (let filePath in this.zipDirectory.files) {
	                if (filePath.startsWith(prepended)) {
	                    if (filePath.length !== prepended.length && prepended.length !== filePath.lastIndexOf('.'))
	                        continue;
	                    result.push(filePath.slice(filePath.lastIndexOf('/') + 1));
	                }
	            }
	        }
	        result.push(...ResourceManager.getFullNamesOf(path, this.modification !== 'gold'));
	        return result;
	    }
	    /** Gets a blob for a file in the zip directory. */
	    getBlobForFile(path) {
	        let file = this.zipDirectory.files[path];
	        if (this.fileToBlobPromises.get(file))
	            return this.fileToBlobPromises.get(file);
	        let promise = file.async('blob');
	        this.fileToBlobPromises.set(file, promise);
	        return promise;
	    }
	    /** Gets a texture from the mission resources. */
	    async getTexture(path) {
	        path = path.toLowerCase();
	        let base = (this.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files[base + path]) {
	            let blob = await this.getBlobForFile(base + path);
	            let url = ResourceManager.getUrlToBlob(blob);
	            let texture = await ResourceManager.getTexture(url, '');
	            return texture;
	        }
	        else {
	            let texture = await ResourceManager.getTexture(path, 'assets/' + base);
	            return texture;
	        }
	    }
	    /** Gets a general resource from the mission resources. */
	    async getResource(path) {
	        path = path.toLowerCase();
	        let base = (this.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files[base + path]) {
	            let blob = await this.getBlobForFile(base + path);
	            return blob;
	        }
	        else {
	            return await ResourceManager.loadResource('./assets/' + base + path);
	        }
	    }
	    /** Gets an image from the mission resources. */
	    async getImage(path) {
	        path = path.toLowerCase();
	        let base = (this.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files[base + path]) {
	            let blob = await this.getBlobForFile(base + path);
	            let url = ResourceManager.getUrlToBlob(blob);
	            return await ResourceManager.loadImage(url, base + path);
	        }
	        else {
	            return await ResourceManager.loadImage('./assets/' + base + path);
	        }
	    }
	    /** Returns true iff the mission matches the given query. */
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    matchesSearch(queryWords, query) {
	        // Disabled because it honestly creates garbage results in many cases
	        //if (Util.isSubsequenceOf(query, this.searchString)) return true;
	        for (let i = 0; i < queryWords.length; i++) {
	            if (!this.searchString.includes(queryWords[i]))
	                return false;
	        }
	        return true;
	    }
	    /** Computes the clock time in MBP when the user should be warned that they're about to exceed the par time. */
	    computeAlarmStartTime() {
	        let alarmStart = this.qualifyTime;
	        if (this.missionInfo.alarmstarttime)
	            alarmStart -= MisParser.parseNumber(this.missionInfo.alarmstarttime) * 1000;
	        else
	            alarmStart -= 15 * 1000;
	        alarmStart = Math.max(0, alarmStart);
	        return alarmStart;
	    }
	    static compareLexicographically(a, b) {
	        return Util.normalizeString(a.title).localeCompare(Util.normalizeString(b.title), undefined, { numeric: true, sensitivity: 'base' });
	    }
	    static compareChronologically(a, b) {
	        return a.createdAt - b.createdAt;
	    }
	}

	class MissionLibrary {
	    /** Loads all missions. */
	    static async init() {
	        let mbgMissionFilenames = [];
	        let mbpMissionFilenames = [];
	        let mbuMissionFilenames = [];
	        const collectMissionFiles = (arr, directory, path) => {
	            for (let name in directory) {
	                if (directory[name]) {
	                    collectMissionFiles(arr, directory[name], path + name + '/');
	                }
	                else if (name.endsWith('.mis')) {
	                    arr.push(path + name);
	                }
	            }
	        };
	        collectMissionFiles(mbgMissionFilenames, ResourceManager.dataDirectoryStructure['missions'], ''); // Find all mission files
	        collectMissionFiles(mbpMissionFilenames, ResourceManager.dataMbpDirectoryStructure['missions_mbp'], '');
	        collectMissionFiles(mbuMissionFilenames, ResourceManager.dataMbpDirectoryStructure['missions_mbu'], '');
	        let mbgPromises = [];
	        let mbpPromises = [];
	        let mbuPromises = [];
	        for (let filename of mbgMissionFilenames) {
	            // Load and read all missions
	            mbgPromises.push(MisParser.loadFile("./assets/data/missions/" + filename));
	        }
	        for (let filename of mbpMissionFilenames) {
	            mbpPromises.push(MisParser.loadFile("./assets/data_mbp/missions_mbp/" + filename));
	        }
	        for (let filename of mbuMissionFilenames) {
	            mbuPromises.push(MisParser.loadFile("./assets/data_mbp/missions_mbu/" + filename));
	        }
	        // Get the list of all custom levels
	        let customLevelListPromise = ResourceManager.loadResource('/api/customs');
	        let mbgMisFiles = await Promise.all(mbgPromises);
	        let mbpMisFiles = await Promise.all(mbpPromises);
	        let mbuMisFiles = await Promise.all(mbuPromises);
	        let misFileToFilename = new Map();
	        for (let i = 0; i < mbgMissionFilenames.length; i++)
	            misFileToFilename.set(mbgMisFiles[i], mbgMissionFilenames[i]);
	        for (let i = 0; i < mbpMissionFilenames.length; i++)
	            misFileToFilename.set(mbpMisFiles[i], mbpMissionFilenames[i]);
	        for (let i = 0; i < mbuMissionFilenames.length; i++)
	            misFileToFilename.set(mbuMisFiles[i], mbuMissionFilenames[i]);
	        let mbgMissions = [];
	        let mbpMissions = [];
	        let mbuMissions = [];
	        // Create the regular missions
	        for (let misFile of mbgMisFiles) {
	            let mission = Mission.fromMisFile(misFileToFilename.get(misFile), misFile);
	            mbgMissions.push(mission);
	        }
	        for (let misFile of mbpMisFiles) {
	            let mission = Mission.fromMisFile('mbp/' + misFileToFilename.get(misFile), misFile);
	            mbpMissions.push(mission);
	        }
	        for (let misFile of mbuMisFiles) {
	            let mission = Mission.fromMisFile('mbu/' + misFileToFilename.get(misFile), misFile);
	            mbuMissions.push(mission);
	        }
	        // Sort the missions by level index so they're in the right order
	        const sortFn = (a, b) => {
	            return MisParser.parseNumber(a.missionInfo.level) - MisParser.parseNumber(b.missionInfo.level);
	        };
	        mbgMissions.sort(sortFn);
	        mbpMissions.sort(sortFn);
	        mbuMissions.sort(sortFn);
	        // Read the custom level list
	        let customs = await ResourceManager.readBlobAsJson(await customLevelListPromise);
	        let goldCustoms = customs.filter(x => x.modification === 'gold');
	        let platCustoms = customs.filter(x => x.modification === 'platinum');
	        let ultraCustoms = customs.filter(x => x.modification === 'ultra');
	        // Create all custom missions
	        for (let custom of [...goldCustoms, ...platCustoms, ...ultraCustoms]) {
	            let mission = Mission.fromCustomLevelInfo(custom, false);
	            if (mission.modification === 'gold')
	                mbgMissions.push(mission);
	            else if (mission.modification === 'ultra')
	                mbuMissions.push(mission);
	            else
	                mbpMissions.push(mission);
	        }
	        // Sort the missions into the correct array
	        for (let mission of mbgMissions) {
	            let missionType = mission.type;
	            if (missionType === 'beginner')
	                this.goldBeginner.push(mission);
	            else if (missionType === 'intermediate')
	                this.goldIntermediate.push(mission);
	            else if (missionType === 'advanced')
	                this.goldAdvanced.push(mission);
	            else
	                this.goldCustom.push(mission);
	            this.allMissions.push(mission);
	        }
	        for (let mission of mbpMissions) {
	            let missionType = mission.type;
	            if (missionType === 'beginner')
	                this.platinumBeginner.push(mission);
	            else if (missionType === 'intermediate')
	                this.platinumIntermediate.push(mission);
	            else if (missionType === 'advanced')
	                this.platinumAdvanced.push(mission);
	            else if (missionType === 'expert')
	                this.platinumExpert.push(mission);
	            else
	                this.platinumCustom.push(mission);
	            this.allMissions.push(mission);
	        }
	        for (let mission of mbuMissions) {
	            let missionType = mission.type;
	            if (missionType === 'beginner')
	                this.ultraBeginner.push(mission);
	            else if (missionType === 'intermediate')
	                this.ultraIntermediate.push(mission);
	            else if (missionType === 'advanced')
	                this.ultraAdvanced.push(mission);
	            else
	                this.ultraCustom.push(mission);
	            this.allMissions.push(mission);
	        }
	        // Strange case, but these two levels are in opposite order in the original game.
	        Util.swapInArray(this.goldIntermediate, 11, 12);
	        // Sort all custom levels lexicographically
	        this.goldCustom.sort(Mission.compareLexicographically);
	        this.platinumCustom.sort(Mission.compareLexicographically);
	        this.ultraCustom.sort(Mission.compareLexicographically);
	        for (let i = 0; i < this.goldBeginner.length; i++)
	            this.goldBeginner[i].initSearchString();
	        for (let i = 0; i < this.goldIntermediate.length; i++)
	            this.goldIntermediate[i].initSearchString();
	        for (let i = 0; i < this.goldAdvanced.length; i++)
	            this.goldAdvanced[i].initSearchString();
	        for (let i = 0; i < this.goldCustom.length; i++)
	            this.goldCustom[i].initSearchString();
	        for (let i = 0; i < this.platinumBeginner.length; i++)
	            this.platinumBeginner[i].initSearchString();
	        for (let i = 0; i < this.platinumIntermediate.length; i++)
	            this.platinumIntermediate[i].initSearchString();
	        for (let i = 0; i < this.platinumAdvanced.length; i++)
	            this.platinumAdvanced[i].initSearchString();
	        for (let i = 0; i < this.platinumExpert.length; i++)
	            this.platinumExpert[i].initSearchString();
	        for (let i = 0; i < this.platinumCustom.length; i++)
	            this.platinumCustom[i].initSearchString();
	        for (let i = 0; i < this.ultraBeginner.length; i++)
	            this.ultraBeginner[i].initSearchString();
	        for (let i = 0; i < this.ultraIntermediate.length; i++)
	            this.ultraIntermediate[i].initSearchString();
	        for (let i = 0; i < this.ultraAdvanced.length; i++)
	            this.ultraAdvanced[i].initSearchString();
	        for (let i = 0; i < this.ultraCustom.length; i++)
	            this.ultraCustom[i].initSearchString();
	        this.allCategories.push(this.goldBeginner, this.goldIntermediate, this.goldAdvanced, this.goldCustom, this.platinumBeginner, this.platinumIntermediate, this.platinumAdvanced, this.platinumExpert, this.platinumCustom, this.ultraBeginner, this.ultraIntermediate, this.ultraAdvanced, this.ultraCustom);
	    }
	    static getModification(arr) {
	        var _a, _b;
	        return (_b = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.modification) !== null && _b !== void 0 ? _b : null;
	    }
	    static getDifficulty(arr) {
	        var _a, _b;
	        return (_b = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : null;
	    }
	}
	MissionLibrary.allMissions = [];
	MissionLibrary.allCategories = [];
	MissionLibrary.goldBeginner = [];
	MissionLibrary.goldIntermediate = [];
	MissionLibrary.goldAdvanced = [];
	MissionLibrary.goldCustom = [];
	MissionLibrary.platinumBeginner = [];
	MissionLibrary.platinumIntermediate = [];
	MissionLibrary.platinumAdvanced = [];
	MissionLibrary.platinumExpert = [];
	MissionLibrary.platinumCustom = [];
	MissionLibrary.ultraBeginner = [];
	MissionLibrary.ultraIntermediate = [];
	MissionLibrary.ultraAdvanced = [];
	MissionLibrary.ultraCustom = [];

	/** Defines the geometry for a 3D mesh. */
	class Geometry {
	    constructor() {
	        /** A list of numbers describing the 3D coordinates of the vertices. */
	        this.positions = [];
	        /** A list of numbers describing the normals of the vertices. */
	        this.normals = [];
	        /** A list of numbers describing the UV texture coordinates of the vertices. */
	        this.uvs = [];
	        /** The list of vertex indices that should be drawn. */
	        this.indices = [];
	        /** For each vertex index, this array defines the material that vertex uses. Only really makes sense if all vertices that make up a triangle have the same material. */
	        this.materials = [];
	    }
	    /** Fills the normal and uv arrays so their lengths match with the vertex positions. */
	    fillRest() {
	        while (this.normals.length / 3 < this.positions.length / 3)
	            this.normals.push(0, 0, 0);
	        while (this.uvs.length / 2 < this.positions.length / 3)
	            this.uvs.push(0, 0);
	    }
	    /** Makes sure the geometry isn't ill-defined. */
	    validate() {
	        // Check if all arrays actually describe the same amount of vertices
	        if (new Set([this.positions.length / 3, this.normals.length / 3, this.uvs.length / 2]).size !== 1) {
	            console.error(this);
	            throw new Error(`Geometry is invalid (vertex counts don't match):
Positions: ${this.positions.length / 3}
Normals: ${this.normals.length / 3}
Uvs: ${this.uvs.length / 2},
Material Indices: ${this.materials.length / 1}
			`);
	        }
	        // Check that all indices are in bounds
	        for (let i = 0; i < this.indices.length; i++) {
	            let index = this.indices[i];
	            if (index >= this.positions.length / 3) {
	                console.error(this);
	                throw new Error("Geometry is invalid (index points out of bounds)");
	            }
	        }
	        let tris = this.indices.length;
	        if (tris % 3)
	            throw new Error("Geometry is invalid (triangle count isn't a whole number): " + tris / 3);
	    }
	    /** Creates a UV sphere geometry. Largely taken from three.js source. */
	    static createSphereGeometry(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
	        let geometry = new Geometry();
	        widthSegments = Math.max(3, Math.floor(widthSegments));
	        heightSegments = Math.max(2, Math.floor(heightSegments));
	        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
	        let index = 0;
	        const grid = [];
	        const vertex = new Vector3();
	        const normal = new Vector3();
	        // buffers
	        const vertices = [];
	        const normals = [];
	        const uvs = [];
	        // generate vertices, normals and uvs
	        for (let iy = 0; iy <= heightSegments; iy++) {
	            const verticesRow = [];
	            const v = iy / heightSegments;
	            // special case for the poles
	            let uOffset = 0;
	            if (iy === 0 && thetaStart === 0) {
	                uOffset = 0.5 / widthSegments;
	            }
	            else if (iy === heightSegments && thetaEnd === Math.PI) {
	                uOffset = -0.5 / widthSegments;
	            }
	            for (let ix = 0; ix <= widthSegments; ix++) {
	                const u = ix / widthSegments;
	                // vertex
	                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
	                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	                vertices.push(vertex.x, vertex.y, vertex.z);
	                // normal
	                normal.copy(vertex).normalize();
	                normals.push(normal.x, normal.y, normal.z);
	                // uv
	                uvs.push(u + uOffset, 1 - v);
	                verticesRow.push(index++);
	            }
	            grid.push(verticesRow);
	        }
	        Util.pushArray(geometry.positions, vertices);
	        Util.pushArray(geometry.normals, normals);
	        Util.pushArray(geometry.uvs, uvs);
	        // indices
	        for (let iy = 0; iy < heightSegments; iy++) {
	            for (let ix = 0; ix < widthSegments; ix++) {
	                const a = grid[iy][ix + 1];
	                const b = grid[iy][ix];
	                const c = grid[iy + 1][ix];
	                const d = grid[iy + 1][ix + 1];
	                if (iy !== 0 || thetaStart > 0)
	                    geometry.indices.push(a, b, d);
	                if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
	                    geometry.indices.push(b, c, d);
	            }
	        }
	        Util.pushArray(geometry.materials, Array(geometry.indices.length).fill(0));
	        return geometry;
	    }
	}

	const IDENTITY_MATRIX = new Matrix4();
	/** Represents an object in 3D space. */
	class Object3D {
	    constructor() {
	        this.parent = null;
	        /** The object's local transform. */
	        this.transform = new Matrix4();
	        this.position = new Vector3();
	        this.orientation = new Quaternion();
	        this.scale = new Vector3(1, 1, 1);
	        /** The object's global transform in world space. */
	        this.worldTransform = new Matrix4();
	        this.needsWorldTransformUpdate = true;
	    }
	    /** Updates this object's global transformation matrix. */
	    updateWorldTransform() {
	        var _a, _b;
	        // Multiply our parent's transform by our own local transform
	        this.worldTransform.copy((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.worldTransform) !== null && _b !== void 0 ? _b : IDENTITY_MATRIX).multiply(this.transform);
	        this.needsWorldTransformUpdate = false;
	        this.transform.decompose(this.position, this.orientation, this.scale); // Keep these values synced with the matrix
	    }
	    /** Marks the object as having received a change to its transform and needing to be updated. */
	    changedTransform() {
	        this.needsWorldTransformUpdate = true;
	        // Also signal it to all ancestors
	        let parent = this.parent;
	        while (parent && !parent.needsWorldTransformUpdate) {
	            parent.needsWorldTransformUpdate = true;
	            parent = parent.parent;
	        }
	    }
	    /** Updates the transformation matrix from position, orienation and scale values. */
	    recomputeTransform() {
	        this.transform.compose(this.position, this.orientation, this.scale);
	        this.changedTransform();
	    }
	}

	/** A mesh, defined by geometry and materials, can be added to a scene graph and rendered. */
	class Mesh extends Object3D {
	    constructor(geometry, materials) {
	        super();
	        /** Whether or not the mesh info buffer needs to be updated because this mesh's info changed. */
	        this.needsMeshInfoBufferUpdate = true;
	        /** Whether or not the vertex buffers need to be updated because this mesh's geometry changed. */
	        this.needsVertexBufferUpdate = false;
	        this._opacity = 1.0;
	        this.castShadows = false;
	        /** Stores the vertex indices for each separate material of this mesh. */
	        this.materialIndices = [];
	        this.hasTransparentMaterials = false;
	        this.geometry = geometry;
	        this.materials = materials;
	    }
	    changedTransform() {
	        if (this.needsWorldTransformUpdate)
	            return;
	        super.changedTransform();
	        this.needsMeshInfoBufferUpdate = true;
	    }
	    get opacity() {
	        return this._opacity;
	    }
	    set opacity(value) {
	        if (value === this._opacity)
	            return;
	        this._opacity = value;
	        this.needsMeshInfoBufferUpdate = true;
	    }
	    updateMeshInfoBuffer(buffer, index) {
	        // The mesh info consists of the mesh's transform and other things. Since the last row of a transformation matrix is constant, that row is used to encode the other data.
	        buffer.set(this.worldTransform.elements, index);
	        buffer[index + 3] = this._opacity;
	        let flags = 0; // Unused right now
	        buffer[index + 7] = flags;
	        this.needsMeshInfoBufferUpdate = false;
	    }
	    compileMaterialIndices() {
	        let map = new Map();
	        for (let i = 0; i < this.geometry.indices.length; i++) {
	            let materialIndex = this.geometry.materials[i];
	            let material = this.materials[materialIndex];
	            let data = map.get(material);
	            if (!data) {
	                data = { material, indices: [] };
	                map.set(material, data);
	                this.materialIndices.push(data);
	            }
	            let index = this.geometry.indices[i];
	            data.indices.push(this.vboOffset + index); // Note we offset the index by our VBO offset so that the index actually makes sense within the whole VBO
	        }
	        for (let group of this.materialIndices) {
	            group.indexBuffer = new Uint32Array(group.indices); // We create a typed array here because we'll need for speedy copying later on
	        }
	    }
	}

	/** A material defines the visual appearance of a mesh and controls the vertex/fragment shaders that are needed to render it. */
	class Material {
	    constructor() {
	        /** Identical materials will get merged into one. To keep materials separate, this differentiator value can be set to something that makes this material unique. */
	        this.differentiator = '';
	        this.diffuseMap = null;
	        this.envMap = null;
	        this.normalMap = null;
	        this.specularMap = null;
	        this.noiseMap = null;
	        this.emissive = false;
	        this.transparent = false;
	        /** When false, the depth buffer will not be written to. */
	        this.depthWrite = true;
	        this.opacity = 1;
	        this.blending = BlendingType.Normal;
	        /** When set to true, normals will be normalized in the shader before they are used. */
	        this.normalizeNormals = false;
	        /** Inverts the R value (D3D9-style normal maps) */
	        this.invertU = false;
	        /** Flips the V texture coordinate. */
	        this.flipY = false;
	        this.isSky = false;
	        /** Shadow materials show nothing but the shadow cast on them. */
	        this.isShadow = false;
	        this.receiveShadows = false;
	        this.reflectivity = 0;
	        /** Defines if the environment map is defined within a "Z-up" space. OpenGL normally uses a Y-up coordinate system, which is why this setting is necessary. */
	        this.envMapZUp = true;
	        /** Creates a more realistic reflection by making the object more reflective at its edges. */
	        this.useFresnel = false;
	        /** When set, the reflection ray is computed per-fragment and not per-vertex. */
	        this.useAccurateReflectionRay = false;
	        this.specularIntensity = 0;
	        this.shininess = 30;
	        /** If set, all incoming light will be saturated to at most 1.0 in each color channel. */
	        this.saturateIncomingLight = true;
	        this.visible = true;
	        /** Materials with a lower render order will be rendered first. */
	        this.renderOrder = 0;
	        /** The factor by which to scale all secondary map (normal & specular) UV coordinates by. */
	        this.secondaryMapUvFactor = 1;
	        this.hashCache = null;
	        this.defineChunkCache = null;
	    }
	    /** Gets the hash of the material. Two materials with the same configuration will have an identical hash. */
	    getHash() {
	        var _a, _b, _c, _d, _e;
	        if (this.hashCache)
	            return this.hashCache;
	        let components = [
	            this.differentiator,
	            (_a = this.diffuseMap) === null || _a === void 0 ? void 0 : _a.id,
	            (_b = this.envMap) === null || _b === void 0 ? void 0 : _b.id,
	            (_c = this.normalMap) === null || _c === void 0 ? void 0 : _c.id,
	            (_d = this.specularMap) === null || _d === void 0 ? void 0 : _d.id,
	            (_e = this.noiseMap) === null || _e === void 0 ? void 0 : _e.id,
	            this.emissive,
	            this.transparent,
	            this.depthWrite,
	            this.opacity,
	            this.blending,
	            this.normalizeNormals,
	            this.invertU,
	            this.flipY,
	            this.isSky,
	            this.isShadow,
	            this.receiveShadows,
	            this.reflectivity,
	            this.envMapZUp,
	            this.useFresnel,
	            this.specularIntensity,
	            this.shininess,
	            this.saturateIncomingLight,
	            this.renderOrder,
	            this.secondaryMapUvFactor
	        ];
	        return this.hashCache = components.map(x => '' + x).join(' ');
	    }
	    /** Gets the #define chunk that needs to be prepended to both the vertex and fragment shaders to make the material work. */
	    getDefineChunk() {
	        if (this.defineChunkCache)
	            return this.defineChunkCache;
	        let defines = [];
	        if (this.diffuseMap)
	            defines.push('USE_DIFFUSE_MAP');
	        if (this.envMap)
	            defines.push('USE_ENV_MAP');
	        if (this.normalMap)
	            defines.push('USE_NORMAL_MAP');
	        if (this.specularMap)
	            defines.push('USE_SPECULAR_MAP');
	        if (this.noiseMap)
	            defines.push('USE_NOISE_MAP');
	        if (this.emissive)
	            defines.push('EMISSIVE');
	        if (this.transparent)
	            defines.push('TRANSPARENT');
	        if (this.normalizeNormals)
	            defines.push('NORMALIZE_NORMALS');
	        if (this.invertU)
	            defines.push('INVERT_U');
	        if (this.flipY)
	            defines.push('FLIP_Y');
	        if (this.isSky)
	            defines.push('IS_SKY');
	        if (this.isShadow)
	            defines.push('IS_SHADOW');
	        if (this.receiveShadows)
	            defines.push('RECEIVE_SHADOWS');
	        if (this.envMapZUp)
	            defines.push('ENV_MAP_Z_UP');
	        if (this.useFresnel)
	            defines.push('USE_FRESNEL');
	        if (this.useAccurateReflectionRay)
	            defines.push('USE_ACCURATE_REFLECTION_RAY');
	        if (this.specularIntensity)
	            defines.push('USE_SPECULAR');
	        if (this.saturateIncomingLight)
	            defines.push('SATURATE_INCOMING_LIGHT');
	        if (this.blending === BlendingType.Normal)
	            defines.push('USE_PREMULTIPLIED_ALPHA');
	        return this.defineChunkCache = defines.map(x => `#define ${x}\n`).join('');
	    }
	}

	var RigidBodyType;
	(function (RigidBodyType) {
	    RigidBodyType[RigidBodyType["Dynamic"] = 0] = "Dynamic";
	    RigidBodyType[RigidBodyType["Static"] = 1] = "Static"; // Has infinite mass and doesn't get affected by external forces such as gravity
	})(RigidBodyType || (RigidBodyType = {}));
	let dq = new Quaternion();
	let v1$1 = new Vector3();
	let q1$1 = new Quaternion();
	class RigidBody {
	    constructor() {
	        this.world = null;
	        this.type = RigidBodyType.Dynamic;
	        /** Disabled bodies will be skipped in the simulation loop. */
	        this.enabled = true;
	        this.position = new Vector3();
	        this.orientation = new Quaternion();
	        this.linearVelocity = new Vector3();
	        this.angularVelocity = new Vector3();
	        this.prevPosition = new Vector3();
	        this.prevOrientation = new Quaternion();
	        this.prevLinearVelocity = new Vector3();
	        this.prevAngularVelocity = new Vector3();
	        /** Indicates whether the previous values are valid, i.e. have been set. */
	        this.prevValid = false;
	        /** The shapes that make up this rigid body. */
	        this.shapes = [];
	        /** The list of collisions this body was a part of in the last simulation step. */
	        this.collisions = [];
	        /** Bodies with lower evaluation order will be evaluated first in the simulation loop. */
	        this.evaluationOrder = 0;
	    }
	    transformPoint(p) {
	        return p.applyQuaternion(this.orientation).add(this.position);
	    }
	    transformPointInv(p) {
	        q1$1.copy(this.orientation).conjugate();
	        return p.sub(this.position).applyQuaternion(q1$1);
	    }
	    /** Updates this body's position and orientation based on its linear and angular velocities. */
	    integrate(dt) {
	        if (this.type !== RigidBodyType.Dynamic)
	            return;
	        let translation = this.linearVelocity.clone().multiplyScalar(dt);
	        let rotation = this.angularVelocity.clone().multiplyScalar(dt);
	        if (translation.lengthSq() === 0 && rotation.lengthSq() === 0) {
	            return; // No need to integrate
	        }
	        this.applyTranslation(translation);
	        this.applyRotation(rotation);
	        this.syncShapes();
	    }
	    applyTranslation(translation) {
	        this.position.add(translation);
	    }
	    applyRotation(rotation) {
	        dq.setFromAxisAngle(v1$1.copy(rotation).normalize(), rotation.length());
	        this.orientation.multiplyQuaternions(dq, this.orientation).normalize();
	    }
	    storePrevious() {
	        this.prevPosition.copy(this.position);
	        this.prevOrientation.copy(this.orientation);
	        //this.prevLinearVelocity.copy(this.linearVelocity);
	        //this.prevAngularVelocity.copy(this.angularVelocity);
	        this.prevValid = true;
	    }
	    /** Reverts this body's state to a linearly interpolated state between the current and last states. */
	    revert(t) {
	        let posEq = this.position.equals(this.prevPosition);
	        let oriEq = this.orientation.equals(this.prevOrientation);
	        if (!posEq || !oriEq) {
	            this.position.lerpVectors(this.prevPosition, this.position, t);
	            q1$1.copy(this.orientation);
	            this.orientation.copy(this.prevOrientation).slerp(q1$1, t);
	        }
	        // Don't revert the velocities
	        //this.linearVelocity.lerpVectors(this.prevLinearVelocity, this.linearVelocity, t);
	        //this.angularVelocity.lerpVectors(this.prevAngularVelocity, this.angularVelocity, t);
	        // Okay in hindsight I should have reverted the velocities. Fuck. The thing that was wrong was the marble code, not this. The marble code is wrong in that it applies movement input on every integrate, not once per tick call. Shite
	    }
	    addCollisionShape(shape) {
	        if (shape.body) {
	            throw new Error("Shape has already been added to a RigidBody.");
	        }
	        this.shapes.push(shape);
	        shape.body = this;
	        shape.updateBoundingBox();
	        if (this.type === RigidBodyType.Static) {
	            shape.mass = Infinity;
	            shape.invInertia.multiplyScalar(0);
	        }
	    }
	    removeCollisionShape(shape) {
	        if (!this.shapes.includes(shape))
	            return;
	        Util.removeFromArray(this.shapes, shape);
	        shape.body = null;
	    }
	    /** Updates this body's collision shapes' bounding boxes and position in the octree. */
	    syncShapes() {
	        for (let i = 0; i < this.shapes.length; i++) {
	            let shape = this.shapes[i];
	            shape.updateBoundingBox();
	        }
	    }
	    /** Gets the relative motion vector of this body and `b2`. */
	    getRelativeMotionVector(dst, b2) {
	        return dst.copy(this.position).sub(this.prevPosition).sub(b2.position).add(b2.prevPosition);
	    }
	    /* eslint-disable  @typescript-eslint/no-unused-vars */
	    onBeforeIntegrate(dt) { }
	    onAfterIntegrate(dt) { }
	    onBeforeCollisionResponse(t, dt) { }
	    onAfterCollisionResponse(t, dt) { }
	}

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	const _vector1 = new Vector3();
	const _vector2 = new Vector3();
	const _normalMatrix = new Matrix3();
	/** A two dimensional surface that extends infinitely in 3d space, represented in Hessian normal form by a unit length normal vector and a constant. */
	class Plane {
	    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
	        // normal is assumed to be normalized
	        this.normal = normal;
	        this.constant = constant;
	    }
	    /** Sets this plane's normal and constant properties by copying the values from the given normal. */
	    set(normal, constant) {
	        this.normal.copy(normal);
	        this.constant = constant;
	        return this;
	    }
	    /** Set the individual components that define the plane. */
	    setComponents(x, y, z, w) {
	        this.normal.set(x, y, z);
	        this.constant = w;
	        return this;
	    }
	    /** Sets the plane's properties as defined by a normal and an arbitrary coplanar point. */
	    setFromNormalAndCoplanarPoint(normal, point) {
	        this.normal.copy(normal);
	        this.constant = -point.dot(this.normal);
	        return this;
	    }
	    /** Defines the plane based on the 3 provided points. The winding order is assumed to be counter-clockwise, and determines the direction of the normal. */
	    setFromCoplanarPoints(a, b, c) {
	        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
	        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	        this.setFromNormalAndCoplanarPoint(normal, a);
	        return this;
	    }
	    /** Copies the values of the passed plane's normal and constant properties to this plane. */
	    copy(plane) {
	        this.normal.copy(plane.normal);
	        this.constant = plane.constant;
	        return this;
	    }
	    /** Normalizes the normal vector, and adjusts the constant value accordingly. */
	    normalize() {
	        // Note: will lead to a divide by zero if the plane is invalid.
	        const inverseNormalLength = 1.0 / this.normal.length();
	        this.normal.multiplyScalar(inverseNormalLength);
	        this.constant *= inverseNormalLength;
	        return this;
	    }
	    /** Negates both the normal vector and the constant. */
	    negate() {
	        this.constant *= -1;
	        this.normal.negate();
	        return this;
	    }
	    /** Returns the signed distance from the point to the plane. */
	    distanceToPoint(point) {
	        return this.normal.dot(point) + this.constant;
	    }
	    /** Projects a point onto the plane. */
	    projectPoint(point, target) {
	        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
	    }
	    /** Returns a Vector3 coplanar to the plane, by calculating the projection of the normal vector at the origin onto the plane. */
	    coplanarPoint(target) {
	        return target.copy(this.normal).multiplyScalar(-this.constant);
	    }
	    /** Apply a Matrix4 to the plane. The matrix must be an affine, homogeneous transform. */
	    applyMatrix4(matrix, optionalNormalMatrix) {
	        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
	        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
	        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
	        this.constant = -referencePoint.dot(normal);
	        return this;
	    }
	    /** Translates the plane by the distance defined by the offset vector. Note that this only affects the plane constant and will not affect the normal vector. */
	    translate(offset) {
	        this.constant -= offset.dot(this.normal);
	        return this;
	    }
	    /** Checks to see if two planes are equal (their normal and constant properties match). */
	    equals(plane) {
	        return plane.normal.equals(this.normal) && plane.constant === this.constant;
	    }
	    /** Returns a new plane with the same normal and constant as this one. */
	    clone() {
	        return new Plane().copy(this);
	    }
	}

	const INTERIOR_DEFAULT_FRICTION = 1;
	const INTERIOR_DEFAULT_RESTITUTION = 1;
	const SMOOTH_SHADING_ANGLE_THRESHOLD = Math.cos(Util.degToRad(15));
	const specialFrictionFactor = {
	    "friction_high": 1.5,
	    "friction_low": 0.2,
	    "friction_none": 0.01,
	    "friction_ramp_yellow": 2.0,
	    "grass": 1.5,
	    "mmg_grass": 0.9,
	    "tarmac": 0.35,
	    "sand": 4.0,
	    "mmg_sand": 6.0,
	    "carpet": 6.0,
	    "rug": 6.0,
	    "water": 6.0,
	    "mmg_water": 6.0,
	    "ice1": 0.03,
	    "mmg_ice": 0.03,
	    "floor_bounce": 0.2,
	    "mbp_chevron_friction": 0.0,
	    "mbp_chevron_friction2": 0.0,
	    "mbp_chevron_friction3": 0.0
	};
	const specialResistutionFactor = {
	    "friction_high": 0.5,
	    "friction_low": 0.5,
	    "friction_none": 0.5,
	    "grass": 0.35,
	    "mmg_grass": 0.5,
	    "tarmac": 0.7,
	    "sand": 0.1,
	    "mmg_sand": 0.1,
	    "carpet": 0.5,
	    "rug": 0.5,
	    "water": 0.0,
	    "mmg_water": 0.0,
	    "ice1": 0.95,
	    "mmg_ice": 0.95
	    //"floor_bounce": 0.0
	};
	const specialForces = {
	    "floor_bounce": 15
	};
	const specialMaterials = new Set([...Object.keys(specialFrictionFactor), ...Object.keys(specialResistutionFactor), ...Object.keys(specialForces)]);
	/** Creates a material with an additional normal map. */
	const createNormalMapMaterial = async (interior, baseTexture, normalTexture) => {
	    let diffuseMap = await interior.level.mission.getTexture(`interiors_mbu/${baseTexture}`);
	    let normalMap = await interior.level.mission.getTexture(`shaders/tex/${normalTexture}`);
	    let mat = new Material();
	    mat.normalMap = normalMap;
	    mat.diffuseMap = diffuseMap;
	    mat.saturateIncomingLight = false;
	    mat.receiveShadows = true;
	    mat.invertU = true;
	    return mat;
	};
	/** Creates a material with an additional normal and specularity map. */
	const createPhongMaterial = async (interior, baseTexture, specTexture, normalTexture, shininess, specularIntensity, secondaryMapUvFactor = 1, invertU = true) => {
	    let specularMap = specTexture && await interior.level.mission.getTexture(`shaders/tex/${specTexture}`);
	    let normalMap = normalTexture && await interior.level.mission.getTexture(`shaders/tex/${normalTexture}`);
	    let texture = await interior.level.mission.getTexture(`interiors_mbu/${baseTexture}`);
	    let mat = new Material();
	    mat.diffuseMap = texture;
	    mat.specularMap = specularMap;
	    mat.normalMap = normalMap;
	    mat.shininess = shininess;
	    mat.specularIntensity = specularIntensity;
	    mat.secondaryMapUvFactor = secondaryMapUvFactor;
	    mat.saturateIncomingLight = false;
	    mat.receiveShadows = true;
	    mat.invertU = invertU;
	    return mat;
	};
	/** Creates a material for a tile texture using an overlaid noise pattern. */
	const createNoiseTileMaterial = async (interior, baseTexture, noiseSuffix) => {
	    let diffuseMap = await interior.level.mission.getTexture(`interiors_mbu/${baseTexture}`);
	    let specularMap = await interior.level.mission.getTexture('shaders/tex/tile_mbu.spec.jpg');
	    let noiseMap = await interior.level.mission.getTexture(`shaders/tex/noise${noiseSuffix}.jpg`);
	    let normalMap = await interior.level.mission.getTexture('shaders/tex/tile_mbu.normal.png');
	    let mat = new Material();
	    mat.diffuseMap = diffuseMap;
	    mat.specularMap = specularMap;
	    mat.normalMap = normalMap;
	    mat.noiseMap = noiseMap;
	    mat.shininess = 40;
	    mat.specularIntensity = 0.7;
	    mat.saturateIncomingLight = false;
	    mat.receiveShadows = true;
	    mat.invertU = true;
	    return mat;
	};
	/** A list of custom materials for MBU. */
	const customMaterialFactories = {
	    'plate_1': (interior) => createPhongMaterial(interior, 'plate_1.jpg', 'plate_mbu.spec.jpg', 'plate_mbu.normal.png', 30, 0.5),
	    'tile_beginner': (interior) => createNoiseTileMaterial(interior, 'tile_beginner.png', ''),
	    'tile_beginner_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_shadow.png', ''),
	    'tile_beginner_red': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_red.jpg', ''),
	    'tile_beginner_red_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_red_shadow.png', ''),
	    'tile_beginner_blue': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_blue.jpg', ''),
	    'tile_beginner_blue_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_blue_shadow.png', ''),
	    'tile_intermediate': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate.png', ''),
	    'tile_intermediate_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_shadow.png', ''),
	    'tile_intermediate_red': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_red.jpg', ''),
	    'tile_intermediate_red_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_red_shadow.png', ''),
	    'tile_intermediate_green': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_green.jpg', ''),
	    'tile_intermediate_green_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_green_shadow.png', ''),
	    'tile_advanced': (interior) => createNoiseTileMaterial(interior, 'tile_advanced.png', ''),
	    'tile_advanced_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_shadow.png', ''),
	    'tile_advanced_blue': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_blue.jpg', ''),
	    'tile_advanced_blue_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_blue_shadow.png', ''),
	    'tile_advanced_green': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_green.jpg', ''),
	    'tile_advanced_green_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_green_shadow.png', ''),
	    'tile_underside': (interior) => createNoiseTileMaterial(interior, 'tile_underside.jpg', ''),
	    'wall_beginner': (interior) => createPhongMaterial(interior, 'wall_beginner.png', 'wall_mbu.spec.png', 'wall_mbu.normal.png', 30, 0.5),
	    'edge_white': (interior) => createPhongMaterial(interior, 'edge_white.jpg', 'edge_white_mbu.spec.jpg', 'edge_white_mbu.normal.jpg', 50, 4, 1, false),
	    'edge_white_shadow': (interior) => createPhongMaterial(interior, 'edge_white_shadow.png', 'edge_white_mbu.spec.jpg', 'edge_white_mbu.normal.jpg', 50, 4, 1, false),
	    'beam': (interior) => createNormalMapMaterial(interior, 'beam.png', 'beam_side_mbu.normal.png'),
	    'beam_side': (interior) => createNormalMapMaterial(interior, 'beam_side.png', 'beam_side_mbu.normal.png'),
	    'friction_low': (interior) => createPhongMaterial(interior, 'friction_low.jpg', null /*'friction_low_mbu.spec.png'*/, 'friction_low_mbu.normal.png', 100, 3),
	    'friction_low_shadow': (interior) => createPhongMaterial(interior, 'friction_low_shadow.png', null /*'friction_low_mbu.spec.png'*/, 'friction_low_mbu.normal.png', 100, 3),
	    'friction_high': (interior) => createPhongMaterial(interior, 'friction_high.png', 'friction_high_mbu.spec.png', 'friction_high_mbu.normal.png', 30, 0.8, 2),
	    'friction_high_shadow': (interior) => createPhongMaterial(interior, 'friction_high_shadow.png', 'friction_high_mbu.spec.png', 'friction_high_mbu.normal.png', 30, 0.8, 2)
	};
	/** Represents a Torque 3D Interior, used for the main surfaces and geometry of levels. */
	class Interior {
	    constructor(file, path, level, subObjectIndex) {
	        this.worldMatrix = new Matrix4();
	        /** Simply contains the file names of the materials without the path to them. */
	        this.materialNames = [];
	        /** Whether or not frictions and bouncy floors work on this interior. */
	        this.allowSpecialMaterials = true;
	        this.dif = file;
	        this.difPath = path;
	        this.level = level;
	        this.detailLevel = (subObjectIndex === undefined) ? file.interiors[0] : file.subObjects[subObjectIndex];
	        this.materialNames = this.detailLevel.materialList.map(x => x.split('/').pop().toLowerCase());
	        this.body = new RigidBody();
	        this.body.type = RigidBodyType.Static;
	        this.body.onAfterCollisionResponse = (t, dt) => {
	            for (let collision of this.body.collisions)
	                this.onMarbleContact(collision, dt);
	        };
	        // Combine the default special materials with the special ones specified in the .mis file
	        this.specialMaterials = new Set([...specialMaterials, ...Object.keys(this.level.mission.misFile.materialMappings)]);
	    }
	    async init(id) {
	        this.id = id;
	        await Interior.initCachePromises.get(this.detailLevel);
	        let cached = Interior.initCache.get(this.detailLevel);
	        if (cached && cached.fancyShaders !== StorageManager.data.settings.fancyShaders) {
	            // The cached interior was created with a different shader setting, so assume it's invalid
	            Interior.initCache.delete(this.detailLevel);
	            cached = null;
	        }
	        if (!cached) {
	            // There is no cached init data for this detail level yet, so go and create it, girl
	            let resolveFunc;
	            let promise = new Promise(resolve => resolveFunc = resolve);
	            Interior.initCachePromises.set(this.detailLevel, promise);
	            let materials = [];
	            for (let i = 0; i < this.detailLevel.materialList.length; i++) {
	                let texName = this.detailLevel.materialList[i].toLowerCase();
	                let fileName = texName.split('/').pop();
	                if (StorageManager.data.settings.fancyShaders && this.level.mission.modification === 'ultra' && customMaterialFactories[fileName]) {
	                    // There's a special way to create this material, prefer this instead of the normal way
	                    materials.push(await customMaterialFactories[fileName](this));
	                    continue;
	                }
	                let mat = new Material();
	                mat.receiveShadows = true;
	                materials.push(mat);
	                // Check for this special material which just makes the surface invisible (like a colmesh)
	                if (this.level.mission.modification === 'ultra' && fileName === 'tools_invisible') {
	                    mat.opacity = 0;
	                    continue;
	                }
	                let fullPath = this.difPath.includes('data/') ?
	                    this.difPath.slice(this.difPath.indexOf('data/') + 'data/'.length)
	                    : this.difPath.slice(this.difPath.indexOf('data_mbp/') + 'data_mbp/'.length);
	                const lookForTexture = async () => {
	                    let currentPath = fullPath;
	                    while (true) {
	                        // Search for the texture file inside-out, first looking in the closest directory and then searching in parent directories until it is found.
	                        currentPath = currentPath.slice(0, Math.max(0, currentPath.lastIndexOf('/')));
	                        if (!currentPath)
	                            break; // Nothing found
	                        let fullNames = this.level.mission.getFullNamesOf(currentPath + '/' + fileName);
	                        if (fullNames.length > 0) {
	                            let name = fullNames.find(x => !x.endsWith('.dif'));
	                            if (!name)
	                                break;
	                            // We found the texture file; create the texture.
	                            let texture = await this.level.mission.getTexture(currentPath + '/' + name);
	                            mat.diffuseMap = texture;
	                            break;
	                        }
	                    }
	                };
	                await lookForTexture(); // First look for the texture regularly
	                if (!mat.diffuseMap && fullPath.includes('interiors/')) {
	                    // If we didn't find the texture, try looking for it in the MBP folder.
	                    fullPath = fullPath.replace('interiors/', 'interiors_mbp/');
	                    await lookForTexture();
	                }
	            }
	            let geometry = new Geometry();
	            let vertexBuckets = new Map(); // Used for computing vertex normals by averaging face normals
	            // Add every surface
	            for (let surface of this.detailLevel.surfaces)
	                this.addSurface(geometry, surface, vertexBuckets);
	            // In order to achieve smooth shading, compute vertex normals by average face normals of faces with similar angles
	            for (let [, buckets] of vertexBuckets) {
	                for (let i = 0; i < buckets.length; i++) {
	                    let bucket = buckets[i];
	                    let avgNormal = new Vector3();
	                    // Average all vertex normals of this bucket
	                    for (let j = 0; j < bucket.normals.length; j++)
	                        avgNormal.add(bucket.normals[j]);
	                    avgNormal.multiplyScalar(1 / bucket.normals.length);
	                    // Write the normal vector into the buffers
	                    for (let j = 0; j < bucket.normalIndices.length; j++) {
	                        let arr = geometry.normals;
	                        let start = bucket.normalIndices[j];
	                        arr[start + 0] = avgNormal.x;
	                        arr[start + 1] = avgNormal.y;
	                        arr[start + 2] = avgNormal.z;
	                    }
	                }
	            }
	            cached = {
	                geometry,
	                materials,
	                fancyShaders: StorageManager.data.settings.fancyShaders
	            };
	            Interior.initCache.set(this.detailLevel, cached);
	            Interior.initCachePromises.delete(this.detailLevel);
	            resolveFunc();
	        }
	        // Create the mesh, add it to the scene, and done
	        let mesh = new Mesh(cached.geometry, cached.materials);
	        this.mesh = mesh;
	        this.level.loadingState.loaded++;
	    }
	    /** Adds one surface worth of geometry. */
	    addSurface(geometry, surface, vertexBuckets) {
	        let detailLevel = this.detailLevel;
	        let texGenEqs = detailLevel.texGenEQs[surface.texGenIndex];
	        // These are needed for UVs
	        let texPlaneX = new Plane(new Vector3(texGenEqs.planeX.x, texGenEqs.planeX.y, texGenEqs.planeX.z), texGenEqs.planeX.d);
	        let texPlaneY = new Plane(new Vector3(texGenEqs.planeY.x, texGenEqs.planeY.y, texGenEqs.planeY.z), texGenEqs.planeY.d);
	        let planeData = detailLevel.planes[surface.planeIndex];
	        let planeNormal = detailLevel.normals[planeData.normalIndex];
	        //let geometryData = this.materialGeometry[surface.textureIndex];
	        let material = this.materialNames[surface.textureIndex];
	        let k = 0; // Keep track of the face's index for corrent vertex winding order.
	        for (let i = surface.windingStart; i < surface.windingStart + surface.windingCount - 2; i++) {
	            let i1 = this.detailLevel.windings[i];
	            let i2 = this.detailLevel.windings[i + 1];
	            let i3 = this.detailLevel.windings[i + 2];
	            if (k % 2 === 0) {
	                // Swap the first and last index to maintain correct winding order
	                let temp = i1;
	                i1 = i3;
	                i3 = temp;
	            }
	            let faceNormal = new Vector3(planeNormal.x, planeNormal.y, planeNormal.z);
	            if (surface.planeFlipped)
	                faceNormal.negate();
	            for (let index of [i1, i2, i3]) {
	                let position = this.detailLevel.points[index];
	                // Figure out UV coordinates by getting the distances of the corresponding vertices to the plane.
	                let u = texPlaneX.distanceToPoint(new Vector3(position.x, position.y, position.z));
	                let v = texPlaneY.distanceToPoint(new Vector3(position.x, position.y, position.z));
	                if (this.level.mission.modification === 'ultra' && material === 'plate_1')
	                    u /= 2, v /= 2; // This one texture gets scaled up by 2x probably in the shader, but to avoid writing a separate shader we do it here.
	                geometry.positions.push(position.x, position.y, position.z);
	                geometry.normals.push(0, 0, 0); // Push a placeholder, we'll compute a proper normal later
	                geometry.uvs.push(u, v);
	                geometry.materials.push(surface.textureIndex);
	                geometry.indices.push(geometry.indices.length);
	                // Find the buckets for this vertex
	                let buckets = vertexBuckets.get(position);
	                if (!buckets) {
	                    // Create a new list of buckets if necessary
	                    buckets = [];
	                    vertexBuckets.set(position, buckets);
	                }
	                // Find the bucket for this vertex
	                let bucket;
	                for (let j = 0; j < buckets.length; j++) {
	                    bucket = buckets[j];
	                    // Check if the reference normal and current face normal point in roughly the same direction; in that case, use that bucket.
	                    if (faceNormal.dot(bucket.referenceNormal) > SMOOTH_SHADING_ANGLE_THRESHOLD)
	                        break;
	                    bucket = null;
	                }
	                if (!bucket) {
	                    // Create a new bucket if necessary
	                    bucket = {
	                        referenceNormal: faceNormal,
	                        normalIndices: [],
	                        normals: []
	                    };
	                    buckets.push(bucket);
	                }
	                // Add data
	                bucket.normalIndices.push(geometry.normals.length - 3);
	                bucket.normals.push(faceNormal);
	            }
	            k++;
	        }
	    }
	    addConvexHull(hullIndex, scale) {
	        let hull = this.detailLevel.convexHulls[hullIndex];
	        let materials = new Set();
	        // Add all materials
	        for (let j = hull.surfaceStart; j < hull.surfaceStart + hull.surfaceCount; j++) {
	            let surface = this.detailLevel.surfaces[this.detailLevel.hullSurfaceIndices[j]];
	            if (!surface)
	                continue;
	            let material = this.materialNames[surface.textureIndex];
	            if (!material)
	                continue;
	            if (!this.specialMaterials.has(material))
	                material = ''; // Not a special material, we can group them as one
	            materials.add(material);
	        }
	        if (materials.size === 0)
	            return;
	        let vertices = [];
	        // Get the vertices
	        for (let j = hull.hullStart; j < hull.hullStart + hull.hullCount; j++) {
	            let point = this.detailLevel.points[this.detailLevel.hullIndices[j]];
	            vertices.push(new Vector3(point.x * scale.x, point.y * scale.y, point.z * scale.z));
	        }
	        let shape = new ConvexHullCollisionShape(vertices);
	        if (materials.size === 1) {
	            let material = materials.values().next().value;
	            let properties = this.getCollisionMaterialProperties(material);
	            shape.friction = properties.friction;
	            shape.restitution = properties.restitution;
	            shape.userData = properties;
	        }
	        else {
	            for (let j = hull.surfaceStart; j < hull.surfaceStart + hull.surfaceCount; j++) {
	                let surface = this.detailLevel.surfaces[this.detailLevel.hullSurfaceIndices[j]];
	                if (!surface)
	                    continue;
	                let material = this.materialNames[surface.textureIndex];
	                if (!material)
	                    continue;
	                let planeData = this.detailLevel.planes[surface.planeIndex];
	                let planeNormal = this.detailLevel.normals[planeData.normalIndex];
	                let faceNormal = new Vector3(planeNormal.x, planeNormal.y, planeNormal.z);
	                if (surface.planeFlipped)
	                    faceNormal.negate();
	                let properties = this.getCollisionMaterialProperties(material);
	                shape.materialOverrides.set(faceNormal, properties);
	            }
	        }
	        this.body.addCollisionShape(shape);
	    }
	    getCollisionMaterialProperties(material) {
	        var _a, _b, _c, _d, _e;
	        let friction = INTERIOR_DEFAULT_RESTITUTION;
	        let restitution = INTERIOR_DEFAULT_RESTITUTION;
	        let force;
	        let isRandom = false;
	        if (this.allowSpecialMaterials) {
	            // Check for a custom material property override in the mission file
	            let specialMatProperties = this.level.mission.misFile.materialProperties[this.level.mission.misFile.materialMappings[material]];
	            let frictionFac = (_b = (_a = specialMatProperties === null || specialMatProperties === void 0 ? void 0 : specialMatProperties['friction']) !== null && _a !== void 0 ? _a : specialFrictionFactor[material]) !== null && _b !== void 0 ? _b : 1;
	            let restitutionFac = (_d = (_c = specialMatProperties === null || specialMatProperties === void 0 ? void 0 : specialMatProperties['restitution']) !== null && _c !== void 0 ? _c : specialResistutionFactor[material]) !== null && _d !== void 0 ? _d : 1;
	            force = (_e = specialMatProperties === null || specialMatProperties === void 0 ? void 0 : specialMatProperties['force']) !== null && _e !== void 0 ? _e : specialForces[material];
	            if (force !== undefined)
	                restitutionFac = 1; // Because we don't want anything to act weird
	            restitution *= restitutionFac;
	            friction *= frictionFac;
	        }
	        if (this.allowSpecialMaterials && (material === null || material === void 0 ? void 0 : material.startsWith('mbp_chevron_friction')))
	            isRandom = true;
	        return { friction, restitution, force, isRandom };
	    }
	    setTransform(position, orientation, scale) {
	        this.worldMatrix.compose(position, orientation, scale);
	        this.scale = scale;
	        this.mesh.transform.copy(this.worldMatrix);
	        this.body.position.copy(position);
	        this.body.orientation.copy(orientation);
	        for (let i = 0; i < this.detailLevel.convexHulls.length; i++)
	            this.addConvexHull(i, this.scale);
	    }
	    onMarbleContact(collision, dt) {
	        let contactShape = collision.s2;
	        let marble = this.level.marble;
	        let materialProperties = (contactShape.userData || contactShape.materialOverrides.get(collision.s2MaterialOverride));
	        if (materialProperties.force !== undefined) {
	            // Set the velocity along the contact normal, but make sure it's capped
	            marble.setLinearVelocityInDirection(collision.normal, materialProperties.force, false);
	            marble.slidingTimeout = 2; // Make sure we don't slide on the interior after bouncing off it
	        }
	        else if (materialProperties.isRandom) {
	            let fac = dt / (1 / PHYSICS_TICK_RATE);
	            let angVel = marble.body.angularVelocity.clone();
	            let movementVec = angVel.cross(collision.normal);
	            // Move the marble in the opposite direction
	            marble.body.linearVelocity.addScaledVector(movementVec, -0.0015 * fac);
	            marble.body.angularVelocity.multiplyScalar(1 + (0.07 * marble.speedFac * fac));
	        }
	    }
	    /* eslint-disable @typescript-eslint/no-unused-vars */
	    tick(time) { }
	    render(time) { }
	    reset() { }
	    async onLevelStart() { }
	}
	/** Avoids recomputation of the same interior. */
	Interior.initCache = new WeakMap();
	Interior.initCachePromises = new WeakMap();

	/** A parser for .ifl files, used to describe an animated sequence of materials. */
	class IflParser {
	    constructor(text) {
	        this.text = text;
	    }
	    parse() {
	        let lines = this.text.split('\n');
	        let keyframes = [];
	        for (let line of lines) {
	            line = line.trim();
	            if (line.startsWith('//'))
	                continue;
	            if (!line)
	                continue;
	            let parts = line.split(' ');
	            let count = parts[1] ? Number(parts[1]) : 1; // If no count is listed, is appears for exactly one keyframe.
	            for (let i = 0; i < count; i++) {
	                keyframes.push(parts[0]);
	            }
	        }
	        return keyframes;
	    }
	    /** Loads and parses an .ifl file. Returns a cached version if already loaded. */
	    static async loadFile(path) {
	        if (this.cachedFiles.get(path))
	            return this.cachedFiles.get(path);
	        let blob = await ResourceManager.loadResource(path);
	        let text = await ResourceManager.readBlobAsText(blob);
	        let parser = new IflParser(text);
	        let result = parser.parse();
	        this.cachedFiles.set(path, result);
	        return result;
	    }
	}
	IflParser.cachedFiles = new Map();

	/** A group represents a collection of 3D objects. */
	class Group extends Object3D {
	    constructor() {
	        super(...arguments);
	        this.children = [];
	    }
	    add(child) {
	        if (child.parent)
	            child.parent.remove(child); // No weird double parent action
	        this.children.push(child);
	        child.parent = this;
	    }
	    remove(child) {
	        Util.removeFromArray(this.children, child);
	        child.parent = null;
	    }
	    updateWorldTransform() {
	        if (!this.needsWorldTransformUpdate)
	            return;
	        super.updateWorldTransform();
	        // Update the world transforms of all descendants
	        for (let child of this.children) {
	            if (child.needsWorldTransformUpdate)
	                child.updateWorldTransform();
	        }
	    }
	    changedTransform() {
	        super.changedTransform();
	        for (let child of this.children)
	            child.changedTransform();
	    }
	    /** Traverses this group and all its descendants and calls the callback on each non-group. */
	    traverse(fn) {
	        fn(this);
	        for (let child of this.children) {
	            if (child instanceof Group)
	                child.traverse(fn);
	            else
	                fn(child);
	        }
	    }
	    /** Recursively sets the opacity of all objects in this group's subtree. */
	    setOpacity(value) {
	        for (let child of this.children) {
	            if (child instanceof Group)
	                child.setOpacity(value);
	            else
	                child.opacity = value;
	        }
	    }
	}

	/** A hardcoded list of shapes that should only use envmaps as textures. */
	const DROP_TEXTURE_FOR_ENV_MAP = new Set(['shapes/items/superjump.dts', 'shapes/items/antigravity.dts']);
	var MaterialFlags;
	(function (MaterialFlags) {
	    MaterialFlags[MaterialFlags["S_Wrap"] = 1] = "S_Wrap";
	    MaterialFlags[MaterialFlags["T_Wrap"] = 2] = "T_Wrap";
	    MaterialFlags[MaterialFlags["Translucent"] = 4] = "Translucent";
	    MaterialFlags[MaterialFlags["Additive"] = 8] = "Additive";
	    MaterialFlags[MaterialFlags["Subtractive"] = 16] = "Subtractive";
	    MaterialFlags[MaterialFlags["SelfIlluminating"] = 32] = "SelfIlluminating";
	    MaterialFlags[MaterialFlags["NeverEnvMap"] = 64] = "NeverEnvMap";
	    MaterialFlags[MaterialFlags["NoMipMap"] = 128] = "NoMipMap";
	    MaterialFlags[MaterialFlags["MipMap_ZeroBorder"] = 256] = "MipMap_ZeroBorder";
	    MaterialFlags[MaterialFlags["IflMaterial"] = 134217728] = "IflMaterial";
	    MaterialFlags[MaterialFlags["IflFrame"] = 268435456] = "IflFrame";
	    MaterialFlags[MaterialFlags["DetailMapOnly"] = 536870912] = "DetailMapOnly";
	    MaterialFlags[MaterialFlags["BumpMapOnly"] = 1073741824] = "BumpMapOnly";
	    MaterialFlags[MaterialFlags["ReflectanceMapOnly"] = -2147483648] = "ReflectanceMapOnly";
	})(MaterialFlags || (MaterialFlags = {}));
	var TSDrawPrimitive;
	(function (TSDrawPrimitive) {
	    TSDrawPrimitive[TSDrawPrimitive["Triangles"] = 0] = "Triangles";
	    TSDrawPrimitive[TSDrawPrimitive["Strip"] = 1073741824] = "Strip";
	    TSDrawPrimitive[TSDrawPrimitive["Fan"] = -2147483648] = "Fan";
	    TSDrawPrimitive[TSDrawPrimitive["Indexed"] = 536870912] = "Indexed";
	    TSDrawPrimitive[TSDrawPrimitive["NoMaterial"] = 268435456] = "NoMaterial";
	    TSDrawPrimitive[TSDrawPrimitive["MaterialMask"] = 268435455] = "MaterialMask";
	    TSDrawPrimitive[TSDrawPrimitive["TypeMask"] = -1073741824] = "TypeMask";
	})(TSDrawPrimitive || (TSDrawPrimitive = {}));
	/** Represents an object created from a DTS file. This is either a static object like the start pad or a sign, or an item like gems or powerups. */
	class Shape {
	    constructor() {
	        /** Whether or not this shape is being used as a TSStatic. TSStatic are static, non-moving shapes that basically can't do anything. */
	        this.isTSStatic = false;
	        this.hasBeenRendered = false;
	        this.meshes = [];
	        /** Whether the marble can physically collide with this shape. */
	        this.collideable = true;
	        /** Not physical colliders, but a list bodies that overlap is checked with. This is used for things like force fields. */
	        this.colliders = [];
	        /** For each shape, the untransformed vertices of their convex hull geometry. */
	        this.shapeVertices = new Map();
	        this.isCurrentlyColliding = false;
	        this.worldPosition = new Vector3();
	        this.worldOrientation = new Quaternion();
	        this.worldScale = new Vector3();
	        this.worldMatrix = new Matrix4();
	        /** Can be used to override certain material names. */
	        this.matNamesOverride = {};
	        this.castShadows = false;
	        /** Stores only the roots of the tree (no parent). */
	        this.rootGraphNodes = [];
	        /** One transformation matrix per DTS node */
	        this.nodeTransforms = [];
	        this.showSequences = true;
	        /** If the element has non-visual sequences, then these should be updated every simulation tick as well. */
	        this.hasNonVisualSequences = false;
	        /** Can be used to override the current keyframe of a sequence. */
	        this.sequenceKeyframeOverride = new WeakMap();
	        /** Stores the last-used keyframe of a sequence to reduce computational load. */
	        this.lastSequenceKeyframes = new WeakMap();
	        this.currentOpacity = 1;
	        this.restitution = INTERIOR_DEFAULT_RESTITUTION;
	        this.friction = INTERIOR_DEFAULT_FRICTION;
	        /** Whether or not to continuously spin. */
	        this.ambientRotate = false;
	        this.ambientSpinFactor = -1 / 3000 * Math.PI * 2;
	        /** Whether or not collision meshes will receive shadows. */
	        this.receiveShadows = true;
	        this.materialPostprocessor = null;
	        /** Same shapes with a different shareId cannot share data. */
	        this.shareId = 0;
	        /** Whether or not to share the same node transforms with other shapes of the same type. */
	        this.shareNodeTransforms = true;
	        /** Whether or not to share the same materials with other shapes of the same type. */
	        this.shareMaterials = true;
	        /** A shape is a master if it was the first shape to run init() amongst those that share data with it. */
	        this.isMaster = false;
	        this.sounds = [];
	    }
	    /** Shapes with identical share hash can share data. */
	    getShareHash() {
	        return this.dtsPath + ' ' + this.constructor.name + ' ' + this.shareId;
	    }
	    async init(level, srcElement = null) {
	        var _a, _b, _c;
	        this.id = (_a = srcElement === null || srcElement === void 0 ? void 0 : srcElement._id) !== null && _a !== void 0 ? _a : 0;
	        this.level = level;
	        this.srcElement = srcElement;
	        (_b = this.colliderDtsPath) !== null && _b !== void 0 ? _b : (this.colliderDtsPath = this.dtsPath);
	        this.dts = await ((this.level) ? this.level.mission.getDts(this.dtsPath) : DtsParser.loadFile(ResourceManager.mainDataPath + this.dtsPath));
	        this.colliderDts = (this.dtsPath === this.colliderDtsPath) ? this.dts : await ((this.level) ? this.level.mission.getDts(this.colliderDtsPath) : DtsParser.loadFile(ResourceManager.mainDataPath + this.colliderDtsPath));
	        this.directoryPath = this.dtsPath.slice(0, this.dtsPath.lastIndexOf('/'));
	        this.group = new Group();
	        this.bodies = [];
	        this.materials = [];
	        this.materialInfo = new WeakMap();
	        // Check if there's already shared data from another shape of the same type
	        let sharedDataPromise = (_c = this.level) === null || _c === void 0 ? void 0 : _c.sharedShapeData.get(this.getShareHash());
	        let sharedData;
	        if (sharedDataPromise) {
	            // If so, (maybe) wait for that data to complete initiation (might already be done)
	            sharedData = await sharedDataPromise;
	        }
	        else {
	            // If we're here, we're the first shape of this type, so let's prepare the shared data
	            let resolveFunc;
	            if (this.level) {
	                sharedDataPromise = new Promise((resolve) => resolveFunc = resolve);
	                this.level.sharedShapeData.set(this.getShareHash(), sharedDataPromise);
	            }
	            for (let i = 0; i < this.dts.nodes.length; i++)
	                this.nodeTransforms.push(new Matrix4());
	            await this.computeMaterials();
	            // Build the node tree
	            let graphNodes = [];
	            for (let i = 0; i < this.dts.nodes.length; i++) {
	                let graphNode = {
	                    index: i,
	                    node: this.dts.nodes[i],
	                    children: [],
	                    parent: null
	                };
	                graphNodes.push(graphNode);
	            }
	            for (let i = 0; i < this.dts.nodes.length; i++) {
	                let node = this.dts.nodes[i];
	                if (node.parentIndex !== -1) {
	                    graphNodes[i].parent = graphNodes[node.parentIndex];
	                    graphNodes[node.parentIndex].children.push(graphNodes[i]);
	                }
	            }
	            this.graphNodes = graphNodes;
	            this.rootGraphNodes = graphNodes.filter((node) => !node.parent);
	            this.updateNodeTransforms();
	            let geometries = [];
	            let geometryMatrixIndices = []; // The index into nodeTransforms
	            let collisionGeometries = new Set();
	            // Go through all nodes and objects and create the geometry
	            for (let i = 0; i < this.dts.nodes.length; i++) {
	                let objects = this.dts.objects.filter((object) => object.nodeIndex === i);
	                for (let object of objects) {
	                    // Torque requires collision objects to start with "Col", so we use that here
	                    let isCollisionObject = this.dts.names[object.nameIndex].toLowerCase().startsWith("col");
	                    if (!isCollisionObject || this.collideable) {
	                        for (let j = object.startMeshIndex; j < object.startMeshIndex + object.numMeshes; j++) {
	                            let mesh = this.dts.meshes[j];
	                            if (!mesh)
	                                continue;
	                            if (mesh.parentMesh >= 0)
	                                continue; // If the node has a parent, skip it. Why? Don't know. Made teleport pad look correct.
	                            if (mesh.verts.length === 0)
	                                continue; // No need
	                            // The reason we precompute position/normal here is because skinned meshes need vector instances they can modify each frame.
	                            let vertices = mesh.verts.map((v) => new Vector3(v.x, v.y, v.z));
	                            let vertexNormals = mesh.norms.map((v) => new Vector3(v.x, v.y, v.z));
	                            let geometry = this.generateGeometryFromMesh(mesh, vertices, vertexNormals);
	                            geometries.push(geometry);
	                            geometryMatrixIndices.push(i);
	                            // Flag it
	                            if (isCollisionObject)
	                                collisionGeometries.add(geometry);
	                        }
	                    }
	                }
	            }
	            // Search for a skinned mesh (only in use for the tornado)
	            let skinnedMeshIndex = null;
	            for (let i = 0; i < this.dts.meshes.length; i++) {
	                let dtsMesh = this.dts.meshes[i];
	                if (!dtsMesh || dtsMesh.type !== MeshType.Skin)
	                    continue;
	                // Create arrays of zero vectors as they will get changed later anyway
	                let vertices = new Array(dtsMesh.verts.length).fill(null).map(() => new Vector3());
	                let vertexNormals = new Array(dtsMesh.norms.length).fill(null).map(() => new Vector3());
	                let geometry = this.generateGeometryFromMesh(dtsMesh, vertices, vertexNormals);
	                geometries.push(geometry); // Even though the mesh is animated, it doesn't count as dynamic because it's not part of any node and therefore cannot follow its transforms.
	                geometryMatrixIndices.push(null);
	                skinnedMeshIndex = i;
	                break; // This is technically not correct. A shape could have many skinned meshes, but the tornado only has one, so we gucci.
	            }
	            sharedData = {
	                materials: this.materials,
	                rootGraphNodes: this.rootGraphNodes,
	                nodeTransforms: this.nodeTransforms,
	                geometries,
	                geometryMatrixIndices,
	                collisionGeometries,
	                skinnedMeshIndex
	            };
	            this.isMaster = true;
	            resolveFunc === null || resolveFunc === void 0 ? void 0 : resolveFunc(sharedData);
	        }
	        if (!this.isMaster) {
	            // Copy some data from the shared data
	            this.nodeTransforms = sharedData.nodeTransforms;
	            if (!this.shareNodeTransforms)
	                this.nodeTransforms = this.nodeTransforms.map(x => x.clone());
	            if (this.shareMaterials)
	                this.materials = sharedData.materials;
	            else
	                await this.computeMaterials();
	            this.rootGraphNodes = sharedData.rootGraphNodes; // The node graph is necessarily identical
	        }
	        // Create the meshes for all geometries
	        for (let [i, geometry] of sharedData.geometries.entries()) {
	            let materials = this.materials;
	            if (sharedData.collisionGeometries.has(geometry)) {
	                // Create a special material that just receives shadows
	                let shadowMaterial = new Material();
	                shadowMaterial.isShadow = true;
	                shadowMaterial.transparent = true;
	                shadowMaterial.depthWrite = false;
	                materials = [shadowMaterial];
	                geometry.materials.fill(0);
	            }
	            let mesh = new Mesh(geometry, materials);
	            let transform = this.nodeTransforms[sharedData.geometryMatrixIndices[i]];
	            if (transform)
	                mesh.transform = transform;
	            if (this.castShadows)
	                mesh.castShadows = true;
	            this.group.add(mesh);
	            this.meshes.push(mesh);
	            if (sharedData.skinnedMeshIndex !== null && !this.skinMeshInfo) {
	                // Will be used for animating the skin later
	                this.skinMeshInfo = {
	                    meshIndex: sharedData.skinnedMeshIndex,
	                    vertices: this.dts.meshes[sharedData.skinnedMeshIndex].verts.map(_ => new Vector3()),
	                    normals: this.dts.meshes[sharedData.skinnedMeshIndex].norms.map(_ => new Vector3()),
	                    mesh: mesh
	                };
	            }
	        }
	        // Now, create an actual collision body for each collision object (will be initiated with geometry later)
	        for (let i = 0; i < this.colliderDts.nodes.length; i++) {
	            let objects = this.colliderDts.objects.filter((object) => object.nodeIndex === i);
	            for (let object of objects) {
	                let isCollisionObject = this.colliderDts.names[object.nameIndex].toLowerCase().startsWith("col");
	                if (isCollisionObject) {
	                    let body = new RigidBody();
	                    body.type = RigidBodyType.Static;
	                    body.userData = { nodeIndex: i };
	                    this.bodies.push(body);
	                }
	            }
	        }
	        // If there are no collision objects, add a single body which will later be filled with bounding box geometry.
	        if (this.bodies.length === 0 && !this.isTSStatic) {
	            let body = new RigidBody();
	            body.type = RigidBodyType.Static;
	            this.bodies.push(body);
	        }
	        // Init collision handlers
	        for (let body of this.bodies) {
	            body.onBeforeIntegrate = () => {
	                if (this.isCurrentlyColliding && body.collisions.length === 0) {
	                    this.isCurrentlyColliding = false;
	                    this.onMarbleLeave();
	                }
	            };
	            body.onBeforeCollisionResponse = (t) => {
	                if (!this.isCurrentlyColliding)
	                    this.onMarbleEnter(t);
	                this.onMarbleInside(t);
	                this.isCurrentlyColliding = true;
	            };
	            body.onAfterCollisionResponse = () => {
	                let chosenCollision = body.collisions[0]; // Just pick the first one, for now. There's not really a better way of choosing which one to pick, right?
	                this.onMarbleContact(chosenCollision);
	            };
	        }
	        // Preload all sounds
	        await (level === null || level === void 0 ? void 0 : level.audio.loadBuffers(this.sounds));
	        if (this.level)
	            this.level.loadingState.loaded++;
	    }
	    /** Creates the materials for this shape. */
	    async computeMaterials() {
	        var _a;
	        let environmentMaterial = null;
	        for (let i = 0; i < this.dts.matNames.length; i++) {
	            let matName = this.matNamesOverride[this.dts.matNames[i]] || this.dts.matNames[i]; // Check the override
	            let flags = this.dts.matFlags[i];
	            let fullNames = ResourceManager.getFullNamesOf(this.directoryPath + '/' + matName).filter((x) => !x.endsWith('.dts'));
	            let fullName = fullNames.find(x => x.endsWith('.ifl')) || fullNames[0]; // Prefer .ifls
	            if (this.isTSStatic && environmentMaterial && DROP_TEXTURE_FOR_ENV_MAP.has(this.dtsPath)) {
	                // Simply use the env material again
	                this.materials.push(environmentMaterial);
	                continue;
	            }
	            let material = new Material();
	            if ((flags & MaterialFlags.SelfIlluminating) || environmentMaterial)
	                material.emissive = true;
	            this.materials.push(material);
	            if (matName instanceof Texture) {
	                material.diffuseMap = matName;
	            }
	            else if (!fullName || (this.isTSStatic && (flags & MaterialFlags.ReflectanceMapOnly))) {
	                // Usually do nothing. It's an plain white material without a texture.
	                // Ah EXCEPT if we're a TSStatic.
	                if (this.isTSStatic) {
	                    material.emissive = true;
	                    if (flags & MaterialFlags.ReflectanceMapOnly)
	                        environmentMaterial = material;
	                }
	            }
	            else if (fullName.endsWith('.ifl')) {
	                // Parse the .ifl file
	                let keyframes = await IflParser.loadFile(ResourceManager.mainDataPath + this.directoryPath + '/' + fullName);
	                let fullNameCache = new Map(); // To speed things up a bit for repeated entries
	                keyframes = keyframes.map(x => {
	                    var _a;
	                    if (fullNameCache.has(x))
	                        return fullNameCache.get(x);
	                    let fullName = (_a = ResourceManager.getFullNamesOf(this.directoryPath + '/' + x).filter((x) => !x.endsWith('.dts'))[0]) !== null && _a !== void 0 ? _a : x;
	                    fullNameCache.set(x, fullName);
	                    return fullName;
	                });
	                this.materialInfo.set(material, { keyframes });
	                // Preload all frames of the material animation
	                let promises = [];
	                for (let frame of new Set(keyframes)) {
	                    promises.push(ResourceManager.getTexture(this.directoryPath + '/' + frame));
	                }
	                let textures = await Promise.all(promises);
	                material.diffuseMap = textures[0]; // So that we compile the material in the right type of shader
	                material.differentiator = this.isTSStatic + ResourceManager.mainDataPath + this.directoryPath + '/' + fullName;
	            }
	            else {
	                let texture = await ResourceManager.getTexture(this.directoryPath + '/' + fullName);
	                material.diffuseMap = texture;
	            }
	            // Set some properties based on the flags
	            if (flags & MaterialFlags.Translucent) {
	                material.transparent = true;
	                material.depthWrite = false;
	            }
	            if (flags & MaterialFlags.Additive)
	                material.blending = BlendingType.Additive;
	            if (flags & MaterialFlags.Subtractive)
	                material.blending = BlendingType.Subtractve;
	            if (this.isTSStatic && !(flags & MaterialFlags.NeverEnvMap)) {
	                material.reflectivity = this.dts.matNames.length === 1 ? 1 : environmentMaterial ? 0.5 : 0.333;
	                material.envMap = this.level.envMap;
	            }
	            (_a = this.materialPostprocessor) === null || _a === void 0 ? void 0 : _a.call(this, material);
	        }
	        // If there are no materials, atleast add one environment one
	        if (this.materials.length === 0) {
	            let mat = new Material();
	            mat.emissive = true;
	            mat.envMap = this.level.envMap;
	            mat.reflectivity = 1;
	            this.materials.push(mat);
	        }
	    }
	    /** Generates geometry info from a given DTS mesh. */
	    generateGeometryFromMesh(dtsMesh, vertices, vertexNormals) {
	        let geometry = new Geometry();
	        for (let i = 0; i < vertices.length; i++) {
	            let vertex = vertices[i];
	            let uv = dtsMesh.tverts[i];
	            let normal = vertexNormals[i];
	            geometry.positions.push(vertex.x, vertex.y, vertex.z);
	            geometry.normals.push(normal.x, normal.y, normal.z);
	            geometry.uvs.push(uv.x, uv.y);
	        }
	        let ab = new Vector3();
	        let ac = new Vector3();
	        const addTriangleFromIndices = (i1, i2, i3, materialIndex) => {
	            // We first perform a check: If the computed face normal points in the opposite direction of all vertex normals, we need to invert the winding order of the vertices.
	            ab.set(vertices[i2].x - vertices[i1].x, vertices[i2].y - vertices[i1].y, vertices[i2].z - vertices[i1].z);
	            ac.set(vertices[i3].x - vertices[i1].x, vertices[i3].y - vertices[i1].y, vertices[i3].z - vertices[i1].z);
	            let normal = ab.cross(ac).normalize();
	            let dot1 = normal.dot(vertexNormals[i1]);
	            let dot2 = normal.dot(vertexNormals[i2]);
	            let dot3 = normal.dot(vertexNormals[i3]);
	            if (!this.dtsPath.includes('helicopter.dts'))
	                if (dot1 < 0 && dot2 < 0 && dot3 < 0)
	                    [i1, i3] = [i3, i1];
	            // ^ temp hardcoded fix
	            geometry.indices.push(i1, i2, i3);
	            geometry.materials.push(materialIndex, materialIndex, materialIndex);
	        };
	        for (let primitive of dtsMesh.primitives) {
	            let materialIndex = primitive.matIndex & TSDrawPrimitive.MaterialMask;
	            let drawType = primitive.matIndex & TSDrawPrimitive.TypeMask;
	            if (drawType === TSDrawPrimitive.Triangles) {
	                for (let i = primitive.start; i < primitive.start + primitive.numElements; i += 3) {
	                    let i1 = dtsMesh.indices[i];
	                    let i2 = dtsMesh.indices[i + 1];
	                    let i3 = dtsMesh.indices[i + 2];
	                    addTriangleFromIndices(i1, i2, i3, materialIndex);
	                }
	            }
	            else if (drawType === TSDrawPrimitive.Strip) {
	                let k = 0; // Keep track of current face for correct vertex winding order
	                for (let i = primitive.start; i < primitive.start + primitive.numElements - 2; i++) {
	                    let i1 = dtsMesh.indices[i];
	                    let i2 = dtsMesh.indices[i + 1];
	                    let i3 = dtsMesh.indices[i + 2];
	                    if (k % 2 === 0) {
	                        // Swap the first and last index to maintain correct winding order
	                        let temp = i1;
	                        i1 = i3;
	                        i3 = temp;
	                    }
	                    addTriangleFromIndices(i1, i2, i3, materialIndex);
	                    k++;
	                }
	            }
	            else if (drawType === TSDrawPrimitive.Fan) {
	                for (let i = primitive.start; i < primitive.start + primitive.numElements - 2; i++) {
	                    let i1 = dtsMesh.indices[primitive.start]; // Triangle fan starts at the start
	                    let i2 = dtsMesh.indices[i + 1];
	                    let i3 = dtsMesh.indices[i + 2];
	                    addTriangleFromIndices(i1, i2, i3, materialIndex);
	                }
	            }
	        }
	        return geometry;
	    }
	    /** Generates collision objects for this shape. Geometry will be generated later. */
	    generateCollisionObjects() {
	        let bodyIndex = 0;
	        let dts = this.colliderDts;
	        for (let i = 0; i < dts.nodes.length; i++) {
	            let objects = dts.objects.filter((object) => object.nodeIndex === i);
	            for (let object of objects) {
	                if (!dts.names[object.nameIndex].toLowerCase().startsWith("col"))
	                    continue;
	                let body = this.bodies[bodyIndex];
	                bodyIndex++;
	                for (let j = object.startMeshIndex; j < object.startMeshIndex + object.numMeshes; j++) {
	                    let mesh = dts.meshes[j];
	                    if (!mesh)
	                        continue;
	                    for (let primitive of mesh.primitives) {
	                        // Create the collision shape but with all zero vectors for now
	                        let shape = new ConvexHullCollisionShape(Array(primitive.numElements).fill(null).map(_ => new Vector3()));
	                        shape.restitution = this.restitution;
	                        shape.friction = this.friction;
	                        if (!this.collideable)
	                            shape.collisionDetectionMask = 0b10; // Collide with the big aux marble
	                        body.addCollisionShape(shape);
	                        // Remember the actual untransformed vertices for this geometry
	                        let vertices = mesh.indices.slice(primitive.start, primitive.start + primitive.numElements)
	                            .map((index) => mesh.verts[index])
	                            .map((vert) => new Vector3(vert.x, vert.y, vert.z));
	                        this.shapeVertices.set(shape, vertices);
	                    }
	                }
	            }
	        }
	        if (bodyIndex === 0 && !this.isTSStatic) {
	            // Create collision geometry based on the bounding box
	            let body = this.bodies[0];
	            let bounds = new Box3();
	            bounds.min.set(dts.bounds.min.x, dts.bounds.min.y, dts.bounds.min.z);
	            bounds.max.set(dts.bounds.max.x, dts.bounds.max.y, dts.bounds.max.z);
	            // Create an empty collision shape for now
	            let shape = new ConvexHullCollisionShape(Array(8).fill(null).map(_ => new Vector3()));
	            shape.restitution = this.restitution;
	            shape.friction = this.friction;
	            if (!this.collideable)
	                shape.collisionDetectionMask = 0b10; // Collide with the big aux marble
	            body.addCollisionShape(shape);
	            // All 8 vertices of the bounding cuboid
	            let vertices = Util.getBoxVertices(bounds);
	            this.shapeVertices.set(shape, vertices);
	        }
	    }
	    /** Recursively updates node transformations in the node tree.
	     * @param quaternions One quaternion for each node.
	     * @param translations One translation for each node.
	     * @param scales One scale for each node.
	     * @param bitfield Specifies which nodes have changed.
	     */
	    updateNodeTransforms(quaternions, translations, scales, bitfield = 0xffffffff) {
	        if (!quaternions) {
	            // Create the default array of quaternions
	            quaternions = this.dts.nodes.map((node, index) => {
	                let rotation = this.dts.defaultRotations[index];
	                let quaternion = new Quaternion(rotation.x, rotation.y, rotation.z, rotation.w);
	                quaternion.normalize();
	                quaternion.conjugate();
	                return quaternion;
	            });
	        }
	        if (!translations) {
	            // Create the default array of translations
	            translations = this.dts.nodes.map((node, index) => {
	                let translation = this.dts.defaultTranslations[index];
	                return new Vector3(translation.x, translation.y, translation.z);
	            });
	        }
	        if (!scales) {
	            // Create the default array of scales
	            scales = this.dts.nodes.map(() => {
	                return new Vector3().setScalar(1);
	            });
	        }
	        let utilityMatrix = new Matrix4();
	        const traverse = (node, needsUpdate) => {
	            if (((1 << node.index) & bitfield) !== 0)
	                needsUpdate = true;
	            if (needsUpdate) {
	                // Recompute the matrix
	                let mat = this.nodeTransforms[node.index];
	                if (!node.parent) {
	                    mat.identity();
	                }
	                else {
	                    mat.copy(this.nodeTransforms[node.parent.index]);
	                }
	                utilityMatrix.compose(translations[node.index], quaternions[node.index], scales[node.index]);
	                mat.multiplyMatrices(mat, utilityMatrix);
	            }
	            // Call all children
	            for (let i = 0; i < node.children.length; i++)
	                traverse(node.children[i], needsUpdate);
	        };
	        // Start with the roots
	        for (let i = 0; i < this.rootGraphNodes.length; i++) {
	            let rootNode = this.rootGraphNodes[i];
	            traverse(rootNode, false);
	        }
	    }
	    /** Updates the geometries of the bodies matching the bitfield based on node transforms. */
	    updateCollisionGeometry(bitfield) {
	        var _a;
	        for (let i = 0; i < this.bodies.length; i++) {
	            let body = this.bodies[i];
	            let mat;
	            if (((_a = body.userData) === null || _a === void 0 ? void 0 : _a.nodeIndex) !== undefined) {
	                if (((1 << body.userData.nodeIndex) & bitfield) === 0)
	                    continue;
	                mat = this.worldMatrix.clone();
	                mat.multiplyMatrices(this.worldMatrix, this.nodeTransforms[body.userData.nodeIndex]);
	            }
	            else {
	                mat = this.worldMatrix;
	            }
	            // For all shapes...
	            for (let shape of body.shapes) {
	                let vertices = this.shapeVertices.get(shape);
	                // Assign the transformed vectors to the vertices of the geometry
	                for (let i = 0; i < vertices.length; i++) {
	                    shape.points[i].copy(vertices[i]).applyMatrix4(mat);
	                }
	                shape.computeLocalBoundingBox();
	            }
	            body.syncShapes();
	        }
	    }
	    tick(time, onlyVisual = false) {
	        // If onlyVisual is set, collision bodies need not be updated.
	        var _a, _b, _c, _d;
	        if (!this.showSequences)
	            return;
	        if (!onlyVisual && !this.hasNonVisualSequences)
	            return;
	        if (!this.shareNodeTransforms || this.isMaster)
	            for (let sequence of this.dts.sequences) {
	                let rot = (_a = sequence.rotationMatters[0]) !== null && _a !== void 0 ? _a : 0;
	                let trans = (_b = sequence.translationMatters[0]) !== null && _b !== void 0 ? _b : 0;
	                let scale = (_c = sequence.scaleMatters[0]) !== null && _c !== void 0 ? _c : 0;
	                let affectedCount = 0;
	                let completion = time.timeSinceLoad / (sequence.duration * 1000);
	                let quaternions;
	                let translations;
	                let scales;
	                // Possibly get the keyframe from the overrides
	                let actualKeyframe = (_d = this.sequenceKeyframeOverride.get(sequence)) !== null && _d !== void 0 ? _d : (completion * sequence.numKeyframes) % sequence.numKeyframes;
	                if (this.lastSequenceKeyframes.get(sequence) === actualKeyframe)
	                    continue;
	                this.lastSequenceKeyframes.set(sequence, actualKeyframe);
	                let keyframeLow = Math.floor(actualKeyframe);
	                let keyframeHigh = Math.ceil(actualKeyframe) % sequence.numKeyframes;
	                let t = (actualKeyframe - keyframeLow) % 1; // The completion between two keyframes
	                // Handle rotation sequences
	                if (rot > 0)
	                    quaternions = this.dts.nodes.map((node, index) => {
	                        let affected = ((1 << index) & rot) !== 0;
	                        if (affected) {
	                            let rot1 = this.dts.nodeRotations[sequence.numKeyframes * affectedCount + keyframeLow];
	                            let rot2 = this.dts.nodeRotations[sequence.numKeyframes * affectedCount + keyframeHigh];
	                            let quaternion1 = new Quaternion(rot1.x, rot1.y, rot1.z, rot1.w);
	                            quaternion1.normalize();
	                            quaternion1.conjugate();
	                            let quaternion2 = new Quaternion(rot2.x, rot2.y, rot2.z, rot2.w);
	                            quaternion2.normalize();
	                            quaternion2.conjugate();
	                            // Interpolate between the two quaternions
	                            quaternion1.slerp(quaternion2, t);
	                            affectedCount++;
	                            return quaternion1;
	                        }
	                        else {
	                            // The rotation for this node is not animated and therefore we return the default rotation.
	                            let rotation = this.dts.defaultRotations[index];
	                            let quaternion = new Quaternion(rotation.x, rotation.y, rotation.z, rotation.w);
	                            quaternion.normalize();
	                            quaternion.conjugate();
	                            return quaternion;
	                        }
	                    });
	                // Handle translation sequences
	                affectedCount = 0;
	                if (trans > 0)
	                    translations = this.dts.nodes.map((node, index) => {
	                        let affected = ((1 << index) & trans) !== 0;
	                        if (affected) {
	                            let trans1 = this.dts.nodeTranslations[sequence.numKeyframes * affectedCount + keyframeLow];
	                            let trans2 = this.dts.nodeTranslations[sequence.numKeyframes * affectedCount + keyframeHigh];
	                            affectedCount++;
	                            // Interpolate between the two translations
	                            return new Vector3(Util.lerp(trans1.x, trans2.x, t), Util.lerp(trans1.y, trans2.y, t), Util.lerp(trans1.z, trans2.z, t));
	                        }
	                        else {
	                            // The translation for this node is not animated and therefore we return the default translation.
	                            let translation = this.dts.defaultTranslations[index];
	                            return new Vector3(translation.x, translation.y, translation.z);
	                        }
	                    });
	                // Handle scale sequences
	                affectedCount = 0;
	                if (scale > 0)
	                    scales = this.dts.nodes.map((node, index) => {
	                        let affected = ((1 << index) & scale) !== 0;
	                        if (affected) {
	                            let scale1 = this.dts.nodeAlignedScales[sequence.numKeyframes * affectedCount + keyframeLow];
	                            let scale2 = this.dts.nodeAlignedScales[sequence.numKeyframes * affectedCount + keyframeHigh];
	                            affectedCount++;
	                            // Interpolate between the two scales
	                            return new Vector3(Util.lerp(scale1.x, scale2.x, t), Util.lerp(scale1.y, scale2.y, t), Util.lerp(scale1.z, scale2.z, t));
	                        }
	                        else {
	                            // The scale for this node is not animated and therefore we return the default scale.
	                            return new Vector3().setScalar(1); // Apparently always this
	                        }
	                    });
	                if (rot | trans | scale) {
	                    this.updateNodeTransforms(quaternions, translations, scales, rot | trans | scale);
	                    if (!onlyVisual)
	                        this.updateCollisionGeometry(rot | trans | scale);
	                }
	            }
	        for (let mesh of this.meshes) {
	            mesh.changedTransform();
	        }
	    }
	    render(time) {
	        if (this.isTSStatic && this.hasBeenRendered)
	            return; // Render TSStatic's only once, since after that they don't change
	        this.tick(time, true); // Execute an only-visual tick
	        if (this.skinMeshInfo && this.isMaster) {
	            // Update the skin mesh.
	            let info = this.skinMeshInfo;
	            let mesh = this.dts.meshes[info.meshIndex];
	            // Zero all vectors at first
	            for (let i = 0; i < info.vertices.length; i++) {
	                info.vertices[i].set(0, 0, 0);
	                info.normals[i].set(0, 0, 0);
	            }
	            // Compute the transformation matrix for each bone
	            let boneTransformations = [];
	            let boneTransformationsTransposed = [];
	            for (let i = 0; i < mesh.nodeIndices.length; i++) {
	                let mat = new Matrix4();
	                mat.elements = mesh.initialTransforms[i].slice();
	                mat.transpose();
	                mat.multiplyMatrices(this.nodeTransforms[mesh.nodeIndices[i]], mat);
	                boneTransformations.push(mat);
	                boneTransformationsTransposed.push(mat.clone().transpose());
	            }
	            // Now fill the vertex and normal vector values
	            let vec = new Vector3();
	            let vec2 = new Vector3();
	            for (let i = 0; i < mesh.vertIndices.length; i++) {
	                let vIndex = mesh.vertIndices[i];
	                let vertex = mesh.verts[vIndex];
	                let normal = mesh.norms[vIndex];
	                vec.set(vertex.x, vertex.y, vertex.z);
	                vec2.set(normal.x, normal.y, normal.z);
	                let mat = boneTransformations[mesh.boneIndices[i]];
	                vec.applyMatrix4(mat);
	                vec.multiplyScalar(mesh.weights[i]);
	                Util.m_matF_x_vectorF(mat, vec2);
	                vec2.multiplyScalar(mesh.weights[i]);
	                info.vertices[vIndex].add(vec);
	                info.normals[vIndex].add(vec2);
	            }
	            // Normalize the normals
	            for (let i = 0; i < info.normals.length; i++) {
	                let norm = info.normals[i];
	                let len2 = norm.dot(norm);
	                // This condition is also present in the Torque 3D source
	                if (len2 > 0.01)
	                    norm.normalize();
	            }
	            // Update the values in the buffer attributes
	            let geometry = info.mesh.geometry;
	            for (let i = 0; i < info.vertices.length; i++) {
	                let vertex = info.vertices[i];
	                let normal = info.normals[i];
	                geometry.positions[3 * i + 0] = vertex.x;
	                geometry.positions[3 * i + 1] = vertex.y;
	                geometry.positions[3 * i + 2] = vertex.z;
	                geometry.normals[3 * i + 0] = normal.x;
	                geometry.normals[3 * i + 1] = normal.y;
	                geometry.normals[3 * i + 2] = normal.z;
	            }
	        }
	        if (this.skinMeshInfo)
	            this.skinMeshInfo.mesh.needsVertexBufferUpdate = true;
	        // Handle animated materials
	        if (!this.shareMaterials || this.isMaster)
	            for (let i = 0; i < this.materials.length; i++) {
	                let info = this.materialInfo.get(this.materials[i]);
	                if (!info)
	                    continue;
	                let iflSequence = this.dts.sequences.find((seq) => seq.iflMatters[0] > 0);
	                if (!iflSequence || !this.showSequences)
	                    continue;
	                let completion = time.timeSinceLoad / (iflSequence.duration * 1000);
	                let keyframe = Math.floor(completion * info.keyframes.length) % info.keyframes.length;
	                let currentFile = info.keyframes[keyframe];
	                // Select the correct texture based on the frame and apply it
	                let texture = ResourceManager.getTextureFromCache(this.directoryPath + '/' + currentFile);
	                this.materials[i].diffuseMap = texture;
	            }
	        // Spin the shape round 'n' round
	        if (this.ambientRotate) {
	            let spinAnimation = new Quaternion();
	            let up = new Vector3(0, 0, 1);
	            spinAnimation.setFromAxisAngle(up, time.timeSinceLoad * this.ambientSpinFactor);
	            let orientation = this.worldOrientation.clone();
	            spinAnimation.multiplyQuaternions(orientation, spinAnimation);
	            this.group.orientation.copy(spinAnimation);
	            this.group.recomputeTransform();
	        }
	        this.hasBeenRendered = true;
	    }
	    /** Updates the transform of the shape's objects and bodies. */
	    setTransform(position, orientation, scale) {
	        let scaleUpdated = scale.clone().sub(this.worldScale).length() !== 0;
	        this.worldPosition = position;
	        this.worldOrientation = orientation;
	        this.worldScale = scale;
	        this.worldMatrix.compose(position, orientation, scale);
	        this.group.position.copy(position);
	        this.group.orientation.copy(orientation);
	        this.group.scale.copy(scale);
	        this.group.recomputeTransform();
	        let colliderMatrix = new Matrix4();
	        colliderMatrix.compose(this.worldPosition, this.worldOrientation, new Vector3(1, 1, 1));
	        // Update the colliders
	        for (let collider of this.colliders) {
	            let mat = collider.transform.clone();
	            mat.multiplyMatrices(colliderMatrix, mat);
	            let position = new Vector3();
	            let orientation = new Quaternion();
	            mat.decompose(position, orientation, new Vector3());
	            collider.body.position.copy(position);
	            collider.body.orientation.copy(orientation);
	            while (collider.body.shapes.length)
	                collider.body.removeCollisionShape(collider.body.shapes[0]); // Remove all shapes
	            // Create the new shape
	            let shape = collider.generateShape(this.worldScale);
	            shape.collisionDetectionMask = 0b100; // Collide with the small aux marble
	            collider.body.addCollisionShape(shape);
	        }
	        if (scaleUpdated)
	            this.generateCollisionObjects(); // We need to recompute the geometry if the scale changed; this will always be called at least once in the first call
	        this.updateCollisionGeometry(0xffffffff); // Update collision geometry
	    }
	    /** Sets the opacity of the shape. Since there's no quick and easy way of doing this, this method recursively sets it for all materials. */
	    setOpacity(opacity) {
	        if (opacity === this.currentOpacity)
	            return;
	        this.currentOpacity = opacity;
	        this.group.setOpacity(opacity);
	    }
	    /** Adds a collider shape. Whenever the marble overlaps with the shape, a callback is fired. */
	    addCollider(generateShape, onInside, localTransform) {
	        let body = new RigidBody();
	        body.type = RigidBodyType.Static;
	        this.colliders.push({
	            generateShape: generateShape,
	            body: body,
	            transform: localTransform
	        });
	        body.onAfterCollisionResponse = onInside;
	    }
	    /** Enable or disable collision. */
	    setCollisionEnabled(enabled) {
	        for (let body of this.bodies) {
	            body.enabled = enabled;
	        }
	    }
	    reset() {
	        this.isCurrentlyColliding = false;
	    }
	    /* eslint-disable  @typescript-eslint/no-unused-vars */
	    onMarbleContact(collision) { }
	    onMarbleInside(t) { }
	    onMarbleEnter(t) { }
	    onMarbleLeave() { }
	    async onLevelStart() { }
	}

	/** Encapsulates a vertex buffer object, its data and its vertex attributes. */
	class VertexBuffer {
	    constructor(renderer, data, attributes) {
	        /** Keeps track of what needs to be updated to send minimum data to the GPU when doing bufferSubData. */
	        this.updateRange = { start: Infinity, end: 0 };
	        this.renderer = renderer;
	        this.buffer = renderer.gl.createBuffer();
	        this.data = data;
	        this.attributes = attributes;
	        this.stride = Object.values(attributes).reduce((a, b) => a + b, 0);
	        if (Object.keys(attributes).length === 1)
	            this.stride = 0; // Indicates a tightly-packed vertex attribute
	        let { gl } = renderer;
	        // Upload the data and done
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	        gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    }
	    /** Overrides a portion of this VBO's data. Will only be uploaded to the GPU with a call to `update()`. */
	    set(data, offset) {
	        this.data.set(data, offset);
	        this.updateRange.start = Math.min(this.updateRange.start, offset);
	        this.updateRange.end = Math.max(this.updateRange.end, offset + data.length);
	    }
	    /** Uploads any changed data to the GPU. */
	    update() {
	        if (this.updateRange.start >= this.updateRange.end)
	            return;
	        let { gl } = this.renderer;
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	        if (!(gl instanceof WebGLRenderingContext)) {
	            gl.bufferSubData(gl.ARRAY_BUFFER, this.updateRange.start * Float32Array.BYTES_PER_ELEMENT, this.data, this.updateRange.start, this.updateRange.end - this.updateRange.start);
	        }
	        else {
	            let slice = this.data.subarray(this.updateRange.start, this.updateRange.end); // This simply creates another view onto the same array buffer, no data is copied here, yay
	            gl.bufferSubData(gl.ARRAY_BUFFER, this.updateRange.start * Float32Array.BYTES_PER_ELEMENT, slice);
	        }
	        // Reset the range
	        this.updateRange.start = Infinity;
	        this.updateRange.end = 0;
	    }
	    dispose() {
	        let { gl } = this.renderer;
	        gl.deleteBuffer(this.buffer);
	    }
	}
	// Most primitive thing ever
	class VertexBufferGroup {
	    constructor(buffers) {
	        this.buffers = buffers;
	    }
	}

	const PATHS = ['particles/bubble.png', 'particles/saturn.png', 'particles/smoke.png', 'particles/spark.png', 'particles/star.png', 'particles/twirl.png'];
	const MAX_PARTICLES_PER_GROUP = 2 ** 14;
	// These two buffers define the geometry of the billboard:
	const positions = new Float32Array(Array(MAX_PARTICLES_PER_GROUP).fill([
	    -0.5, -0.5,
	    0.5, -0.5,
	    0.5, 0.5,
	    -0.5, 0.5
	]).flat());
	const uvs = new Float32Array(Array(MAX_PARTICLES_PER_GROUP).fill([
	    0, 0,
	    1, 0,
	    1, 1,
	    0, 1
	]).flat());
	const indices = [];
	for (let i = 0; i < MAX_PARTICLES_PER_GROUP; i++)
	    indices.push(4 * i + 0, 4 * i + 1, 4 * i + 2, 4 * i + 0, 4 * i + 2, 4 * i + 3);
	/** Manages emitters and particles. */
	class ParticleManager {
	    constructor(level) {
	        this.emitters = [];
	        this.particleGroups = new Map();
	        /** For non-instanced, legacy particles. */
	        this.particles = [];
	        this.level = level;
	    }
	    async init(renderer) {
	        this.renderer = renderer;
	        let { gl } = renderer;
	        // Setup the vertex buffers that will be used to draw all particles
	        this.positionBuffer = new VertexBuffer(renderer, positions, { 'position': 2 });
	        this.uvBuffer = new VertexBuffer(renderer, uvs, { 'uv': 2 });
	        this.bufferGroup = new VertexBufferGroup([this.positionBuffer, this.uvBuffer]);
	        this.indexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
	        let promises = [];
	        // Preload all textures so we can load them instantly from cache later
	        for (let path of PATHS) {
	            promises.push(ResourceManager.getTexture(path));
	        }
	        let textures = await Promise.all(promises);
	        for (let texture of textures)
	            texture.getGLTexture(renderer); // Also preload the GL texture
	    }
	    /** Gets or creates a particle group for the given options. */
	    getParticleGroup(o) {
	        let group = this.particleGroups.get(o);
	        if (!group) {
	            group = this.createParticleGroup(o);
	            this.particleGroups.set(o, group);
	        }
	        return group;
	    }
	    createParticleGroup(o) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
	        let attributes = {
	            'particleSpawnTime': 1,
	            'particleLifetime': 1,
	            'particlePosition': 3,
	            'particleVelocity': 3,
	            'particleInitialSpin': 1
	        };
	        const floatsPerParticle = Object.values(attributes).reduce((a, b) => a + b, 0);
	        const vertsPerParticle = 4;
	        let buffer = new Float32Array(floatsPerParticle * vertsPerParticle * MAX_PARTICLES_PER_GROUP); // Make the buffer large enough so that we won't ever have to worry about not being able to fit enough particles in
	        let vertexBuffer = new VertexBuffer(this.renderer, buffer, attributes);
	        let colorsMatrix = new Matrix4();
	        colorsMatrix.set(((_a = o.colors[0]) === null || _a === void 0 ? void 0 : _a.r) || 0, ((_b = o.colors[0]) === null || _b === void 0 ? void 0 : _b.g) || 0, ((_c = o.colors[0]) === null || _c === void 0 ? void 0 : _c.b) || 0, ((_d = o.colors[0]) === null || _d === void 0 ? void 0 : _d.a) || 0, ((_e = o.colors[1]) === null || _e === void 0 ? void 0 : _e.r) || 0, ((_f = o.colors[1]) === null || _f === void 0 ? void 0 : _f.g) || 0, ((_g = o.colors[1]) === null || _g === void 0 ? void 0 : _g.b) || 0, ((_h = o.colors[1]) === null || _h === void 0 ? void 0 : _h.a) || 0, ((_j = o.colors[2]) === null || _j === void 0 ? void 0 : _j.r) || 0, ((_k = o.colors[2]) === null || _k === void 0 ? void 0 : _k.g) || 0, ((_l = o.colors[2]) === null || _l === void 0 ? void 0 : _l.b) || 0, ((_m = o.colors[2]) === null || _m === void 0 ? void 0 : _m.a) || 0, ((_o = o.colors[3]) === null || _o === void 0 ? void 0 : _o.r) || 0, ((_p = o.colors[3]) === null || _p === void 0 ? void 0 : _p.g) || 0, ((_q = o.colors[3]) === null || _q === void 0 ? void 0 : _q.b) || 0, ((_r = o.colors[3]) === null || _r === void 0 ? void 0 : _r.a) || 0);
	        colorsMatrix.transpose();
	        // Set all the values that are true for every particle of this type
	        let uniforms = {
	            acceleration: o.acceleration,
	            spinSpeed: Util.degToRad(o.spinSpeed),
	            dragCoefficient: o.dragCoefficient,
	            times: new Float32Array([(_s = o.times[0]) !== null && _s !== void 0 ? _s : Infinity, (_t = o.times[1]) !== null && _t !== void 0 ? _t : Infinity, (_u = o.times[2]) !== null && _u !== void 0 ? _u : Infinity, (_v = o.times[3]) !== null && _v !== void 0 ? _v : Infinity]),
	            sizes: new Float32Array([o.sizes[0] || 0, o.sizes[1] || 0, o.sizes[2] || 0, o.sizes[3] || 0]),
	            colors: new Float32Array(colorsMatrix.elements)
	        };
	        let group = {
	            vertexBuffer: vertexBuffer,
	            uniforms,
	            particles: []
	        };
	        return group;
	    }
	    getTime() {
	        return this.level.timeState.timeSinceLoad;
	    }
	    createEmitter(options, initialPos, getPos, spawnSphereSquish) {
	        var _a;
	        let emitter = new ParticleEmitter(options, this, getPos, spawnSphereSquish);
	        emitter.currPos = (_a = getPos === null || getPos === void 0 ? void 0 : getPos()) !== null && _a !== void 0 ? _a : initialPos.clone();
	        emitter.currPosTime = this.getTime();
	        emitter.spawn(this.getTime());
	        this.emitters.push(emitter);
	        return emitter;
	    }
	    removeEmitter(emitter) {
	        Util.removeFromArray(this.emitters, emitter);
	    }
	    tick() {
	        let time = this.getTime();
	        for (let i = 0; i < this.emitters.length; i++) {
	            let emitter = this.emitters[i];
	            if (emitter.getPos)
	                emitter.setPos(emitter.getPos(), time);
	            let alive = emitter.tick(time);
	            if (!alive)
	                this.emitters.splice(i--, 1);
	        }
	    }
	    render(time) {
	        this.currentRenderTime = time;
	        // Update all the particle groups
	        for (let [, group] of this.particleGroups) {
	            for (let i = 0; i < group.particles.length; i++) {
	                let particle = group.particles[i];
	                let dead = !particle.isAlive(time);
	                if (dead) {
	                    if (i < group.particles.length - 1) {
	                        // Since we want the array to be contiguous, swap in the last particle in the list to fill the hole
	                        group.particles[i] = group.particles[group.particles.length - 1];
	                        group.particles[i].applyToGroup(group, i);
	                    }
	                    group.particles.length--;
	                    i--;
	                }
	            }
	            group.vertexBuffer.update();
	        }
	    }
	    dispose() {
	        for (let [, group] of this.particleGroups) {
	            group.vertexBuffer.dispose();
	        }
	    }
	}
	class ParticleEmitter {
	    constructor(options, manager, getPos, spawnSphereSquish) {
	        this.vel = new Vector3();
	        this.o = options;
	        this.manager = manager;
	        this.getPos = getPos;
	        this.spawnSphereSquish = spawnSphereSquish !== null && spawnSphereSquish !== void 0 ? spawnSphereSquish : new Vector3(1, 1, 1);
	    }
	    spawn(time) {
	        this.spawnTime = time;
	        this.emit(time);
	    }
	    tick(time) {
	        // Cap the amount of particles emitted in such a case to prevent lag
	        if (time - this.lastEmitTime >= 1000)
	            this.lastEmitTime = time - 1000;
	        // Spawn as many particles as needed
	        while (this.lastEmitTime + this.currentWaitPeriod <= time) {
	            this.emit(this.lastEmitTime + this.currentWaitPeriod);
	            let completion = Util.clamp((this.lastEmitTime - this.spawnTime) / this.o.emitterLifetime, 0, 1);
	            if (completion === 1)
	                return false;
	        }
	        return true;
	    }
	    /** Emit a single particle. */
	    emit(time) {
	        this.lastEmitTime = time;
	        this.currentWaitPeriod = this.o.ejectionPeriod;
	        let pos = this.getPosAtTime(time).clone();
	        if (this.o.spawnOffset)
	            pos.add(this.o.spawnOffset()); // Call the spawnOffset function if it's there
	        // Generate a point uniformly chosen on a sphere's surface.
	        let randomPointOnSphere = new Vector3().randomDirection();
	        randomPointOnSphere.multiply(this.spawnSphereSquish);
	        // Compute the total velocity
	        let vel = this.vel.clone().multiplyScalar(this.o.inheritedVelFactor).add(randomPointOnSphere.multiplyScalar(this.o.ejectionVelocity + this.o.velocityVariance * (Math.random() * 2 - 1))).add(this.o.ambientVelocity);
	        let group = this.manager.getParticleGroup(this.o.particleOptions);
	        if (group.particles.length === MAX_PARTICLES_PER_GROUP)
	            return;
	        let particle = new Particle(this.o.particleOptions, this.manager, time, pos, vel);
	        particle.applyToGroup(group, group.particles.length);
	        group.particles.push(particle);
	    }
	    /** Computes the interpolated emitter position at a point in time. */
	    getPosAtTime(time) {
	        if (!this.lastPos)
	            return this.currPos;
	        let completion = Util.clamp((time - this.lastPosTime) / (this.currPosTime - this.lastPosTime), 0, 1);
	        return this.lastPos.clone().lerp(this.currPos, completion);
	    }
	    setPos(pos, time) {
	        this.lastPos = this.currPos;
	        this.lastPosTime = this.currPosTime;
	        this.currPos = pos.clone();
	        this.currPosTime = time;
	        this.vel = this.currPos.clone().sub(this.lastPos).multiplyScalar(1000 / (this.currPosTime - this.lastPosTime));
	    }
	    static cloneOptions(options) {
	        let clone = Util.jsonClone(options);
	        clone.ambientVelocity = new Vector3(options.ambientVelocity.x, options.ambientVelocity.y, options.ambientVelocity.z);
	        clone.spawnOffset = options.spawnOffset;
	        return clone;
	    }
	}
	class Particle {
	    constructor(options, manager, spawnTime, pos, vel) {
	        this.o = options;
	        this.manager = manager;
	        this.spawnTime = spawnTime;
	        this.pos = pos;
	        this.vel = vel;
	        this.lifetime = this.o.lifetime + this.o.lifetimeVariance * (Math.random() * 2 - 1);
	        this.initialSpin = Util.lerp(this.o.spinRandomMin, this.o.spinRandomMax, Math.random());
	    }
	    /** Writes this particle's starting state into vertex buffers so that it can be simulated on the GPU. */
	    applyToGroup(group, index) {
	        let data = [
	            this.spawnTime,
	            this.lifetime,
	            this.pos.x, this.pos.y, this.pos.z,
	            this.vel.x, this.vel.y, this.vel.z,
	            Util.degToRad(this.initialSpin)
	        ];
	        // Update the data about the particle for each of the vertices. Yeah, it's a bit redundant, but name a better way. Data texture, you say? 😂
	        let buf = group.vertexBuffer;
	        buf.set(data, 4 * index * buf.stride + 0 * buf.stride);
	        buf.set(data, 4 * index * buf.stride + 1 * buf.stride);
	        buf.set(data, 4 * index * buf.stride + 2 * buf.stride);
	        buf.set(data, 4 * index * buf.stride + 3 * buf.stride);
	    }
	    isAlive(time) {
	        let elapsed = time - this.spawnTime;
	        let completion = Util.clamp(elapsed / this.lifetime, 0, 1);
	        return completion < 1;
	    }
	}
	const particleNodeEmittersEmitterOptions = {
	    MarbleTrailEmitter: {
	        ejectionPeriod: 5,
	        ambientVelocity: new Vector3(0, 0, 0),
	        ejectionVelocity: 0,
	        velocityVariance: 0.25,
	        emitterLifetime: 10000,
	        inheritedVelFactor: 0,
	        particleOptions: {
	            texture: 'particles/smoke.png',
	            blending: BlendingType.Normal,
	            spinSpeed: 0,
	            spinRandomMin: 0,
	            spinRandomMax: 0,
	            lifetime: 100,
	            lifetimeVariance: 10,
	            dragCoefficient: 0,
	            acceleration: 0,
	            colors: [{ r: 1, g: 1, b: 0, a: 0 }, { r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 1, b: 1, a: 0 }],
	            sizes: [0.4, 0.4, 0.4],
	            times: [0, 0.15, 1]
	        }
	    },
	    LandMineEmitter: {
	        ejectionPeriod: 10,
	        ambientVelocity: new Vector3(0, 0, 0),
	        ejectionVelocity: 0.5,
	        velocityVariance: 0.25,
	        emitterLifetime: Infinity,
	        inheritedVelFactor: 0.2,
	        particleOptions: {
	            texture: 'particles/smoke.png',
	            blending: BlendingType.Additive,
	            spinSpeed: 40,
	            spinRandomMin: -90,
	            spinRandomMax: 90,
	            lifetime: 1000,
	            lifetimeVariance: 150,
	            dragCoefficient: 0.8,
	            acceleration: 0,
	            colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.56, g: 0.36, b: 0.26, a: 0 }],
	            sizes: [0.5, 1],
	            times: [0, 1]
	        }
	    }
	};

	/** Stores a cube texture. */
	class CubeTexture {
	    constructor(renderer, arg2) {
	        this.id = Util.getRandomId();
	        /** For efficiency purposes, not all faces of the texture are rendered to in one step. Therefore, we need to keep track of where we left off. */
	        this.nextFaceToRender = 0;
	        this.renderer = renderer;
	        let { gl } = renderer;
	        let texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
	        if (Array.isArray(arg2)) {
	            let images = arg2;
	            if (images.some(x => !x.complete))
	                throw new Error("Can only pass loaded images into CubeTexture.");
	            this.size = images[0].naturalWidth; // Assume square images
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[0]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[1]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[2]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[3]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[4]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[5]);
	            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	        }
	        else {
	            let size = arg2;
	            this.size = size;
	            let data = new Uint8Array(size * size * 4); // Passing the (albeit empty) data suppresses an annoying warning on Firefox
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        }
	        // Make sure to set min/mag filters, otherwise nothing will render
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	        this.glTexture = texture;
	    }
	    /** Creates a framebuffer that will be used to render a scene to this cube texture. */
	    createFramebuffer() {
	        let { gl } = this.renderer;
	        let framebuffer = gl.createFramebuffer();
	        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	        let depthBuffer = gl.createRenderbuffer();
	        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
	        // Make a depth buffer and the same size as the target texture
	        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.size, this.size);
	        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
	        this.framebuffer = framebuffer;
	        this.depthBuffer = depthBuffer;
	    }
	    /**
	     * Renders a given scene to the cube texture. Depending on the budget, this might not render to all six faces.
	     * @param budget Defines the maximum amount of time in milliseconds this method should run. Can be used to set an upper bound on render time, since rendering a scene six times _can_ get expensive.
	     */
	    render(scene, cubeCamera, budget = Infinity) {
	        let { gl } = this.renderer;
	        if (!this.framebuffer)
	            this.createFramebuffer(); // We're here for the first time, so go and create a framebuffer first
	        let start = performance.now();
	        let renderedFaces = 0;
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
	        for (let i = 0; i < 6; i++) {
	            // Figure out what face we need to render next based on where we left off
	            let index = (this.nextFaceToRender + i) % 6;
	            // Update the camera's position
	            let camera = cubeCamera.cameras[index];
	            camera.position.copy(cubeCamera.position);
	            camera.updateMatrixWorld();
	            // Bind the correct side of the cube texture to the framebuffer as a texture target
	            let target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + index;
	            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, this.glTexture, 0);
	            // Render the scene
	            this.renderer.render(scene, camera, { framebuffer: this.framebuffer, width: this.size, height: this.size, colorTexture: this.glTexture });
	            renderedFaces++;
	            let time = performance.now();
	            let elapsed = time - start;
	            let elapsedPerFace = elapsed / renderedFaces;
	            if (elapsedPerFace * (renderedFaces + 1) >= budget)
	                break; // We predict that the next loop iteration would exceed the budget, so break
	        }
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.glTexture);
	        gl.generateMipmap(gl.TEXTURE_CUBE_MAP); // Make sure to generate mips
	        this.nextFaceToRender += renderedFaces;
	        this.nextFaceToRender %= 6;
	    }
	    dispose() {
	        let { gl } = this.renderer;
	        gl.deleteTexture(this.glTexture);
	        gl.deleteFramebuffer(this.framebuffer);
	        gl.deleteRenderbuffer(this.depthBuffer);
	    }
	}

	let m1$1 = new Matrix4();
	class Camera {
	    constructor() {
	        this.position = new Vector3();
	        this.orientation = new Quaternion();
	        this.up = new Vector3(0, 0, 1);
	        this.matrixWorld = new Matrix4();
	        this.matrixWorldInverse = new Matrix4();
	        this.projectionMatrix = new Matrix4();
	        this.projectionMatrixInverse = new Matrix4();
	    }
	    updateMatrixWorld() {
	        this.matrixWorld.compose(this.position, this.orientation, new Vector3().setScalar(1));
	        this.matrixWorldInverse.copy(this.matrixWorld).invert();
	    }
	    lookAt(target) {
	        m1$1.lookAt(this.position, target, this.up);
	        this.orientation.setFromRotationMatrix(m1$1);
	    }
	}
	class PerspectiveCamera extends Camera {
	    constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
	        super();
	        this.fov = fov;
	        this.zoom = 1;
	        this.near = near;
	        this.far = far;
	        this.aspect = aspect;
	        this.updateProjectionMatrix();
	    }
	    updateProjectionMatrix() {
	        const near = this.near;
	        let top = (near * Math.tan(Util.degToRad(0.5 * this.fov))) / this.zoom;
	        let height = 2 * top;
	        let width = this.aspect * height;
	        let left = -0.5 * width;
	        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
	        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	    }
	}
	class OrthographicCamera extends Camera {
	    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
	        super();
	        this.zoom = 1;
	        this.left = left;
	        this.right = right;
	        this.top = top;
	        this.bottom = bottom;
	        this.near = near;
	        this.far = far;
	        this.updateProjectionMatrix();
	    }
	    updateProjectionMatrix() {
	        const dx = (this.right - this.left) / (2 * this.zoom);
	        const dy = (this.top - this.bottom) / (2 * this.zoom);
	        const cx = (this.right + this.left) / 2;
	        const cy = (this.top + this.bottom) / 2;
	        let left = cx - dx;
	        let right = cx + dx;
	        let top = cy + dy;
	        let bottom = cy - dy;
	        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
	        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	    }
	}

	/** Cube cameras can be used to render to cube textures. */
	class CubeCamera {
	    constructor(near, far) {
	        this.cameras = [];
	        this.position = new Vector3();
	        const fov = 90, aspect = 1;
	        // Create all 6 cameras, each capturing exactly 1/6th of the cube (taken from three.js)
	        const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
	        cameraPX.up.set(0, -1, 0);
	        cameraPX.lookAt(new Vector3(1, 0, 0));
	        this.cameras.push(cameraPX);
	        const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
	        cameraNX.up.set(0, -1, 0);
	        cameraNX.lookAt(new Vector3(-1, 0, 0));
	        this.cameras.push(cameraNX);
	        const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
	        cameraPY.up.set(0, 0, 1);
	        cameraPY.lookAt(new Vector3(0, 1, 0));
	        this.cameras.push(cameraPY);
	        const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
	        cameraNY.up.set(0, 0, -1);
	        cameraNY.lookAt(new Vector3(0, -1, 0));
	        this.cameras.push(cameraNY);
	        const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
	        cameraPZ.up.set(0, -1, 0);
	        cameraPZ.lookAt(new Vector3(0, 0, 1));
	        this.cameras.push(cameraPZ);
	        const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
	        cameraNZ.up.set(0, -1, 0);
	        cameraNZ.lookAt(new Vector3(0, 0, -1));
	        this.cameras.push(cameraNZ);
	    }
	}

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	const _matrix = new Matrix4();
	const _quaternion$1 = new Quaternion();
	/**
	A class representing Euler Angles using intrinsic Tait-Bryan angles.

	Euler angles describe a rotational transformation by rotating an object on its various axes in specified amounts per axis, and a specified axis order.
	 */
	class Euler {
	    constructor(x = 0, y = 0, z = 0, order = Euler.defaultOrder) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.order = order;
	    }
	    /** Sets the angles of this euler transform and optionally the `order`. */
	    set(x, y, z, order = this.order) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.order = order;
	        return this;
	    }
	    /** Returns a new Euler with the same parameters as this one. */
	    clone() {
	        return new Euler(this.x, this.y, this.z, this.order);
	    }
	    /** Copies value of `euler` to this euler. */
	    copy(euler) {
	        this.x = euler.x;
	        this.y = euler.y;
	        this.z = euler.z;
	        this.order = euler.order;
	        return this;
	    }
	    /** Sets the angles of this euler transform from a pure rotation matrix based on the orientation specified by `order`. */
	    setFromRotationMatrix(m, order = this.order) {
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        const te = m.elements;
	        const m11 = te[0], m12 = te[4], m13 = te[8];
	        const m21 = te[1], m22 = te[5], m23 = te[9];
	        const m31 = te[2], m32 = te[6], m33 = te[10];
	        switch (order) {
	            case "XYZ":
	                this.y = Math.asin(Util.clamp(m13, -1, 1));
	                if (Math.abs(m13) < 0.9999999) {
	                    this.x = Math.atan2(-m23, m33);
	                    this.z = Math.atan2(-m12, m11);
	                }
	                else {
	                    this.x = Math.atan2(m32, m22);
	                    this.z = 0;
	                }
	                break;
	            case "YXZ":
	                this.x = Math.asin(-Util.clamp(m23, -1, 1));
	                if (Math.abs(m23) < 0.9999999) {
	                    this.y = Math.atan2(m13, m33);
	                    this.z = Math.atan2(m21, m22);
	                }
	                else {
	                    this.y = Math.atan2(-m31, m11);
	                    this.z = 0;
	                }
	                break;
	            case "ZXY":
	                this.x = Math.asin(Util.clamp(m32, -1, 1));
	                if (Math.abs(m32) < 0.9999999) {
	                    this.y = Math.atan2(-m31, m33);
	                    this.z = Math.atan2(-m12, m22);
	                }
	                else {
	                    this.y = 0;
	                    this.z = Math.atan2(m21, m11);
	                }
	                break;
	            case "ZYX":
	                this.y = Math.asin(-Util.clamp(m31, -1, 1));
	                if (Math.abs(m31) < 0.9999999) {
	                    this.x = Math.atan2(m32, m33);
	                    this.z = Math.atan2(m21, m11);
	                }
	                else {
	                    this.x = 0;
	                    this.z = Math.atan2(-m12, m22);
	                }
	                break;
	            case "YZX":
	                this.z = Math.asin(Util.clamp(m21, -1, 1));
	                if (Math.abs(m21) < 0.9999999) {
	                    this.x = Math.atan2(-m23, m22);
	                    this.y = Math.atan2(-m31, m11);
	                }
	                else {
	                    this.x = 0;
	                    this.y = Math.atan2(m13, m33);
	                }
	                break;
	            case "XZY":
	                this.z = Math.asin(-Util.clamp(m12, -1, 1));
	                if (Math.abs(m12) < 0.9999999) {
	                    this.x = Math.atan2(m32, m22);
	                    this.y = Math.atan2(m13, m11);
	                }
	                else {
	                    this.x = Math.atan2(-m23, m33);
	                    this.y = 0;
	                }
	                break;
	            default:
	                console.warn("Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
	        }
	        this.order = order;
	        return this;
	    }
	    /** Sets the angles of this euler transform from a normalized quaternion based on the orientation specified by `order`. */
	    setFromQuaternion(q, order) {
	        _matrix.makeRotationFromQuaternion(q);
	        return this.setFromRotationMatrix(_matrix, order);
	    }
	    /** Set the x, y and z, and optionally update the `order`. */
	    setFromVector3(v, order = this.order) {
	        return this.set(v.x, v.y, v.z, order);
	    }
	    /** Resets the euler angle with a new order by creating a quaternion from this euler angle and then setting this euler angle with the quaternion and the new order. WARNING: this discards revolution information. */
	    reorder(newOrder) {
	        // WARNING: this discards revolution information -bhouston
	        _quaternion$1.setFromEuler(this);
	        return this.setFromQuaternion(_quaternion$1, newOrder);
	    }
	    /** Checks for strict equality of this euler and `euler`. */
	    equals(euler) {
	        return euler.x === this.x && euler.y === this.y && euler.z === this.z && euler.order === this.order;
	    }
	    /** Assigns this euler's x angle to array[0]. Assigns this euler's y angle to array[1]. Assigns this euler's z angle to array[2]. Optionally assigns this euler's order to array[3]. */
	    fromArray(array) {
	        this.x = array[0];
	        this.y = array[1];
	        this.z = array[2];
	        if (array[3] !== undefined)
	            this.order = array[3];
	        return this;
	    }
	    /** Returns an array of the form [x, y, z, order]. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.order;
	        return array;
	    }
	    /** Returns the Euler's x, y and z properties as a Vector3. */
	    toVector3(optionalResult) {
	        if (optionalResult) {
	            return optionalResult.set(this.x, this.y, this.z);
	        }
	        else {
	            return new Vector3(this.x, this.y, this.z);
	        }
	    }
	}
	Euler.defaultOrder = "XYZ";
	Euler.rotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];

	const DEFAULT_RADIUS = 0.2;
	const ULTRA_RADIUS = 0.3;
	const MEGA_MARBLE_RADIUS = 0.6666;
	const MARBLE_ROLL_FORCE = 40 ;
	const TELEPORT_FADE_DURATION = 500;
	const bounceParticleOptions = {
	    ejectionPeriod: 1,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 2.6,
	    velocityVariance: 0.25 * 0.5,
	    emitterLifetime: 3,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/star.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 90,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 500,
	        lifetimeVariance: 100,
	        dragCoefficient: 0.5,
	        acceleration: -2,
	        colors: [{ r: 0.9, g: 0, b: 0, a: 1 }, { r: 0.9, g: 0.9, b: 0, a: 1 }, { r: 0.9, g: 0.9, b: 0, a: 0 }],
	        sizes: [0.25, 0.25, 0.25],
	        times: [0, 0.75, 1]
	    }
	};
	const blastParticleOptions = {
	    ejectionPeriod: 0.9,
	    ambientVelocity: new Vector3(0, 0, -0.3),
	    ejectionVelocity: 3,
	    velocityVariance: 0.4,
	    emitterLifetime: 300,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 20,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 600,
	        lifetimeVariance: 250,
	        dragCoefficient: 0.2,
	        acceleration: -0.1,
	        colors: [{ r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 0.2 }, { r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 1 }, { r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 1 }, { r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 0 }],
	        sizes: [0.1, 0.1, 0.1],
	        times: [0, 0.2, 0.75, 1]
	    }
	};
	const blastMaxParticleOptions = ParticleEmitter.cloneOptions(blastParticleOptions);
	blastMaxParticleOptions.ejectionVelocity = 4;
	blastMaxParticleOptions.ejectionPeriod = 0.7;
	blastMaxParticleOptions.particleOptions.dragCoefficient = 0.3;
	blastMaxParticleOptions.particleOptions.colors = blastMaxParticleOptions.particleOptions.colors.map(x => { x.r = 255 / 255; x.g = 159 / 255; x.b = 25 / 255; return x; });
	/** Controls marble behavior and responds to player input. */
	class Marble {
	    constructor(level) {
	        /** The predicted position of the marble in the next tick. */
	        this.predictedPosition = new Vector3();
	        /** The predicted orientation of the marble in the next tick. */
	        this.predictedOrientation = new Quaternion();
	        /** The radius of the marble. */
	        this.radius = null;
	        /** The default jump impulse of the marble. */
	        this.jumpImpulse =  7.3; // For now, seems to fit more than the "actual" 7.5.
	        /** The default restitution of the marble. */
	        this.bounceRestitution = 0.5;
	        this.superBounceEnableTime = -Infinity;
	        this.shockAbsorberEnableTime = -Infinity;
	        this.helicopterEnableTime = -Infinity;
	        this.megaMarbleEnableTime = -Infinity;
	        this.helicopterSound = null;
	        this.shockAbsorberSound = null;
	        this.superBounceSound = null;
	        this.lastMovementVec = new Vector3();
	        this.beforeVel = new Vector3();
	        this.beforeAngVel = new Vector3();
	        /** Necessary for super speed. */
	        this.lastContactNormal = new Vector3();
	        this.slidingTimeout = 0;
	        this.level = level;
	    }
	    get speedFac() {
	        return DEFAULT_RADIUS / this.radius;
	    }
	    async init() {
	        var _a, _b;
	        this.group = new Group();
	        this.innerGroup = new Group();
	        this.group.add(this.innerGroup);
	        if (this.level.mission.misFile.marbleAttributes["jumpImpulse"] !== undefined)
	            this.jumpImpulse = MisParser.parseNumber(this.level.mission.misFile.marbleAttributes["jumpImpulse"]);
	        if (this.level.mission.misFile.marbleAttributes["bounceRestitution"] !== undefined)
	            this.bounceRestitution = MisParser.parseNumber(this.level.mission.misFile.marbleAttributes["bounceRestitution"]);
	        // Get the correct texture
	        let marbleTexture;
	        let customTextureBlob = ((_a = this.level.offlineSettings) === null || _a === void 0 ? void 0 : _a.marbleTexture) !== undefined ? this.level.offlineSettings.marbleTexture : await StorageManager.databaseGet('keyvalue', 'marbleTexture');
	        if (customTextureBlob) {
	            try {
	                let url = ResourceManager.getUrlToBlob(customTextureBlob);
	                marbleTexture = await ResourceManager.getTexture(url, '');
	            }
	            catch (e) {
	                console.error("Failed to load custom marble texture:", e);
	            }
	        }
	        else {
	            marbleTexture = await ResourceManager.getTexture("shapes/balls/base.marble.png");
	        }
	        let has2To1Texture = marbleTexture.image.width === marbleTexture.image.height * 2;
	        if (this.isReflective()) {
	            this.cubeMap = new CubeTexture(mainRenderer, 128);
	            this.cubeCamera = new CubeCamera(0.025, this.level.camera.far);
	        }
	        const addMarbleReflectivity = (m) => {
	            m.envMap = this.cubeMap;
	            m.envMapZUp = false;
	            m.reflectivity = 0.7;
	            m.useFresnel = true;
	            m.useAccurateReflectionRay = true;
	        };
	        // Create the 3D object
	        if (has2To1Texture || (this.level.mission.modification === 'ultra' && !customTextureBlob)) {
	            let ballShape = new Shape();
	            ballShape.shareMaterials = false;
	            ballShape.dtsPath = 'shapes/balls/pack1/pack1marble.dts';
	            ballShape.castShadows = true;
	            ballShape.materialPostprocessor = m => {
	                m.normalizeNormals = true; // We do this so that the marble doesn't get darker the larger it gets
	                m.flipY = true;
	                if (this.isReflective())
	                    addMarbleReflectivity(m);
	            };
	            if (customTextureBlob)
	                ballShape.matNamesOverride['base.marble'] = marbleTexture;
	            await ballShape.init(this.level);
	            this.innerGroup.add(ballShape.group);
	            this.ballShape = ballShape;
	        }
	        let geometry = Geometry.createSphereGeometry(1, 32, 16);
	        let sphereMaterial = new Material();
	        sphereMaterial.diffuseMap = marbleTexture;
	        sphereMaterial.normalizeNormals = true;
	        sphereMaterial.flipY = true;
	        if (this.isReflective())
	            addMarbleReflectivity(sphereMaterial);
	        // Create the sphere's mesh
	        let sphere = new Mesh(geometry, [sphereMaterial]);
	        sphere.castShadows = true;
	        this.sphere = sphere;
	        this.innerGroup.add(sphere);
	        // Create the physics stuff
	        this.body = new RigidBody();
	        this.body.evaluationOrder = 1000; // Make sure this body's handlers are called after all the other ones (interiors, shapes, etc)
	        let colShape = new BallCollisionShape(0); // We'll update the radius later
	        colShape.restitution = this.bounceRestitution;
	        this.shape = colShape;
	        this.body.addCollisionShape(colShape);
	        let largeAuxShape = new BallCollisionShape(0);
	        largeAuxShape.collisionDetectionMask = 0b10;
	        largeAuxShape.collisionResponseMask = 0;
	        this.body.addCollisionShape(largeAuxShape);
	        let smallAuxShape = new BallCollisionShape(0);
	        smallAuxShape.collisionDetectionMask = 0b100;
	        smallAuxShape.collisionResponseMask = 0;
	        this.body.addCollisionShape(smallAuxShape);
	        colShape.broadphaseShape = largeAuxShape;
	        smallAuxShape.broadphaseShape = largeAuxShape;
	        this.largeAuxShape = largeAuxShape;
	        this.smallAuxShape = smallAuxShape;
	        this.body.onBeforeIntegrate = this.onBeforeIntegrate.bind(this);
	        this.body.onAfterIntegrate = this.onAfterIntegrate.bind(this);
	        this.body.onBeforeCollisionResponse = this.onBeforeCollisionResponse.bind(this);
	        this.body.onAfterCollisionResponse = this.onAfterCollisionResponse.bind(this);
	        // Set the marble's default orientation to be close to actual MBP
	        this.body.orientation.setFromEuler(new Euler(Math.PI / 2, Math.PI * 7 / 6, 0));
	        this.forcefield = new Shape();
	        this.forcefield.dtsPath = "shapes/images/glow_bounce.dts";
	        await this.forcefield.init(this.level);
	        this.forcefield.setOpacity(0);
	        this.forcefield.showSequences = false; // Hide the weird default animation it does
	        this.innerGroup.add(this.forcefield.group);
	        this.helicopter = new Shape();
	        // Easter egg: Due to an iconic bug where the helicopter would instead look like a glow bounce, this can now happen 0.1% of the time.
	        this.helicopter.dtsPath = (Math.random() < 1 / 1000) ? "shapes/images/glow_bounce.dts" : "shapes/images/helicopter.dts";
	        this.helicopter.castShadows = true;
	        await this.helicopter.init(this.level);
	        this.helicopter.setOpacity(0);
	        this.group.add(this.helicopter.group);
	        // Load the necessary rolling sounds
	        let toLoad = ["jump.wav", "bouncehard1.wav", "bouncehard2.wav", "bouncehard3.wav", "bouncehard4.wav", "rolling_hard.wav", "sliding.wav"];
	        if (this.level.mission.hasBlast)
	            toLoad.push("blast.wav");
	        await this.level.audio.loadBuffers(toLoad);
	        this.rollingSound = this.level.audio.createAudioSource('rolling_hard.wav');
	        this.rollingSound.play();
	        this.rollingSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	        this.rollingSound.setLoop(true);
	        // Check if we need to prep a Mega Marble sound
	        if (this.level.mission.allElements.some(x => { var _a; return x._type === MissionElementType.Item && ((_a = x.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'megamarbleitem'; })) {
	            this.rollingMegaMarbleSound = this.level.audio.createAudioSource('mega_roll.wav');
	            this.rollingMegaMarbleSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	            this.rollingMegaMarbleSound.setLoop(true);
	        }
	        this.slidingSound = this.level.audio.createAudioSource('sliding.wav');
	        this.slidingSound.play();
	        this.slidingSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	        this.slidingSound.setLoop(true);
	        await Promise.all([this.rollingSound.promise, this.slidingSound.promise, (_b = this.rollingMegaMarbleSound) === null || _b === void 0 ? void 0 : _b.promise]);
	    }
	    /** Returns true iff the marble should use special reflective shaders. */
	    isReflective() {
	        var _a;
	        if (((_a = this.level.offlineSettings) === null || _a === void 0 ? void 0 : _a.reflectiveMarble) !== undefined)
	            return this.level.offlineSettings.reflectiveMarble;
	        return (StorageManager.data.settings.marbleReflectivity === 2 || (StorageManager.data.settings.marbleReflectivity === 0 && this.level.mission.modification === 'ultra')) && !Util.isIOS();
	        // On some iOS devices, the reflective marble is invisible. That implies a shader compilation error but I sadly cannot check the console on there so we're just disabling them for all iOS devices.
	    }
	    findBestCollision(withRespectTo) {
	        let bestCollision;
	        let bestCollisionValue = -Infinity;
	        for (let collision of this.body.collisions) {
	            if (collision.s1 !== this.shape)
	                continue; // Could also be an aux collider that caused the collision but we don't wanna count that here
	            let value = withRespectTo(collision);
	            if (value > bestCollisionValue) {
	                bestCollision = collision;
	                bestCollisionValue = value;
	            }
	        }
	        if (!bestCollision)
	            return null;
	        let contactNormal = bestCollision.normal;
	        let contactShape = bestCollision.s2;
	        if (bestCollision.s1 !== this.body.shapes[0]) {
	            contactNormal.negate();
	            contactShape = bestCollision.s2;
	        }
	        // How much the current surface is pointing up
	        let contactNormalUpDot = Math.abs(contactNormal.dot(this.level.currentUp));
	        return { collision: bestCollision, contactNormal, contactShape, contactNormalUpDot };
	    }
	    onBeforeIntegrate(dt) {
	        var _a;
	        let allowUserInput = !state.menu.finishScreen.showing;
	        // Construct the raw movement vector from inputs
	        let movementVec = new Vector3(0, 0, 0);
	        if (isPressed('up'))
	            movementVec.add(new Vector3(1, 0, 0));
	        if (isPressed('down'))
	            movementVec.add(new Vector3(-1, 0, 0));
	        if (isPressed('left'))
	            movementVec.add(new Vector3(0, 1, 0));
	        if (isPressed('right'))
	            movementVec.add(new Vector3(0, -1, 0));
	        // Add gamepad input and restrict if necessary
	        movementVec.add(new Vector3(-gamepadAxes.marbleY, -gamepadAxes.marbleX));
	        if (normalizedJoystickHandlePosition)
	            movementVec.add(new Vector3(-Util.signedSquare(normalizedJoystickHandlePosition.y), -Util.signedSquare(normalizedJoystickHandlePosition.x)));
	        if (movementVec.x > 1.0)
	            movementVec.x = 1.0;
	        if (movementVec.x < -1.0)
	            movementVec.x = -1.0;
	        if (movementVec.y > 1.0)
	            movementVec.y = 1.0;
	        if (movementVec.y < -1.0)
	            movementVec.y = -1.0;
	        if (!allowUserInput)
	            movementVec.multiplyScalar(0);
	        let inputStrength = movementVec.length();
	        // Rotate the vector accordingly
	        movementVec.multiplyScalar(MARBLE_ROLL_FORCE * 5 * dt);
	        movementVec.applyAxisAngle(new Vector3(0, 0, 1), this.level.yaw);
	        let quat = this.level.newOrientationQuat;
	        movementVec.applyQuaternion(quat);
	        this.lastMovementVec.copy(movementVec);
	        // The axis of rotation (for angular velocity) is the cross product of the current up vector and the movement vector, since the axis of rotation is perpendicular to both.
	        let movementRotationAxis = this.level.currentUp.clone().cross(movementVec);
	        let bestCollision = this.findBestCollision(c => c.normal.dot(this.level.currentUp));
	        if (bestCollision) {
	            let { collision, contactNormal, contactNormalUpDot } = bestCollision;
	            // The rotation necessary to get from the up vector to the contact normal.
	            let contactNormalRotation = new Quaternion().setFromUnitVectors(this.level.currentUp, contactNormal);
	            movementRotationAxis.applyQuaternion(contactNormalRotation);
	            // Weaken the marble's angular power based on the friction and steepness of the surface
	            let dot = -movementVec.clone().normalize().dot(contactNormal);
	            let penalty = Math.max(0, dot - Math.max(0, (collision.s2Friction - 1.0)));
	            movementRotationAxis.multiplyScalar(1 - penalty);
	            // Apply angular velocity changes
	            let angVel = this.body.angularVelocity;
	            // Subtract the movement axis so it doesn't get slowed down
	            let direction = movementRotationAxis.clone().normalize();
	            let dot2 = Math.max(0, angVel.dot(direction));
	            angVel.addScaledVector(direction, -dot2);
	            // Subtract the "surface rotation axis", this ensures we can roll down hills quickly
	            let surfaceRotationAxis = this.level.currentUp.clone().cross(contactNormal);
	            let dot3 = Math.max(angVel.dot(surfaceRotationAxis), 0);
	            angVel.addScaledVector(surfaceRotationAxis, -dot3);
	            angVel.multiplyScalar(0.02 ** (Math.min(1, collision.friction) * dt)); // Handle velocity slowdown
	            // Add them back
	            angVel.addScaledVector(surfaceRotationAxis, dot3);
	            angVel.addScaledVector(direction, dot2);
	            if (angVel.length() > 300 * this.speedFac)
	                angVel.multiplyScalar(300 * this.speedFac / angVel.length()); // Absolute max angular speed
	            if (dot2 + movementRotationAxis.length() > 12 * Math.PI * 2 * inputStrength / contactNormalUpDot * this.speedFac) {
	                // Cap the rolling velocity
	                let newLength = Math.max(0, 12 * Math.PI * 2 * inputStrength / contactNormalUpDot * this.speedFac - dot2);
	                movementRotationAxis.normalize().multiplyScalar(newLength);
	            }
	        }
	        else {
	            // Handle airborne movement
	            // Angular acceleration isn't quite as speedy
	            movementRotationAxis.multiplyScalar(1 / 2);
	            let time = this.level.timeState;
	            let airMovementVector = movementVec.clone();
	            let airVelocity = (time.currentAttemptTime - this.helicopterEnableTime) < 5000 ? 5 : 3.2; // Change air velocity for the helicopter
	            if (this.level.finishTime)
	                airVelocity = 0;
	            airMovementVector.multiplyScalar(airVelocity * dt);
	            //this.body.addLinearVelocity(airMovementVector);
	            this.body.linearVelocity.add(airMovementVector);
	            this.slidingSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	            this.rollingSound.gain.gain.linearRampToValueAtTime(0, this.level.audio.currentTime + 0.02);
	            (_a = this.rollingMegaMarbleSound) === null || _a === void 0 ? void 0 : _a.gain.gain.linearRampToValueAtTime(0, this.level.audio.currentTime + 0.02);
	        }
	        movementRotationAxis.multiplyScalar(this.speedFac);
	        // Apply angular acceleration, but make sure the angular velocity doesn't exceed some maximum
	        Util.addToVectorCapped(this.body.angularVelocity, movementRotationAxis, 120 * this.speedFac);
	        if (this.level.finishTime)
	            this.body.linearVelocity.multiplyScalar(0.9);
	        if (allowUserInput && this.level.heldPowerUp && (isPressed('use') || this.level.useQueued) && getPressedFlag('use')) {
	            this.level.replay.recordUsePowerUp(this.level.heldPowerUp);
	            this.level.heldPowerUp.use(0);
	            this.level.useQueued = false;
	        }
	        if (allowUserInput && (isPressed('blast') || this.level.blastQueued) && getPressedFlag('blast')) {
	            this.useBlast();
	            this.level.blastQueued = false;
	        }
	        this.slidingTimeout--;
	    }
	    onAfterIntegrate() {
	        // We'll need these for collision response lata
	        this.beforeVel.copy(this.body.linearVelocity);
	        this.beforeAngVel.copy(this.body.angularVelocity);
	        let time = this.level.timeState;
	        let playReplay = this.level.replay.mode === 'playback';
	        if (time.currentAttemptTime < GO_TIME && !playReplay) {
	            // Lock the marble to the space above the start pad
	            let { position: startPosition } = this.level.getStartPositionAndOrientation();
	            let position = this.body.position;
	            position.x = startPosition.x;
	            position.y = startPosition.y;
	            let vel = this.body.linearVelocity;
	            vel.x = vel.y = 0;
	            let angVel = this.body.angularVelocity;
	            // Cap the angular velocity so it doesn't go haywire
	            if (angVel.length() > 60)
	                angVel.normalize().multiplyScalar(60);
	            this.shape.friction = 0;
	        }
	        else {
	            this.shape.friction = 1;
	        }
	    }
	    onBeforeCollisionResponse() {
	        // Nothing.
	    }
	    onAfterCollisionResponse() {
	        var _a, _b, _c;
	        let bestCollision = this.findBestCollision(c => c.normal.dot(this.level.currentUp));
	        if (!bestCollision)
	            return;
	        let { collision, contactNormal, contactShape, contactNormalUpDot } = bestCollision;
	        this.lastContactNormal.copy(contactNormal);
	        let lastSurfaceRelativeVelocity = this.beforeVel.clone().sub(contactShape.body.linearVelocity);
	        let surfaceRelativeVelocity = this.body.linearVelocity.clone().sub(contactShape.body.linearVelocity);
	        let maxDotSlide = 0.5; // 30°
	        // Implements sliding: If we hit the surface at an angle below 45°, and have movement keys pressed, we don't bounce.
	        let dot0 = -contactNormal.dot(lastSurfaceRelativeVelocity.clone().normalize());
	        let slidinigEligible = contactNormalUpDot > 0.1; // Kinda arbitrary rn, it's about 84°, definitely makes sure we don't slide on walls
	        if (slidinigEligible && this.slidingTimeout <= 0 && dot0 > 0.001 && dot0 <= maxDotSlide && this.lastMovementVec.length() > 0) {
	            let dot = contactNormal.dot(surfaceRelativeVelocity);
	            let linearVelocity = this.body.linearVelocity;
	            let originalLength = linearVelocity.length();
	            linearVelocity.addScaledVector(contactNormal, -dot); // Remove all velocity in the direction of the surface normal
	            let newLength = linearVelocity.length();
	            let diff = originalLength - newLength;
	            linearVelocity.normalize().multiplyScalar(newLength + diff * 2); // Give a small speedboost
	        }
	        // If we're using a shock absorber or we're on a low-restitution surface, give the marble a velocity boost on contact based on its angular velocity.
	        outer: if (collision.restitution < 0.5) {
	            let dot = -this.beforeVel.dot(contactNormal);
	            if (dot < 0)
	                break outer;
	            let boost = this.beforeAngVel.clone().cross(contactNormal).multiplyScalar(2 * (0.5 - collision.restitution) * dot / 300 / 0.98); // 0.98 fac because shock absorber used to have 0 rest but now 0.01
	            this.body.linearVelocity.add(boost);
	        }
	        // Create a certain velocity boost on collisions with walls based on angular velocity. This assists in making wall-hits feel more natural.
	        let angularBoost = this.body.angularVelocity.clone().cross(contactNormal).multiplyScalar((1 - Math.abs(contactNormalUpDot)) * contactNormal.dot(this.body.linearVelocity) / (Math.PI * 2) / 15);
	        if (angularBoost.length() >= 0.01) {
	            // Remove a bit of the current velocity so that the response isn't too extreme
	            let currentVelocity = this.body.linearVelocity;
	            let ratio = angularBoost.length() / currentVelocity.length();
	            currentVelocity.multiplyScalar(1 / (1 + ratio * 0.5)).add(angularBoost);
	        }
	        // Handle jumping
	        if (contactNormalUpDot > 1e-6 && !state.menu.finishScreen.showing && (isPressed('jump') || this.level.jumpQueued)) {
	            this.setLinearVelocityInDirection(contactNormal, this.jumpImpulse + contactShape.body.linearVelocity.dot(contactNormal), true, () => {
	                this.playJumpSound();
	                if (this.level.replay.canStore)
	                    this.level.replay.jumpSoundTimes.push(this.level.replay.currentTickIndex);
	            });
	            this.level.jumpQueued = false;
	        }
	        // Create bounce particles
	        let mostPowerfulCollision = this.findBestCollision(c => {
	            return -c.normal.dot(this.beforeVel.clone().sub(c.s2.body.linearVelocity));
	        });
	        let impactVelocity = -mostPowerfulCollision.contactNormal.dot(this.beforeVel.clone().sub(contactShape.body.linearVelocity));
	        if (impactVelocity > 6)
	            this.showBounceParticles();
	        // Handle bounce sound
	        let volume = Util.clamp((impactVelocity / 12) ** 1.5, 0, 1);
	        if (impactVelocity > 1) {
	            // Play a collision impact sound
	            this.playBounceSound(volume);
	            if (this.level.replay.canStore)
	                this.level.replay.bounceTimes.push({ tickIndex: this.level.replay.currentTickIndex, volume: volume, showParticles: impactVelocity > 6 });
	        }
	        // Handle rolling and sliding sounds
	        if (contactNormal.dot(surfaceRelativeVelocity) < 0.01) {
	            let predictedMovement = this.body.angularVelocity.clone().cross(this.level.currentUp).multiplyScalar(1 / Math.PI / 2);
	            // The expected movement based on the current angular velocity. If actual movement differs too much, we consider the marble to be "sliding".
	            if (predictedMovement.dot(surfaceRelativeVelocity) < -0.00001 || (predictedMovement.length() > 0.5 && predictedMovement.length() > surfaceRelativeVelocity.length() * 1.5)) {
	                this.slidingSound.gain.gain.setValueAtTime(0.6, this.level.audio.currentTime);
	                this.rollingSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	                if (this.rollingMegaMarbleSound)
	                    this.rollingMegaMarbleSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	            }
	            else {
	                this.slidingSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	                let pitch = Util.clamp(surfaceRelativeVelocity.length() / 15, 0, 1) * 0.75 + 0.75;
	                this.rollingSound.gain.gain.linearRampToValueAtTime(Util.clamp(pitch - 0.75, 0, 1), this.level.audio.currentTime + 0.02);
	                (_a = this.rollingMegaMarbleSound) === null || _a === void 0 ? void 0 : _a.gain.gain.linearRampToValueAtTime(Util.clamp(pitch - 0.75, 0, 1), this.level.audio.currentTime + 0.02);
	                this.rollingSound.setPlaybackRate(pitch);
	                (_b = this.rollingMegaMarbleSound) === null || _b === void 0 ? void 0 : _b.setPlaybackRate(pitch);
	            }
	        }
	        else {
	            this.slidingSound.gain.gain.setValueAtTime(0, this.level.audio.currentTime);
	            this.rollingSound.gain.gain.linearRampToValueAtTime(0, this.level.audio.currentTime + 0.02);
	            (_c = this.rollingMegaMarbleSound) === null || _c === void 0 ? void 0 : _c.gain.gain.linearRampToValueAtTime(0, this.level.audio.currentTime + 0.02);
	        }
	    }
	    tick(time) {
	        var _a, _b, _c, _d, _e, _f;
	        if (time.currentAttemptTime - this.shockAbsorberEnableTime < 5000) {
	            // Show the shock absorber (takes precedence over super bounce)
	            this.forcefield.setOpacity(1);
	            this.shape.restitution = 0.01; // Yep it's not actually zero
	            if (!this.shockAbsorberSound) {
	                this.shockAbsorberSound = this.level.audio.createAudioSource('superbounceactive.wav');
	                this.shockAbsorberSound.setLoop(true);
	                this.shockAbsorberSound.play();
	            }
	        }
	        else if (time.currentAttemptTime - this.superBounceEnableTime < 5000) {
	            // Show the super bounce
	            this.forcefield.setOpacity(1);
	            this.shape.restitution = 0.9;
	            (_a = this.shockAbsorberSound) === null || _a === void 0 ? void 0 : _a.stop();
	            this.shockAbsorberSound = null;
	        }
	        else {
	            // Stop both shock absorber and super bounce
	            this.forcefield.setOpacity(0);
	            this.shape.restitution = this.bounceRestitution;
	            (_b = this.shockAbsorberSound) === null || _b === void 0 ? void 0 : _b.stop();
	            this.shockAbsorberSound = null;
	            (_c = this.superBounceSound) === null || _c === void 0 ? void 0 : _c.stop();
	            this.superBounceSound = null;
	        }
	        if (time.currentAttemptTime - this.superBounceEnableTime < 5000 && !this.superBounceSound) {
	            // Play the super bounce sound
	            this.superBounceSound = this.level.audio.createAudioSource('forcefield.wav');
	            this.superBounceSound.setLoop(true);
	            this.superBounceSound.play();
	        }
	        if (time.currentAttemptTime - this.helicopterEnableTime < 5000) {
	            // Show the helicopter
	            this.helicopter.setOpacity(1);
	            this.helicopter.setTransform(new Vector3(0, 0, this.radius - DEFAULT_RADIUS).applyQuaternion(this.level.newOrientationQuat), this.level.newOrientationQuat, new Vector3(1, 1, 1));
	            this.level.setGravityIntensity(this.level.defaultGravity * 0.25);
	            if (!this.helicopterSound) {
	                this.helicopterSound = this.level.audio.createAudioSource('use_gyrocopter.wav');
	                this.helicopterSound.setLoop(true);
	                this.helicopterSound.play();
	            }
	        }
	        else {
	            // Stop the helicopter
	            this.helicopter.setOpacity(0);
	            this.level.setGravityIntensity(this.level.defaultGravity);
	            (_d = this.helicopterSound) === null || _d === void 0 ? void 0 : _d.stop();
	            this.helicopterSound = null;
	        }
	        if (this.radius !== MEGA_MARBLE_RADIUS && time.currentAttemptTime - this.megaMarbleEnableTime < 10000) {
	            this.setRadius(MEGA_MARBLE_RADIUS);
	            this.body.linearVelocity.addScaledVector(this.level.currentUp, 6); // There's a small yeet upwards
	            this.rollingSound.stop();
	            (_e = this.rollingMegaMarbleSound) === null || _e === void 0 ? void 0 : _e.play();
	        }
	        else if (time.currentAttemptTime - this.megaMarbleEnableTime >= 10000) {
	            this.setRadius(this.level.mission.hasUltraMarble ? ULTRA_RADIUS : DEFAULT_RADIUS);
	            this.rollingSound.play();
	            (_f = this.rollingMegaMarbleSound) === null || _f === void 0 ? void 0 : _f.stop();
	        }
	    }
	    playJumpSound() {
	        this.level.audio.play(['jump.wav']);
	    }
	    playBounceSound(volume) {
	        let prefix = (this.radius === MEGA_MARBLE_RADIUS) ? 'mega_' : '';
	        this.level.audio.play(['bouncehard1.wav', 'bouncehard2.wav', 'bouncehard3.wav', 'bouncehard4.wav'].map(x => prefix + x), volume);
	    }
	    showBounceParticles() {
	        this.level.particles.createEmitter(bounceParticleOptions, this.body.position, null, new Vector3(1, 1, 1).addScaledVector(Util.absVector(this.level.currentUp.clone()), -0.8));
	    }
	    /** Sets linear velocity in a specific direction, but capped. Used for things like jumping and bumpers. */
	    setLinearVelocityInDirection(direction, magnitude, onlyIncrease, onIncrease = () => { }) {
	        let unitVelocity = this.body.linearVelocity.clone().normalize();
	        let dot = unitVelocity.dot(direction);
	        let directionalSpeed = dot * this.body.linearVelocity.length();
	        if (directionalSpeed < magnitude || !onlyIncrease) {
	            let velocity = this.body.linearVelocity;
	            velocity.addScaledVector(direction, -directionalSpeed);
	            velocity.addScaledVector(direction, magnitude);
	            if (directionalSpeed < magnitude)
	                onIncrease();
	        }
	    }
	    /** Predicts the position of the marble in the next physics tick to allow for smooth, interpolated rendering. */
	    calculatePredictiveTransforms() {
	        var _a;
	        let pos = this.body.position;
	        let orientation = this.body.orientation;
	        let linVel = this.body.linearVelocity;
	        let angVel = this.body.angularVelocity;
	        // Naive: Just assume the marble moves as if nothing was in its way and it continued with its current velocity.
	        let predictedPosition = pos.clone().addScaledVector(linVel, 1 / PHYSICS_TICK_RATE).addScaledVector(this.level.world.gravity, 1 / PHYSICS_TICK_RATE ** 2 / 2);
	        let movementDiff = predictedPosition.clone().sub(pos);
	        let dRotation = angVel.clone().multiplyScalar(1 / PHYSICS_TICK_RATE);
	        let dRotationLength = dRotation.length();
	        let dq = new Quaternion().setFromAxisAngle(dRotation.normalize(), dRotationLength);
	        let predictedOrientation = dq.multiply(orientation);
	        // See if we hit something, do this to prevent clipping through things
	        let hits = this.level.world.castShape(this.shape, movementDiff, 1);
	        let hit = hits.find(x => !this.body.collisions.some(y => y.s2 === x.shape)); // Filter out hits with shapes we're already touching
	        let lambda = (_a = hit === null || hit === void 0 ? void 0 : hit.lambda) !== null && _a !== void 0 ? _a : 1;
	        this.predictedPosition.lerpVectors(pos, predictedPosition, lambda);
	        this.predictedOrientation.copy(orientation).slerp(predictedOrientation, lambda);
	    }
	    render(time) {
	        // Position based on current and predicted position and orientation
	        this.group.position.copy(this.body.position).lerp(this.predictedPosition, time.physicsTickCompletion);
	        this.innerGroup.orientation.copy(this.body.orientation).slerp(this.predictedOrientation, time.physicsTickCompletion);
	        this.group.recomputeTransform();
	        this.innerGroup.recomputeTransform();
	        this.forcefield.render(time);
	        if (time.currentAttemptTime - this.helicopterEnableTime < 5000)
	            this.helicopter.render(time);
	        // Update the teleporting look:
	        let teleportFadeCompletion = 0;
	        if (this.teleportEnableTime !== null)
	            teleportFadeCompletion = Util.clamp((time.currentAttemptTime - this.teleportEnableTime) / TELEPORT_FADE_DURATION, 0, 1);
	        if (this.teleportDisableTime !== null)
	            teleportFadeCompletion = Util.clamp(1 - (time.currentAttemptTime - this.teleportDisableTime) / TELEPORT_FADE_DURATION, 0, 1);
	        if (teleportFadeCompletion > 0) {
	            this.sphere.opacity = Util.lerp(1, 0.25, teleportFadeCompletion);
	        }
	        else {
	            this.sphere.opacity = Number(!this.ballShape);
	        }
	    }
	    renderReflection() {
	        if (!this.isReflective())
	            return;
	        this.cubeCamera.position.copy(this.group.position);
	        this.cubeMap.render(this.level.scene, this.cubeCamera, 4);
	    }
	    enableSuperBounce(time) {
	        this.superBounceEnableTime = time.currentAttemptTime;
	    }
	    enableShockAbsorber(time) {
	        this.shockAbsorberEnableTime = time.currentAttemptTime;
	    }
	    enableHelicopter(time) {
	        this.helicopterEnableTime = time.currentAttemptTime;
	    }
	    enableTeleportingLook(time) {
	        let completion = (this.teleportDisableTime !== null) ? Util.clamp((time.currentAttemptTime - this.teleportDisableTime) / TELEPORT_FADE_DURATION, 0, 1) : 1;
	        this.teleportEnableTime = time.currentAttemptTime - TELEPORT_FADE_DURATION * (1 - completion);
	        this.teleportDisableTime = null;
	    }
	    disableTeleportingLook(time) {
	        var _a;
	        let completion = (_a = Util.clamp((time.currentAttemptTime - this.teleportEnableTime) / TELEPORT_FADE_DURATION, 0, 1)) !== null && _a !== void 0 ? _a : 1;
	        this.teleportDisableTime = time.currentAttemptTime - TELEPORT_FADE_DURATION * (1 - completion);
	        this.teleportEnableTime = null;
	    }
	    enableMegaMarble(time) {
	        this.megaMarbleEnableTime = time.currentAttemptTime;
	    }
	    useBlast() {
	        if (this.level.blastAmount < 0.2 || !this.level.mission.hasBlast)
	            return;
	        let impulse = this.level.currentUp.clone().multiplyScalar(Math.max(Math.sqrt(this.level.blastAmount), this.level.blastAmount) * 10);
	        this.body.linearVelocity.add(impulse);
	        this.level.audio.play('blast.wav');
	        this.level.particles.createEmitter((this.level.blastAmount > 1) ? blastMaxParticleOptions : blastParticleOptions, null, () => this.body.position.clone().addScaledVector(this.level.currentUp, -this.radius * 0.4), new Vector3(1, 1, 1).addScaledVector(Util.absVector(this.level.currentUp.clone()), -0.8));
	        this.level.blastAmount = 0;
	        this.level.replay.recordUseBlast();
	    }
	    /** Updates the radius of the marble both visually and physically. */
	    setRadius(radius) {
	        var _a;
	        if (this.radius === radius)
	            return;
	        this.radius = radius;
	        this.sphere.scale.setScalar(radius);
	        this.sphere.recomputeTransform();
	        (_a = this.ballShape) === null || _a === void 0 ? void 0 : _a.setTransform(new Vector3(), new Quaternion(), new Vector3().setScalar(radius / DEFAULT_RADIUS));
	        this.shape.radius = radius;
	        this.shape.updateInertiaTensor();
	        this.largeAuxShape.radius = 2 * radius;
	        this.smallAuxShape.radius = radius;
	        this.body.syncShapes();
	        this.forcefield.group.scale.setScalar(this.radius / DEFAULT_RADIUS);
	        this.forcefield.group.recomputeTransform();
	    }
	    reset() {
	        this.body.linearVelocity.setScalar(0);
	        this.body.angularVelocity.setScalar(0);
	        this.superBounceEnableTime = -Infinity;
	        this.shockAbsorberEnableTime = -Infinity;
	        this.helicopterEnableTime = -Infinity;
	        this.teleportEnableTime = null;
	        this.teleportDisableTime = null;
	        this.megaMarbleEnableTime = -Infinity;
	        this.lastContactNormal.set(0, 0, 0);
	        this.beforeVel.set(0, 0, 0);
	        this.beforeAngVel.set(0, 0, 0);
	        this.slidingTimeout = 0;
	        this.predictedPosition.copy(this.body.position);
	        this.predictedOrientation.copy(this.body.orientation);
	        this.setRadius(this.level.mission.hasUltraMarble ? ULTRA_RADIUS : DEFAULT_RADIUS);
	    }
	    dispose() {
	        var _a;
	        (_a = this.cubeMap) === null || _a === void 0 ? void 0 : _a.dispose();
	    }
	}

	/** The starting location of the level. */
	class StartPad extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/pads/startarea.dts";
	    }
	}

	/** The flickering finish sign, usually above the finish pad. */
	class SignFinish extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/signs/finishlinesign.dts";
	    }
	}

	/** A plain sign showing a direction. */
	class SignPlain extends Shape {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/signs/plainsign.dts";
	        this.shareMaterials = false;
	        // Determine the direction to show
	        let direction = element.datablock.slice("SignPlain".length).toLowerCase();
	        switch (direction) {
	            case "right":
	                this.matNamesOverride["base.plainsign"] = "right.plainsign";
	                break;
	            case "left":
	                this.matNamesOverride["base.plainsign"] = "left.plainsign";
	                break;
	            case "up":
	                this.matNamesOverride["base.plainsign"] = "up.plainsign";
	                break;
	            case "down":
	                this.matNamesOverride["base.plainsign"] = "down.plainsign";
	                break;
	        }
	    }
	}

	/** The finish pad. */
	class EndPad extends Shape {
	    /** @param isMain Whether or not this pad is the main pad, meaning it has to be touched for the level to end. All other pads are purely cosmetic. */
	    constructor(isMain) {
	        super();
	        this.dtsPath = "shapes/pads/endarea.dts";
	        this.fireworks = [];
	        this.sounds = ['firewrks.wav'];
	        this.inArea = 0; // Used to only trigger the event once
	        if (!isMain)
	            return;
	        // Create the finish area collision geometry
	        let height = 4.8;
	        let radius = 1.7;
	        let transform = new Matrix4();
	        transform.compose(new Vector3(0, 0, height / 2 + 0.2), new Quaternion().setFromEuler(new Euler(-Math.PI / 2, 0, 0)), new Vector3(1, 1, 1));
	        this.addCollider((scale) => {
	            // Create the finish area collision geometry
	            // Scaling note: The actual height of the cylinder (here: the y scaling) doesn't change, it's always the same.
	            let finishArea = Util.createCylinderConvexHull(radius, height / 2, 64, new Vector3(scale.x, 1, scale.y));
	            finishArea.margin = 0.005; // OIMO had a margin of 0.005 on every shape. We somewhat try to correct for that by adding it back here.
	            return finishArea;
	        }, (t) => {
	            // These checks are to make sure touchFinish is only called once per contact with the collider. For it to be called again, the marble must leave the area again.
	            let exit = this.inArea > 0;
	            this.inArea = 2;
	            if (exit)
	                return;
	            this.level.touchFinish(t);
	        }, transform);
	    }
	    /** Starts the finish celebration firework at a given time. */
	    spawnFirework(time) {
	        let firework = new Firework(this.level, this.worldPosition, time.timeSinceLoad);
	        this.fireworks.push(firework);
	        this.level.audio.play(this.sounds[0], 1, undefined, this.worldPosition);
	    }
	    tick(time, onlyVisual) {
	        if (onlyVisual)
	            return;
	        super.tick(time);
	        // Tick the firework
	        for (let firework of this.fireworks.slice()) {
	            firework.tick(time.timeSinceLoad);
	            if (time.timeSinceLoad - firework.spawnTime >= 10000)
	                Util.removeFromArray(this.fireworks, firework); // We can safely remove the firework
	        }
	        this.inArea--;
	    }
	}
	/** The ambient smoke coming up from the finish pad. */
	const fireworkSmoke = {
	    ejectionPeriod: 100,
	    ambientVelocity: new Vector3(0, 0, 1),
	    ejectionVelocity: 0,
	    velocityVariance: 0,
	    emitterLifetime: 4000,
	    spawnOffset() {
	        let randomPointInCircle = Util.randomPointInUnitCircle();
	        return new Vector3(randomPointInCircle.x * 1.6, randomPointInCircle.y * 1.6, Math.random() * 0.4 - 0.5);
	    },
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/saturn.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 0,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 2000,
	        lifetimeVariance: 200,
	        dragCoefficient: 0.5,
	        acceleration: 0,
	        colors: [{ r: 1, g: 1, b: 0, a: 0 }, { r: 1, g: 0, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 0 }],
	        sizes: [0.1, 0.2, 0.3],
	        times: [0, 0.2, 1]
	    }
	};
	/** The trail of the red rockets. */
	const redTrail = {
	    ejectionPeriod: 30,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 0,
	    velocityVariance: 0,
	    emitterLifetime: 10000,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 0,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 600,
	        lifetimeVariance: 100,
	        dragCoefficient: 0,
	        acceleration: 0,
	        colors: [{ r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 0 }],
	        sizes: [0.1, 0.05, 0.01],
	        times: [0, 0.5, 1]
	    }
	};
	/** The trail of the blue rockets. */
	const blueTrail = {
	    ejectionPeriod: 30,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 0,
	    velocityVariance: 0,
	    emitterLifetime: 10000,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 0,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 600,
	        lifetimeVariance: 100,
	        dragCoefficient: 0,
	        acceleration: 0,
	        colors: [{ r: 0, g: 0, b: 1, a: 1 }, { r: 0.5, g: 0.5, b: 1, a: 1 }, { r: 1, g: 1, b: 1, a: 0 }],
	        sizes: [0.1, 0.05, 0.01],
	        times: [0, 0.5, 1]
	    }
	};
	/** The explosion effect of the red rockets. */
	const redSpark = {
	    ejectionPeriod: 1,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 0.8,
	    velocityVariance: 0.25,
	    emitterLifetime: 10,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/star.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 500,
	        lifetimeVariance: 50,
	        dragCoefficient: 0.5,
	        acceleration: 0,
	        colors: [{ r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 0 }],
	        sizes: [0.2, 0.2, 0.2],
	        times: [0, 0.5, 1]
	    }
	};
	/** The explosion effect of the blue rockets. */
	const blueSpark = {
	    ejectionPeriod: 1,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 0.5,
	    velocityVariance: 0.25,
	    emitterLifetime: 10,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/bubble.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 2000,
	        lifetimeVariance: 200,
	        dragCoefficient: 0,
	        acceleration: 0,
	        colors: [{ r: 0, g: 0, b: 1, a: 1 }, { r: 0.5, g: 0.5, b: 1, a: 1 }, { r: 1, g: 1, b: 1, a: 0 }],
	        sizes: [0.2, 0.2, 0.2],
	        times: [0, 0.5, 1]
	    }
	};
	/** Handles the firework animation that plays on the finish pad upon level completion. */
	class Firework extends Scheduler {
	    constructor(level, pos, spawnTime) {
	        super();
	        this.trails = [];
	        /** The fireworks are spawned in waves, this controls how many are left. */
	        this.wavesLeft = 4;
	        this.level = level;
	        this.pos = pos;
	        this.spawnTime = spawnTime;
	        this.level.particles.createEmitter(fireworkSmoke, this.pos); // Start the smoke
	        this.doWave(this.spawnTime); // Start the first wave
	    }
	    tick(time) {
	        this.tickSchedule(time);
	        // Update the trails
	        for (let trail of this.trails.slice()) {
	            let completion = Util.clamp((time - trail.spawnTime) / trail.lifetime, 0, 1);
	            completion = 1 - (1 - completion) ** 2; // ease-out
	            // Make the trail travel along an arc (parabola, whatever)
	            let pos = this.pos.clone().multiplyScalar(1 - completion).add(trail.targetPos.clone().multiplyScalar(completion));
	            pos.sub(new Vector3(0, 0, 1).multiplyScalar(completion ** 2));
	            trail.smokeEmitter.setPos(pos, time);
	            if (completion === 1) {
	                // The trail has reached its end, remove the emitter and spawn the explosion.
	                this.level.particles.removeEmitter(trail.smokeEmitter);
	                Util.removeFromArray(this.trails, trail);
	                if (trail.type === 'red') {
	                    this.level.particles.createEmitter(redSpark, pos);
	                }
	                else {
	                    this.level.particles.createEmitter(blueSpark, pos);
	                }
	            }
	        }
	    }
	    /** Spawns a bunch of trails going in random directions. */
	    doWave(time) {
	        let count = Math.floor(17 + Math.random() * 10);
	        for (let i = 0; i < count; i++)
	            this.spawnTrail(time);
	        this.wavesLeft--;
	        if (this.wavesLeft > 0) {
	            let nextWaveTime = time + 500 + 1000 * Math.random();
	            this.schedule(nextWaveTime, () => this.doWave(nextWaveTime));
	        }
	    }
	    /** Spawns a red or blue trail going in a random direction with a random speed. */
	    spawnTrail(time) {
	        let type = (Math.random() < 0.5) ? 'red' : 'blue';
	        let lifetime = 250 + Math.random() * 2000;
	        let distanceFac = 0.5 + lifetime / 5000; // Make sure the firework doesn't travel a great distance way too quickly
	        let emitter = this.level.particles.createEmitter((type === 'red') ? redTrail : blueTrail, this.pos);
	        let randomPointInCircle = Util.randomPointInUnitCircle();
	        let targetPos = new Vector3(randomPointInCircle.x * 3, randomPointInCircle.y * 3, 1 + Math.sqrt(Math.random()) * 3).multiplyScalar(distanceFac).add(this.pos);
	        let trail = {
	            type: type,
	            smokeEmitter: emitter,
	            targetPos: targetPos,
	            spawnTime: time,
	            lifetime: lifetime
	        };
	        this.trails.push(trail);
	    }
	}

	// List all of gem colors for randomly choosing one
	const GEM_COLORS = ["blue", "red", "yellow", "purple", "green", "turquoise", "orange", "black"]; // "Platinum" is also a color, but it can't appear by chance
	/** Gems need to be collected before being able to finish. */
	class Gem extends Shape {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/items/gem.dts";
	        this.ambientRotate = true;
	        this.collideable = false;
	        this.pickedUp = false;
	        this.shareMaterials = false;
	        this.showSequences = false; // Gems actually have an animation for the little shiny thing, but the actual game ignores that. I get it, it was annoying as hell.
	        this.sounds = ['gotgem.wav', 'gotallgems.wav', 'missinggems.wav'];
	        // Determine the color of the gem:
	        let color = element.datablock.slice("GemItem".length);
	        if (color.length === 0)
	            color = Gem.pickRandomColor(); // Random if no color specified
	        this.matNamesOverride["base.gem"] = color.toLowerCase() + ".gem";
	    }
	    onMarbleInside(t) {
	        if (this.pickedUp)
	            return;
	        this.pickedUp = true;
	        this.setOpacity(0); // Hide the gem
	        this.level.pickUpGem(t);
	        this.level.replay.recordMarbleInside(this);
	        this.setCollisionEnabled(false);
	    }
	    reset() {
	        super.reset();
	        this.pickedUp = false;
	        this.setOpacity(1);
	        this.setCollisionEnabled(true);
	    }
	    static pickRandomColor() {
	        return Util.randomFromArray(GEM_COLORS);
	    }
	}

	const DEFAULT_COOLDOWN_DURATION = 7000;
	/** Powerups can be collected and used by the player for bonus effects. */
	class PowerUp extends Shape {
	    constructor(element) {
	        super();
	        this.lastPickUpTime = null;
	        /** Reappears after this time. */
	        this.cooldownDuration = DEFAULT_COOLDOWN_DURATION;
	        /** Whether or not to automatically use the powerup instantly on pickup. */
	        this.autoUse = false;
	        this.ambientRotate = true;
	        this.collideable = false;
	        this.shareMaterials = false;
	        /** Overrides the full pick up alert string. */
	        this.customPickUpAlert = null;
	        /** If 'an' should be used instead of 'a' in the pickup alert. */
	        this.an = false;
	        this.element = element;
	    }
	    onMarbleInside(t) {
	        var _a;
	        let time = this.level.timeState;
	        let pickupable = this.lastPickUpTime === null || (time.currentAttemptTime - this.lastPickUpTime) >= this.cooldownDuration;
	        if (!pickupable)
	            return;
	        if (this.pickUp()) {
	            this.level.replay.recordMarbleInside(this);
	            this.lastPickUpTime = time.currentAttemptTime;
	            if (this.autoUse)
	                this.use(t);
	            state.menu.hud.displayAlert((_a = this.customPickUpAlert) !== null && _a !== void 0 ? _a : `You picked up ${this.an ? 'an' : 'a'} ${this.pickUpName}!`);
	            if (this.element.showhelponpickup === "1" && !this.autoUse)
	                state.menu.hud.displayHelp(`Press <func:bind mousefire> to use the ${this.pickUpName}!`);
	            let body = this.bodies[0];
	            body.enabled = false;
	        }
	    }
	    tick(time, onlyVisual) {
	        super.tick(time, onlyVisual);
	        if (onlyVisual)
	            return;
	        // Enable or disable the collision based on the last pick-up time time
	        let pickupable = this.lastPickUpTime === null || (time.currentAttemptTime - this.lastPickUpTime) >= this.cooldownDuration;
	        this.setCollisionEnabled(pickupable);
	    }
	    render(time) {
	        super.render(time);
	        let opacity = 1;
	        if (this.lastPickUpTime && this.cooldownDuration > 0) {
	            let availableTime = this.lastPickUpTime + this.cooldownDuration;
	            opacity = Util.clamp((time.currentAttemptTime - availableTime) / 1000, 0, 1);
	        }
	        this.setOpacity(opacity);
	    }
	    reset() {
	        super.reset();
	        let body = this.bodies[0];
	        body.enabled = true;
	        this.lastPickUpTime = null;
	    }
	}

	/** Gives the marble an upwards boost. */
	class SuperJump extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/superjump.dts";
	        this.pickUpName = (state.modification === 'gold') ? "Super Jump PowerUp" : "Jump Boost PowerUp";
	        this.sounds = ["pusuperjumpvoice.wav", "dosuperjump.wav"];
	    }
	    pickUp() {
	        return this.level.pickUpPowerUp(this);
	    }
	    use() {
	        let marble = this.level.marble;
	        marble.body.linearVelocity.addScaledVector(this.level.currentUp, 20); // Simply add to vertical velocity
	        this.level.audio.play(this.sounds[1]);
	        this.level.particles.createEmitter(superJumpParticleOptions, null, () => marble.body.position.clone());
	        this.level.deselectPowerUp();
	    }
	}
	const superJumpParticleOptions = {
	    ejectionPeriod: 10,
	    ambientVelocity: new Vector3(0, 0, 0.05),
	    ejectionVelocity: 1 * 0.5,
	    velocityVariance: 0.25 * 0.5,
	    emitterLifetime: 1000,
	    inheritedVelFactor: 0.1,
	    particleOptions: {
	        texture: 'particles/twirl.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 90,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1000,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.25,
	        acceleration: 0,
	        colors: [{ r: 0, g: 0.5, b: 1, a: 0 }, { r: 0, g: 0.6, b: 1, a: 1 }, { r: 0, g: 0.6, b: 1, a: 0 }],
	        sizes: [0.25, 0.25, 0.5],
	        times: [0, 0.75, 1]
	    }
	};

	/** A caution/danger sign. */
	class SignCaution extends Shape {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/signs/cautionsign.dts";
	        this.shareMaterials = false;
	        // Determine the type of the sign
	        let type = element.datablock.slice("SignCaution".length).toLowerCase();
	        switch (type) {
	            case "caution":
	                this.matNamesOverride["base.cautionsign"] = "caution.cautionsign";
	                break;
	            case "danger":
	                this.matNamesOverride["base.cautionsign"] = "danger.cautionsign";
	                break;
	        }
	    }
	}

	/** Temporarily increase marble restitution. */
	class SuperBounce extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/superbounce.dts";
	        this.pickUpName = (state.modification === 'gold') ? "Super Bounce PowerUp" : "Marble Recoil PowerUp";
	        this.sounds = ["pusuperbouncevoice.wav", "forcefield.wav"];
	    }
	    pickUp() {
	        return this.level.pickUpPowerUp(this);
	    }
	    use() {
	        this.level.marble.enableSuperBounce(this.level.timeState);
	        this.level.deselectPowerUp();
	    }
	}

	/** A bumper is a shape which knocks the marble away on contact. */
	class AbstractBumper extends Shape {
	    constructor() {
	        super(...arguments);
	        this.wiggleAnimationStart = -Infinity;
	        this.shareNodeTransforms = false;
	    }
	    get animationDuration() {
	        return this.dts.sequences[0].duration * 1000;
	    }
	    onMarbleContact(collision) {
	        let time = this.level.timeState;
	        this.wiggleAnimationStart = time.timeSinceLoad;
	        this.level.audio.play(this.sounds[0]);
	        if (!collision)
	            return; // We're probably in a replay if this is the case
	        let marble = this.level.marble;
	        // Set the velocity along the contact normal, but make sure it's capped
	        marble.setLinearVelocityInDirection(collision.normal, 15, false);
	        marble.slidingTimeout = 2; // Make sure we don't slide on the bumper after bouncing off it
	        this.level.replay.recordMarbleContact(this);
	    }
	    render(time) {
	        let currentCompletion = Util.clamp((time.timeSinceLoad - this.wiggleAnimationStart) / this.animationDuration, 0, 1);
	        // Override the keyframe for the "wiggle" effect
	        this.sequenceKeyframeOverride.set(this.dts.sequences[0], currentCompletion * (this.dts.sequences[0].numKeyframes - 1));
	        super.render(time);
	    }
	}

	/** A round bumper. */
	class RoundBumper extends AbstractBumper {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/bumpers/pball_round.dts";
	        this.sounds = ["bumperding1.wav"];
	    }
	}

	/** Reduces gravity temporarily. */
	class Helicopter extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/images/helicopter.dts";
	        this.showSequences = false;
	        this.shareNodeTransforms = false;
	        this.pickUpName = (state.modification === 'gold') ? "Gyrocopter PowerUp" : "Helicopter PowerUp";
	        this.sounds = ["pugyrocoptervoice.wav", "use_gyrocopter.wav"];
	    }
	    pickUp() {
	        return this.level.pickUpPowerUp(this);
	    }
	    use() {
	        this.level.marble.enableHelicopter(this.level.timeState);
	        this.level.deselectPowerUp();
	    }
	}

	/** A shape with force areas that can push or pull the marble. */
	class ForceShape extends Shape {
	    /** Creates a cone-shaped force area that widens as it gets farther away its origin. */
	    addConicForce(distance, arcangle, strength) {
	        let semiverticalangle = arcangle / 2; // Self explanatory, the semi-vertical angle of the right circular cone
	        // Apparently, the tip of the cone in MB is a bit behind the center of the fan,
	        // we are not handling the cases the marble is just a little bit behind the fan, so we must adjust the strength accordingly.
	        // Strength of the fan is inversely proportional to the distance between the tip of the cone and the marble
	        let actualStrength = strength - (strength * (0.7 / distance));
	        let actualDistance = distance - 0.7;
	        // Create a cone-shaped collider
	        this.addCollider(() => new BallCollisionShape(distance), (t, dt) => {
	            let marble = this.level.marble;
	            let perpendicular = new Vector3(0, 0, 1); // The normal to the fan
	            perpendicular.applyQuaternion(this.worldOrientation);
	            let conetip = this.worldPosition.clone().sub(perpendicular.multiplyScalar(0.7)); // The tip of the cone
	            let vec = marble.body.position.clone().sub(conetip); // The vector from the tip of the cone to the marble
	            if (vec.length() === 0)
	                return;
	            if (vec.length() > actualDistance)
	                return; // Our distance is greater than the allowed distance, so we stop right here
	            // Maximum force is proportional to the negative of the distance between the marble and the tip of the cone
	            let maxF = Util.lerp(actualStrength, 0, vec.length() / actualDistance);
	            // Calculate the angle between the perpendicular and the relative position of the marble to the tip of the cone
	            let theta = perpendicular.angleTo(vec);
	            // If our angle is more than the maximum angle, we stop. The division by 2 is just there cause it just works.
	            if (theta > semiverticalangle / 2)
	                return;
	            // The force at an an angle is a parabolic function peaking at maxF, and its zeroes are the the positive and negative semi-vertical angles
	            let forcemag = Math.abs(-maxF * (theta - semiverticalangle) * (theta + semiverticalangle));
	            forcemag *= Math.sign(actualStrength);
	            // Now we have to get the direction of force
	            let force = vec.clone();
	            force.normalize();
	            // Now we apply it
	            marble.body.linearVelocity.addScaledVector(force, forcemag * dt);
	        }, new Matrix4());
	    }
	    /** Like `addConicForce`, but directly ported from OpenMBU (which did some reverse-engineering magic) */
	    addConicForceExceptItsAccurateThisTime(forceRadius, forceArc, forceStrength) {
	        // Create a cone-shaped collider
	        this.addCollider(() => new BallCollisionShape(forceRadius), (t, dt) => {
	            let force = this.computeAccurateConicForce(forceRadius, forceArc, forceStrength);
	            // Calculate the actual force
	            force.multiplyScalar(dt);
	            // Now we apply it
	            this.level.marble.body.linearVelocity.add(force);
	        }, new Matrix4());
	    }
	    computeAccurateConicForce(forceRadius, forceArc, forceStrength) {
	        let marble = this.level.marble;
	        let pos = marble.body.position;
	        let strength = 0.0;
	        let dot = 0.0;
	        let posVec = new Vector3();
	        let retForce = new Vector3();
	        let node = this.worldMatrix.clone(); // In the general case, this is a mount node, but we're only using this method for magnets so far and those don't have that, so use the magnet's transform instead
	        let nodeVec = new Vector3(node.elements[4], node.elements[5], node.elements[6]); // Gets the second column, so basically the transformed y axis
	        nodeVec.normalize();
	        posVec = pos.clone().sub(new Vector3().setFromMatrixPosition(node));
	        dot = posVec.length();
	        if (forceRadius < dot) {
	            // We're outside the area of effect
	            return retForce;
	        }
	        strength = (1 - dot / forceRadius) * forceStrength;
	        posVec.multiplyScalar(1 / dot);
	        let newDot = nodeVec.dot(posVec);
	        let arc = forceArc;
	        if (arc < newDot) {
	            retForce.add(posVec.multiplyScalar(strength).multiplyScalar(newDot - arc).multiplyScalar(1 / (1 - arc)));
	        }
	        return retForce;
	    }
	    /** Creates a spherical-shaped force whose force always acts in the direction away from the center. */
	    addSphericalForce(radius, strength) {
	        this.addCollider(() => new BallCollisionShape(radius), (t, dt) => {
	            let marble = this.level.marble;
	            let vec = marble.body.position.clone().sub(this.worldPosition);
	            if (vec.length() === 0)
	                return;
	            let strengthFac = 1 - Util.clamp(vec.length() / radius, 0, 1) ** 2; // Quadratic falloff with distance
	            marble.body.linearVelocity.addScaledVector(vec.normalize(), strength * strengthFac * dt);
	        }, new Matrix4());
	    }
	    /** Creates a spherical-shaped force whose force acts in the direction of the vector specified. */
	    addFieldForce(radius, forceVector) {
	        this.addCollider(() => new BallCollisionShape(radius), (t, dt) => {
	            let marble = this.level.marble;
	            if (marble.body.position.distanceTo(this.worldPosition) >= radius)
	                return;
	            // Simply add the force
	            marble.body.linearVelocity.addScaledVector(forceVector, dt);
	        }, new Matrix4());
	    }
	}

	/** Blows the marble away. */
	class DuctFan extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/ductfan.dts";
	        this.sounds = ["fan_loop.wav"];
	        this.addConicForce(10, 2.617, 40);
	    }
	    async onLevelStart() {
	        this.soundSource = this.level.audio.createAudioSource(this.sounds[0], undefined, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}

	/** Changes the gravity on pickup. */
	class AntiGravity extends PowerUp {
	    constructor(element, respawnInstantly = false) {
	        super(element);
	        this.dtsPath = "shapes/items/antigravity.dts";
	        this.autoUse = true;
	        this.pickUpName = (state.modification === 'gold') ? "Gravity Modifier" : "Gravity Defier";
	        this.sounds = ["gravitychange.wav"];
	        if (respawnInstantly)
	            this.cooldownDuration = -Infinity;
	    }
	    pickUp() {
	        let direction = new Vector3(0, 0, -1);
	        direction.applyQuaternion(this.worldOrientation).normalize();
	        return !Util.isSameVector(direction, this.level.currentUp);
	    }
	    use() {
	        // Determine the new up vector
	        let direction = new Vector3(0, 0, -1);
	        direction.applyQuaternion(this.worldOrientation);
	        this.level.setUp(direction);
	        this.level.audio.play(this.sounds[0]);
	    }
	}

	/** Land mines explode on contact and knock the marble away. */
	class LandMine extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/hazards/landmine.dts";
	        this.disappearTime = -Infinity;
	        this.sounds = ['explode1.wav'];
	        this.shareMaterials = false;
	    }
	    onMarbleContact() {
	        let time = this.level.timeState;
	        let marble = this.level.marble;
	        let minePos = this.worldPosition;
	        let vec = marble.body.position.clone().sub(minePos);
	        // Add velocity to the marble
	        let explosionStrength = this.computeExplosionStrength(vec.length());
	        marble.body.linearVelocity.addScaledVector(vec.normalize(), explosionStrength);
	        marble.slidingTimeout = 2;
	        this.disappearTime = time.timeSinceLoad;
	        this.setCollisionEnabled(false);
	        this.level.audio.play(this.sounds[0]);
	        this.level.particles.createEmitter(landMineParticle, this.worldPosition);
	        this.level.particles.createEmitter(landMineSmokeParticle, this.worldPosition);
	        this.level.particles.createEmitter(landMineSparksParticle, this.worldPosition);
	        // Normally, we would add a light here, but eh.
	        this.level.replay.recordMarbleContact(this);
	    }
	    /** Computes the strength of the explosion (force) based on distance from it. */
	    computeExplosionStrength(r) {
	        // Figured out through testing by RandomityGuy
	        if (r >= 10.25)
	            return 0;
	        if (r >= 10)
	            return Util.lerp(30.0087, 30.7555, r - 10);
	        // The explosion first becomes stronger the further you are away from it, then becomes weaker again (parabolic).
	        let a = 0.071436222;
	        let v = ((r - 5) ** 2) / (-4 * a) + 87.5;
	        return v;
	    }
	    tick(time, onlyVisual) {
	        if (onlyVisual)
	            return;
	        // Enable or disable the collision based on disappear time
	        let visible = time.timeSinceLoad >= this.disappearTime + 5000;
	        this.setCollisionEnabled(visible);
	    }
	    render(time) {
	        let opacity = Util.clamp((time.timeSinceLoad - (this.disappearTime + 5000)) / 1000, 0, 1);
	        this.setOpacity(opacity);
	    }
	}
	/** The fire particle. */
	const landMineParticle = {
	    ejectionPeriod: 0.2,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 2,
	    velocityVariance: 1,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1000,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.8,
	        acceleration: 0,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.56, g: 0.36, b: 0.26, a: 0 }],
	        sizes: [0.5, 1],
	        times: [0, 1]
	    }
	};
	/** The smoke particle. */
	const landMineSmokeParticle = {
	    ejectionPeriod: 0.5,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 0.8,
	    velocityVariance: 0.4,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1200,
	        lifetimeVariance: 300,
	        dragCoefficient: 0.85,
	        acceleration: -8,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.2, g: 0.2, b: 0.2, a: 1 }, { r: 0, g: 0, b: 0, a: 0 }],
	        sizes: [1, 1.5, 2],
	        times: [0, 0.5, 1]
	    }
	};
	/** The sparks exploding away. */
	const landMineSparksParticle = {
	    ejectionPeriod: 0.4,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 13 / 4,
	    velocityVariance: 6.75 / 4,
	    emitterLifetime: 100,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 500,
	        lifetimeVariance: 350,
	        dragCoefficient: 0.75,
	        acceleration: -8,
	        colors: [{ r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 1, g: 0.4, b: 0.3, a: 0 }],
	        sizes: [0.5, 0.25, 0.25],
	        times: [0, 0.5, 1]
	    }
	};

	/** Temporarily reduces marble restitution. */
	class ShockAbsorber extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/shockabsorber.dts";
	        this.pickUpName = (state.modification === 'gold') ? "Shock Absorber PowerUp" : "Anti-Recoil PowerUp";
	        this.an = state.modification !== 'gold';
	        this.sounds = ["pushockabsorbervoice.wav", "superbounceactive.wav"];
	    }
	    pickUp() {
	        return this.level.pickUpPowerUp(this);
	    }
	    use() {
	        this.level.marble.enableShockAbsorber(this.level.timeState);
	        this.level.deselectPowerUp();
	    }
	}

	/** Accelerates the marble. */
	class SuperSpeed extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/superspeed.dts";
	        this.pickUpName = (state.modification === 'gold') ? "Super Speed PowerUp" : "Speed Booster PowerUp";
	        this.sounds = ["pusuperspeedvoice.wav", "dosuperspeed.wav"];
	    }
	    pickUp() {
	        return this.level.pickUpPowerUp(this);
	    }
	    use() {
	        let level = this.level;
	        let marble = this.level.marble;
	        let movementVector = new Vector3(1, 0, 0);
	        movementVector.applyAxisAngle(new Vector3(0, 0, 1), level.yaw);
	        // Okay, so Super Speed directionality is a bit strange. In general, the direction is based on the normal vector of the last surface you had contact with.
	        let quat = level.newOrientationQuat;
	        movementVector.applyQuaternion(quat);
	        let quat2 = new Quaternion();
	        quat2.setFromUnitVectors(this.level.currentUp, marble.lastContactNormal); // Determine the necessary rotation to rotate the up vector to the contact normal.
	        movementVector.applyQuaternion(quat2); // ...then rotate the movement bonus vector by that amount.
	        marble.body.linearVelocity.addScaledVector(movementVector, 24.7); // Whirligig's determined value (ok it's actually 25 but we ain't changing it)
	        this.level.audio.play(this.sounds[1]);
	        this.level.particles.createEmitter(superSpeedParticleOptions, null, () => marble.body.position.clone());
	        this.level.deselectPowerUp();
	    }
	}
	const superSpeedParticleOptions = {
	    ejectionPeriod: 5,
	    ambientVelocity: new Vector3(0, 0, 0.2),
	    ejectionVelocity: 1 * 0.5,
	    velocityVariance: 0.25 * 0.5,
	    emitterLifetime: 1100,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 0,
	        spinRandomMin: 0,
	        spinRandomMax: 0,
	        lifetime: 1500,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.25,
	        acceleration: 0,
	        colors: [{ r: 0.8, g: 0.8, b: 0, a: 0 }, { r: 0.8, g: 0.8, b: 0, a: 1 }, { r: 0.8, g: 0.8, b: 0, a: 0 }],
	        sizes: [0.25, 0.25, 1],
	        times: [0, 0.25, 1]
	    }
	};

	/** Temporarily pauses the game clock. */
	class TimeTravel extends PowerUp {
	    constructor(element) {
	        super(element);
	        this.dtsPath = "shapes/items/timetravel.dts";
	        this.cooldownDuration = Infinity; // Won't respawn until the level is restarted
	        this.autoUse = true;
	        this.timeBonus = 5000;
	        this.sounds = ["putimetravelvoice.wav", "timetravelactive.wav"];
	        this.pickUpName = ''; // Modified on the fly based on the time bonus
	        if (element.timebonus) {
	            this.timeBonus = MisParser.parseNumber(element.timebonus);
	        }
	        if (element.timepenalty) {
	            this.timeBonus = -MisParser.parseNumber(element.timepenalty);
	        }
	        if (state.modification === 'gold') {
	            this.pickUpName = `${this.timeBonus / 1000} second Time Travel bonus`;
	        }
	        else {
	            this.pickUpName = `${Math.abs(this.timeBonus / 1000)} second Time ${this.timeBonus >= 0 ? 'Modifier' : 'Penalty'}`; // MBP calls them Time Penalty when they add time
	        }
	    }
	    pickUp() {
	        this.level.audio.play(this.sounds[0]);
	        return true;
	    }
	    use(t) {
	        let timeToRevert = (1 - t) * 1000 / PHYSICS_TICK_RATE;
	        if (this.level.replay.mode === 'playback')
	            timeToRevert = this.level.replay.timeTravelTimeToRevert.get(this.id);
	        else
	            this.level.replay.timeTravelTimeToRevert.set(this.id, timeToRevert);
	        this.level.addTimeTravelBonus(this.timeBonus, timeToRevert);
	    }
	}

	/** Sucks the marble in and then slings it upwards. */
	class Tornado extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/tornado.dts";
	        this.collideable = false;
	        this.sounds = ["tornado.wav"];
	        this.addSphericalForce(8, -60);
	        this.addSphericalForce(3, 60);
	        this.addFieldForce(3, new Vector3(0, 0, 150)); // The upwards force is always in the same direction, which is fine considering tornados never appear with modified gravity.
	    }
	    async onLevelStart() {
	        this.soundSource = this.level.audio.createAudioSource(this.sounds[0], undefined, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}

	const RESET_TIME = 5000;
	/** Trap doors open on contact. */
	class TrapDoor extends Shape {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/hazards/trapdoor.dts";
	        this.hasNonVisualSequences = true;
	        this.shareNodeTransforms = false;
	        this.lastContactTime = -Infinity;
	        /** The time it takes from the moment of touching the trapdoor to it opening. */
	        this.timeout = 0;
	        this.lastCompletion = 0;
	        this.sounds = ['trapdooropen.wav'];
	        if (element.timeout)
	            this.timeout = MisParser.parseNumber(element.timeout);
	    }
	    get animationDuration() {
	        return this.dts.sequences[0].duration * 1000;
	    }
	    tick(time, onlyVisual) {
	        let currentCompletion = this.getCurrentCompletion(time);
	        // Override the keyframe
	        this.sequenceKeyframeOverride.set(this.dts.sequences[0], currentCompletion * (this.dts.sequences[0].numKeyframes - 1));
	        super.tick(time, onlyVisual);
	        if (onlyVisual)
	            return;
	        let direction = Math.sign(currentCompletion - this.lastCompletion);
	        if (direction !== 0 && direction !== this.lastDirection) {
	            // If the direction has changed, play the sound
	            this.level.audio.play(this.sounds[0], undefined, undefined, this.worldPosition);
	        }
	        this.lastCompletion = currentCompletion;
	        this.lastDirection = direction;
	    }
	    /** Gets the current completion of the trapdoor openness. 0 = closed, 1 = open. */
	    getCurrentCompletion(time) {
	        let elapsed = time.timeSinceLoad - this.lastContactTime;
	        let completion = Util.clamp(elapsed / this.animationDuration, 0, 1);
	        if (elapsed > RESET_TIME)
	            completion = Util.clamp(1 - (elapsed - RESET_TIME) / this.animationDuration, 0, 1);
	        return completion;
	    }
	    onMarbleContact() {
	        let time = this.level.timeState;
	        if (time.timeSinceLoad - this.lastContactTime <= 0)
	            return; // The trapdoor is queued to open, so don't do anything.
	        let currentCompletion = this.getCurrentCompletion(time);
	        // Set the last contact time accordingly so that the trapdoor starts closing (again)
	        this.lastContactTime = time.timeSinceLoad - currentCompletion * this.animationDuration;
	        if (currentCompletion === 0)
	            this.lastContactTime += this.timeout;
	        this.level.replay.recordMarbleContact(this);
	    }
	}

	/** A triangle-shaped bumper. */
	class TriangleBumper extends AbstractBumper {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/bumpers/pball_tri.dts";
	        this.sounds = ["bumper1.wav"];
	    }
	}

	/** Oilslicks are slippery. */
	class Oilslick extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/hazards/oilslick.dts";
	        this.friction = specialFrictionFactor['friction_none'];
	    }
	}

	/** Blows the marble away, but not much. */
	class SmallDuctFan extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/ductfan.dts";
	        this.sounds = ["fan_loop.wav"];
	        this.addConicForce(5, 2.617, 10);
	    }
	    async onLevelStart() {
	        this.soundSource = this.level.audio.createAudioSource(this.sounds[0], undefined, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}

	/** A trigger is a cuboid-shaped area whose overlap with the marble causes certain events to happen. */
	class Trigger {
	    constructor(element, level) {
	        this.sounds = [];
	        this.isCurrentlyColliding = false;
	        this.id = element._id;
	        this.element = element;
	        this.level = level;
	        // Parse the "polyhedron"
	        let coordinates = MisParser.parseNumberList(element.polyhedron);
	        let origin = new Vector3(coordinates[0], coordinates[1], coordinates[2]);
	        let d1 = new Vector3(coordinates[3], coordinates[4], coordinates[5]);
	        let d2 = new Vector3(coordinates[6], coordinates[7], coordinates[8]);
	        let d3 = new Vector3(coordinates[9], coordinates[10], coordinates[11]);
	        // Create the 8 points of the parallelepiped
	        let p1 = origin.clone();
	        let p2 = origin.clone().add(d1);
	        let p3 = origin.clone().add(d2);
	        let p4 = origin.clone().add(d3);
	        let p5 = origin.clone().add(d1).add(d2);
	        let p6 = origin.clone().add(d1).add(d3);
	        let p7 = origin.clone().add(d2).add(d3);
	        let p8 = origin.clone().add(d1).add(d2).add(d3);
	        let mat = new Matrix4();
	        mat.compose(MisParser.parseVector3(element.position), MisParser.parseRotation(element.rotation), MisParser.parseVector3(element.scale));
	        // Apply the transformation matrix to each vertex
	        let vertices = [p1, p2, p3, p4, p5, p6, p7, p8].map(x => x.applyMatrix4(mat));
	        this.vertices = vertices;
	        // Triggers ignore the actual shape of the polyhedron and simply use its AABB.
	        let aabb = new Box3().setFromPoints(vertices);
	        let aabbVertices = Util.getBoxVertices(aabb);
	        // Create the collision geometry
	        let ownShape = new ConvexHullCollisionShape(aabbVertices);
	        ownShape.collisionDetectionMask = 0b100; // Collide with the small aux marble
	        let body = new RigidBody();
	        body.type = RigidBodyType.Static;
	        body.addCollisionShape(ownShape);
	        this.body = body;
	        // Init collision handlers
	        body.onBeforeIntegrate = () => {
	            if (this.isCurrentlyColliding && body.collisions.length === 0) {
	                this.isCurrentlyColliding = false;
	                this.onMarbleLeave();
	            }
	        };
	        body.onBeforeCollisionResponse = () => {
	            if (!this.isCurrentlyColliding)
	                this.onMarbleEnter();
	            this.onMarbleInside();
	            this.isCurrentlyColliding = true;
	        };
	        this.reset();
	    }
	    async init() {
	        // Preload all sounds
	        for (let sound of this.sounds) {
	            await this.level.audio.loadBuffer(sound);
	        }
	    }
	    reset() {
	        this.isCurrentlyColliding = false;
	    }
	    /* eslint-disable  @typescript-eslint/no-unused-vars */
	    onMarbleInside() { }
	    onMarbleEnter() { }
	    onMarbleLeave() { }
	    tick(time) { }
	}

	/** A must-change trigger controls the path of a pathed interior. */
	class MustChangeTrigger extends Trigger {
	    constructor(element, interior) {
	        super(element, interior.level);
	        this.interior = interior;
	    }
	    onMarbleEnter() {
	        let time = this.level.timeState;
	        this.interior.setTargetTime(time, MisParser.parseNumber(this.element.targettime));
	        if (this.element.instant === "1") {
	            if (this.element.icontinuetottime && this.element.icontinuetottime !== "0") {
	                // Absolutely strange, and not sure if it's even a thing in MBG, but is implement nonetheless.
	                this.interior.currentTime = this.interior.targetTime;
	                this.interior.targetTime = MisParser.parseNumber(this.element.icontinuetottime);
	            }
	            else {
	                this.interior.changeTime = -Infinity; // "If instant is 1, the MP will warp to targetTime instantly."
	            }
	        }
	        this.level.replay.recordMarbleEnter(this);
	    }
	}

	let v1$2 = new Vector3();
	let m1$2 = new Matrix4();
	/** Represents a Torque 3D Pathed Interior moving along a set path. */
	class PathedInterior extends Interior {
	    constructor() {
	        super(...arguments);
	        this.triggers = [];
	        /** The source time */
	        this.currentTime = 0;
	        /** The destination time */
	        this.targetTime = 0;
	        /** The start reference point in time of interior interpolation */
	        this.changeTime = 0;
	        this.prevPosition = new Vector3();
	        this.currentPosition = new Vector3();
	        this.allowSpecialMaterials = false; // Frictions don't work on pathed interiors
	    }
	    /** Creates a PathedInterior from a sim group containing it and its path (and possible triggers). */
	    static async createFromSimGroup(simGroup, level) {
	        let interiorElement = simGroup.elements.find((element) => element._type === MissionElementType.PathedInterior);
	        let { dif: difFile, path } = await level.mission.getDif(interiorElement.interiorresource);
	        if (!difFile)
	            return null;
	        let pathedInterior = new PathedInterior(difFile, path, level, MisParser.parseNumber(interiorElement.interiorindex));
	        pathedInterior.simGroup = simGroup;
	        pathedInterior.element = interiorElement;
	        level.interiors.push(pathedInterior);
	        await Util.wait(10); // See shapes for the meaning of this hack
	        await pathedInterior.init(interiorElement._id);
	        return pathedInterior;
	    }
	    async init(id) {
	        var _a;
	        await super.init(id);
	        // Pathed interiors ignore the normal position, rotation, scale and use the base- variants instead.
	        this.basePosition = MisParser.parseVector3(this.element.baseposition);
	        this.baseOrientation = MisParser.parseRotation(this.element.baserotation);
	        this.baseScale = MisParser.parseVector3(this.element.basescale);
	        this.hasCollision = this.baseScale.x !== 0 && this.baseScale.y !== 0 && this.baseScale.z !== 0; // Don't want to add buggy geometry
	        // Fix zero-volume interiors so they receive correct lighting
	        if (this.baseScale.x === 0)
	            this.baseScale.x = 0.0001;
	        if (this.baseScale.y === 0)
	            this.baseScale.y = 0.0001;
	        if (this.baseScale.z === 0)
	            this.baseScale.z = 0.0001;
	        this.body.onBeforeIntegrate = this.onBeforeIntegrate.bind(this);
	        this.body.orientation.copy(this.baseOrientation);
	        // Add collision geometry
	        for (let i = 0; i < this.detailLevel.convexHulls.length; i++)
	            this.addConvexHull(i, this.baseScale);
	        // Parse the markers
	        this.path = this.simGroup.elements.find((element) => element._type === MissionElementType.Path);
	        this.markerData = this.path.markers.map(x => {
	            return {
	                msToNext: MisParser.parseNumber(x.mstonext),
	                smoothingType: x.smoothingtype,
	                position: MisParser.parseVector3(x.position),
	                rotation: MisParser.parseRotation(x.rotation)
	            };
	        });
	        if (MisParser.parseBoolean(this.path.isLooping))
	            this.markerData.push(this.markerData[0]); // In this case, we wrap around the marker list smoothly. Emulate this by copying the start to the end.
	        this.computeDuration();
	        // Add MustChangeTriggers if necessary
	        let triggers = this.simGroup.elements.filter((element) => element._type === MissionElementType.Trigger);
	        for (let triggerElement of triggers) {
	            if (!triggerElement.targettime)
	                continue; // Not a pathed interior trigger
	            let trigger = new MustChangeTrigger(triggerElement, this);
	            this.triggers.push(trigger);
	        }
	        // Create a sound effect if so specified
	        if (((_a = this.element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'pathedmovingblock') {
	            this.soundPosition = new Vector3(); // This position will be modified
	            this.soundSource = this.level.audio.createAudioSource('movingblockloop.wav', undefined, this.soundPosition);
	            this.soundSource.setLoop(true);
	            await this.soundSource.promise;
	        }
	        this.reset();
	    }
	    async onLevelStart() {
	        var _a;
	        (_a = this.soundSource) === null || _a === void 0 ? void 0 : _a.play();
	    }
	    /** Computes the total duration of the path. */
	    computeDuration() {
	        let total = 0;
	        // Don't count the last marker
	        for (let i = 0; i < this.markerData.length - 1; i++) {
	            total += this.markerData[i].msToNext;
	        }
	        this.duration = total;
	    }
	    setTargetTime(now, target) {
	        let currentInternalTime = this.getInternalTime(now.currentAttemptTime);
	        this.currentTime = currentInternalTime; // Start where the interior currently is
	        this.targetTime = target;
	        this.changeTime = now.currentAttemptTime;
	    }
	    /** Gets the internal time along the path. Is guaranteed to be in [0, duration]. */
	    getInternalTime(externalTime) {
	        if (this.targetTime < 0) {
	            let direction = (this.targetTime === -1) ? 1 : (this.targetTime === -2) ? -1 : 0;
	            return Util.adjustedMod(this.currentTime + (externalTime - this.changeTime) * direction, this.duration);
	        }
	        else {
	            let dur = Math.abs(this.currentTime - this.targetTime);
	            let completion = Util.clamp(dur ? (externalTime - this.changeTime) / dur : 1, 0, 1);
	            return Util.clamp(Util.lerp(this.currentTime, this.targetTime, completion), 0, this.duration);
	        }
	    }
	    tick(time) {
	        var _a, _b, _c;
	        this.body.position.copy(this.currentPosition); // Reset it back to where it should be (render loop might've moved it)
	        let transform = this.getTransformAtTime(m1$2, this.getInternalTime(time.currentAttemptTime));
	        this.prevPosition.copy(this.currentPosition);
	        this.currentPosition.setFromMatrixPosition(transform); // The orientation doesn't matter in that version of TGE, so we only need position
	        // Approximate the velocity numerically
	        let velocity = v1$2.copy(this.currentPosition).sub(this.prevPosition).multiplyScalar(PHYSICS_TICK_RATE);
	        this.body.linearVelocity.copy(velocity);
	        // Modify the sound effect position, if present
	        (_a = this.soundPosition) === null || _a === void 0 ? void 0 : _a.copy(this.currentPosition).add((_c = (_b = this.markerData[0]) === null || _b === void 0 ? void 0 : _b.position) !== null && _c !== void 0 ? _c : new Vector3());
	    }
	    onBeforeIntegrate() {
	        this.body.position.copy(this.currentPosition);
	        this.body.syncShapes();
	    }
	    /** Computes the transform of the interior at a point in time along the path. */
	    getTransformAtTime(dst, time) {
	        let m1 = this.markerData[0];
	        let m2 = this.markerData[1];
	        if (!m1) {
	            // Incase there are no markers at all
	            dst.compose(this.basePosition, this.baseOrientation, this.baseScale);
	            return dst;
	        }
	        // Find the two markers in question
	        let currentEndTime = m1.msToNext;
	        let i = 2;
	        while (currentEndTime < time && i < this.markerData.length) {
	            m1 = m2;
	            m2 = this.markerData[i++];
	            currentEndTime += m1.msToNext;
	        }
	        if (!m2)
	            m2 = m1;
	        let m1Time = currentEndTime - m1.msToNext;
	        let m2Time = currentEndTime;
	        let duration = m2Time - m1Time;
	        let position;
	        let completion = Util.clamp(duration ? (time - m1Time) / duration : 1, 0, 1);
	        if (m1.smoothingType === "Accelerate") {
	            // A simple easing function
	            completion = Math.sin(completion * Math.PI - (Math.PI / 2)) * 0.5 + 0.5;
	        }
	        else if (m1.smoothingType === "Spline") {
	            // Smooth the path like it's a Catmull-Rom spline.
	            let preStart = (i - 2) - 1;
	            let postEnd = (i - 1) + 1;
	            if (postEnd >= this.path.markers.length)
	                postEnd = 0;
	            if (preStart < 0)
	                preStart = this.path.markers.length - 1;
	            let p0 = this.markerData[preStart].position;
	            let p1 = m1.position;
	            let p2 = m2.position;
	            let p3 = this.markerData[postEnd].position;
	            position = v1$2;
	            position.x = Util.catmullRom(completion, p0.x, p1.x, p2.x, p3.x);
	            position.y = Util.catmullRom(completion, p0.y, p1.y, p2.y, p3.y);
	            position.z = Util.catmullRom(completion, p0.z, p1.z, p2.z, p3.z);
	        }
	        if (!position) {
	            let p1 = m1.position;
	            let p2 = m2.position;
	            position = v1$2.copy(p1).lerp(p2, completion);
	        }
	        // Offset by the position of the first marker
	        let firstPosition = this.markerData[0].position;
	        position.sub(firstPosition);
	        position.add(this.basePosition); // Add the base position
	        dst.compose(position, this.baseOrientation, this.baseScale);
	        return dst;
	    }
	    render(time) {
	        let transform = this.getTransformAtTime(m1$2, this.getInternalTime(time.currentAttemptTime));
	        this.mesh.transform.copy(transform);
	        this.mesh.changedTransform();
	        this.body.position.setFromMatrixPosition(transform);
	        this.body.syncShapes(); // Set the position of the body as well for correct camera ray casting results
	    }
	    /** Resets the movement state of the pathed interior to the beginning values. */
	    reset() {
	        var _a, _b, _c;
	        this.currentTime = 0;
	        this.targetTime = 0;
	        this.changeTime = 0;
	        if (this.element.initialposition) {
	            this.currentTime = MisParser.parseNumber(this.element.initialposition);
	        }
	        if (this.element.initialtargetposition) {
	            this.targetTime = MisParser.parseNumber(this.element.initialtargetposition);
	            // Alright this is strange. In Torque, there are some FPS-dependent client/server desync issues that cause the interior to start at the end position whenever the initialTargetPosition is somewhere greater than 1 and, like, approximately below 50.
	            if (this.targetTime > 0 && this.targetTime < 50)
	                this.currentTime = this.duration;
	        }
	        // Reset the position
	        let transform = this.getTransformAtTime(m1$2, this.getInternalTime(0));
	        this.prevPosition.setFromMatrixPosition(transform);
	        this.currentPosition.setFromMatrixPosition(transform);
	        // Should prevent incorrect CCD stuff
	        this.body.position.copy(this.currentPosition);
	        this.body.syncShapes();
	        (_a = this.soundPosition) === null || _a === void 0 ? void 0 : _a.copy(this.currentPosition).add((_c = (_b = this.markerData[0]) === null || _b === void 0 ? void 0 : _b.position) !== null && _c !== void 0 ? _c : new Vector3());
	    }
	}

	/** An in-bounds trigger causes OOB on marble exit. */
	class InBoundsTrigger extends Trigger {
	    onMarbleLeave() {
	        this.level.goOutOfBounds();
	        this.level.replay.recordMarbleLeave(this);
	    }
	}

	/** A help trigger displays an info message when the player touches one. */
	class HelpTrigger extends Trigger {
	    constructor() {
	        super(...arguments);
	        this.sounds = ['infotutorial.wav'];
	    }
	    onMarbleEnter() {
	        if (this.element.text)
	            state.menu.hud.displayHelp(this.element.text, true);
	        this.level.replay.recordMarbleEnter(this);
	    }
	}

	/** An out-of-bounds trigger causes OOB if the marble enters it. */
	class OutOfBoundsTrigger extends Trigger {
	    onMarbleInside() {
	        this.level.goOutOfBounds();
	        this.level.replay.recordMarbleInside(this);
	    }
	}

	const RESET_TIME$1 = 5000;
	/** A simple shape representing a button that is pushed down when the shape is touched. */
	class PushButton extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = 'shapes/buttons/pushbutton.dts';
	        this.lastContactTime = -Infinity;
	        this.shareNodeTransforms = false;
	    }
	    get animationDuration() {
	        return this.dts.sequences[0].duration * 1000;
	    }
	    tick(time, onlyVisual) {
	        let currentCompletion = this.getCurrentCompletion(time);
	        // Override the keyframe
	        this.sequenceKeyframeOverride.set(this.dts.sequences[0], currentCompletion * (this.dts.sequences[0].numKeyframes - 1));
	        super.tick(time, onlyVisual);
	    }
	    /** Gets the current completion of the button pressedness. 0 = not pressed, 1 = completely pressed down. */
	    getCurrentCompletion(time) {
	        let elapsed = time.timeSinceLoad - this.lastContactTime;
	        let completion = Util.clamp(elapsed / this.animationDuration, 0, 1);
	        if (elapsed > RESET_TIME$1)
	            completion = Util.clamp(1 - (elapsed - RESET_TIME$1) / this.animationDuration, 0, 1);
	        return completion;
	    }
	    onMarbleContact() {
	        let time = this.level.timeState;
	        let currentCompletion = this.getCurrentCompletion(time);
	        // Only trigger the button if it's completely retracted
	        if (currentCompletion === 0)
	            this.lastContactTime = time.timeSinceLoad;
	        this.level.replay.recordMarbleContact(this);
	    }
	}

	/** Sign used in MBP to show a direction. */
	class Sign extends Shape {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/signs/sign.dts";
	        if (element.datablock.toLowerCase() !== 'arrow') {
	            // Determine the direction to show
	            let direction = element.datablock.slice("Sign".length).toLowerCase();
	            switch (direction) {
	                case "":
	                    this.dtsPath = "shapes/signs/sign.dts";
	                    break;
	                case "down":
	                    this.dtsPath = "shapes/signs/signdown.dts";
	                    break;
	                case "up":
	                    this.dtsPath = "shapes/signs/signup.dts";
	                    break;
	                case "side":
	                    this.dtsPath = "shapes/signs/signside.dts";
	                    break;
	                case "downside":
	                    this.dtsPath = "shapes/signs/signdown-side.dts";
	                    break;
	                case "upside":
	                    this.dtsPath = "shapes/signs/signup-side.dts";
	                    break;
	            }
	        }
	    }
	}

	/** Magnets pull the marble towards itself. */
	class Magnet extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/magnet/magnet.dts";
	        this.collideable = false;
	        this.sounds = ["magnet.wav"];
	        this.addConicForceExceptItsAccurateThisTime(10, 0.7, -90);
	    }
	    async onLevelStart() {
	        this.soundSource = this.level.audio.createAudioSource(this.sounds[0], undefined, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}

	/** Nukes explode on contact and knock the marble away even more than mines do. */
	class Nuke extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/hazards/nuke/nuke.dts";
	        this.disappearTime = -Infinity;
	        this.sounds = ['nukeexplode.wav'];
	        this.shareMaterials = false;
	    }
	    onMarbleContact() {
	        let time = this.level.timeState;
	        let marble = this.level.marble;
	        let nukePos = this.worldPosition;
	        // Add velocity to the marble
	        let explosionForce = this.computeExplosionForce(marble.body.position.clone().sub(nukePos));
	        marble.body.linearVelocity.add(explosionForce);
	        marble.slidingTimeout = 2;
	        this.disappearTime = time.timeSinceLoad;
	        this.setCollisionEnabled(false);
	        this.level.audio.play(this.sounds[0]);
	        this.level.particles.createEmitter(nukeParticle, this.worldPosition);
	        this.level.particles.createEmitter(nukeSmokeParticle, this.worldPosition);
	        this.level.particles.createEmitter(nukeSparksParticle, this.worldPosition);
	        // Normally, we would add a light here, but eh
	        this.level.replay.recordMarbleContact(this);
	    }
	    /** Computes the force of the explosion based on the vector to the nuke. Ported from decompiled MBG. */
	    computeExplosionForce(distVec) {
	        const range = 10;
	        const power = 100;
	        let dist = distVec.length();
	        if (dist < range) {
	            let scalar = (1 - dist / range) * power;
	            distVec.multiplyScalar(scalar);
	        }
	        return distVec;
	    }
	    tick(time, onlyVisual) {
	        if (onlyVisual)
	            return;
	        // Enable or disable the collision based on disappear time
	        let visible = time.timeSinceLoad >= this.disappearTime + 15000;
	        this.setCollisionEnabled(visible);
	    }
	    render(time) {
	        let opacity = Util.clamp((time.timeSinceLoad - (this.disappearTime + 15000)) / 1000, 0, 1);
	        this.setOpacity(opacity);
	    }
	}
	/** The fire particle. */
	const nukeParticle = {
	    ejectionPeriod: 0.2,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 2,
	    velocityVariance: 1,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1000,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.8,
	        acceleration: 0,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.56, g: 0.36, b: 0.26, a: 0 }],
	        sizes: [0.5, 1],
	        times: [0, 1]
	    }
	};
	/** The smoke particle. */
	const nukeSmokeParticle = {
	    ejectionPeriod: 0.5,
	    ambientVelocity: new Vector3(0, 0, 0),
	    ejectionVelocity: 1.3,
	    velocityVariance: 0.5,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 2500,
	        lifetimeVariance: 300,
	        dragCoefficient: 0.7,
	        acceleration: -8,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.2, g: 0.2, b: 0.2, a: 0.85 }, { r: 0, g: 0, b: 0, a: 0 }],
	        sizes: [1, 1.5, 2],
	        times: [0, 0.5, 1]
	    }
	};
	/** The sparks exploding away. */
	const nukeSparksParticle = {
	    ejectionPeriod: 1.7,
	    ambientVelocity: new Vector3(0, -0.5, 0),
	    ejectionVelocity: 13 / 1.5,
	    velocityVariance: 5 / 1,
	    emitterLifetime: 5000,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 4500,
	        lifetimeVariance: 2500,
	        dragCoefficient: 0.5,
	        acceleration:  0 ,
	        colors: [{ r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 1, g: 0.4, b: 0.3, a: 0 }],
	        sizes: [0.5, 0.4, 0.2],
	        times: [0, 0.5, 1]
	    }
	};

	/** Specifies the destination of a teleport. */
	class DestinationTrigger extends Trigger {
	}

	/** A teleport trigger teleports the marble to a specified destination after some time of being inside it. */
	class TeleportTrigger extends Trigger {
	    constructor(element, level) {
	        super(element, level);
	        /** How long after entry until the teleport happens */
	        this.delay = 2000;
	        this.entryTime = null;
	        this.exitTime = null;
	        this.sounds = ["teleport.wav"];
	        this.teleportingSound = null;
	        if (element.delay)
	            this.delay = MisParser.parseNumber(element.delay);
	    }
	    onMarbleEnter() {
	        let time = this.level.timeState;
	        this.exitTime = null;
	        this.level.marble.enableTeleportingLook(time);
	        this.level.replay.recordMarbleEnter(this);
	        if (this.entryTime !== null)
	            return;
	        this.entryTime = time.currentAttemptTime;
	        state.menu.hud.displayAlert("Teleporter has been activated, please wait.");
	        this.teleportingSound = this.level.audio.createAudioSource('teleport.wav');
	        this.teleportingSound.play();
	    }
	    onMarbleLeave() {
	        let time = this.level.timeState;
	        this.exitTime = time.currentAttemptTime;
	        this.level.marble.disableTeleportingLook(time);
	        this.level.replay.recordMarbleLeave(this);
	    }
	    tick(time) {
	        if (this.entryTime === null)
	            return;
	        if (time.currentAttemptTime - this.entryTime >= this.delay) {
	            this.executeTeleport();
	            return;
	        }
	        // There's a little delay after exiting before the teleporter gets cancelled
	        if (this.exitTime !== null && time.currentAttemptTime - this.exitTime > 50) {
	            this.entryTime = null;
	            this.exitTime = null;
	            return;
	        }
	    }
	    executeTeleport() {
	        var _a;
	        this.entryTime = null;
	        // Find the destination trigger
	        let destination = this.level.triggers.find(x => { var _a; return x instanceof DestinationTrigger && x.element._name.toLowerCase() === ((_a = this.element.destination) === null || _a === void 0 ? void 0 : _a.toLowerCase()); });
	        if (!destination)
	            return; // Who knows
	        let body = this.level.marble.body;
	        // Determine where to place the marble
	        let position;
	        if (MisParser.parseBoolean(this.element.centerdestpoint || destination.element.centerdestpoint)) {
	            position = destination.vertices[0].clone().lerp(destination.vertices[7], 0.5); // Put the marble in the middle of the thing
	        }
	        else {
	            position = destination.vertices[0].clone().add(new Vector3(0, 0, 3));
	        }
	        body.position.copy(position);
	        body.prevPosition.copy(position); // Avoid funky CCD business
	        if (!MisParser.parseBoolean(this.element.keepvelocity || destination.element.keepvelocity))
	            body.linearVelocity.setScalar(0);
	        if (MisParser.parseBoolean(this.element.inversevelocity || destination.element.inversevelocity))
	            body.linearVelocity.negate();
	        if (!MisParser.parseBoolean(this.element.keepangular || destination.element.keepangular))
	            body.angularVelocity.setScalar(0);
	        // Determine camera orientation
	        if (!MisParser.parseBoolean(this.element.keepcamera || destination.element.keepcamera)) {
	            let yaw;
	            if (this.element.camerayaw)
	                yaw = Util.degToRad(MisParser.parseNumber(this.element.camerayaw));
	            else if (destination.element.camerayaw)
	                yaw = Util.degToRad(MisParser.parseNumber(destination.element.camerayaw));
	            else
	                yaw = 0;
	            yaw = -yaw; // Need to flip it for some reason
	            this.level.yaw = yaw + Math.PI / 2;
	            this.level.pitch = DEFAULT_PITCH;
	        }
	        this.level.audio.play('spawn.wav');
	        (_a = this.teleportingSound) === null || _a === void 0 ? void 0 : _a.stop();
	        this.teleportingSound = null;
	    }
	    reset() {
	        super.reset();
	        this.entryTime = null;
	        this.exitTime = null;
	    }
	}

	/** On contact, sets a new checkpoint with itself as the respawn shape. */
	class Checkpoint extends Shape {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/buttons/checkpoint.dts";
	        this.sounds = ['checkpoint.wav'];
	    }
	    onMarbleContact() {
	        this.level.saveCheckpointState(this);
	        this.level.replay.recordMarbleContact(this);
	    }
	}

	/** A checkpoint trigger sets the current checkpoint to an arbitrary shape in the level. */
	class CheckpointTrigger extends Trigger {
	    constructor() {
	        super(...arguments);
	        this.sounds = ['checkpoint.wav'];
	    }
	    onMarbleEnter() {
	        // Shape can be anything, doesn't necessarily have to be a checkpoint
	        let respawnShape = this.level.shapes.find(x => { var _a, _b; return ((_a = x.srcElement) === null || _a === void 0 ? void 0 : _a._name.toLowerCase()) === ((_b = this.element.respawnpoint) === null || _b === void 0 ? void 0 : _b.toLowerCase()); });
	        if (!respawnShape)
	            return;
	        this.level.saveCheckpointState(respawnShape, this);
	        this.level.replay.recordMarbleEnter(this);
	    }
	}

	/** Easter eggs are hidden collectibles that the player can search for. */
	class EasterEgg extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/easteregg.dts";
	        this.cooldownDuration = Infinity; // Won't respawn until the level is restarted
	        this.autoUse = true;
	        this.sounds = ["easter.wav", "easterfound.wav"]; // The sound varies based on if the player already found the egg
	        this.pickUpName = '';
	    }
	    pickUp() {
	        let alreadyFound = StorageManager.data.collectedEggs.includes(this.level.mission.path);
	        if (!alreadyFound) {
	            StorageManager.data.collectedEggs.push(this.level.mission.path);
	            StorageManager.store();
	            state.menu.levelSelect.displayMission(); // To refresh the icon
	        }
	        this.level.audio.play(this.sounds[Number(alreadyFound)]); // Holy shit this cast is nasty
	        this.customPickUpAlert = alreadyFound ? "You already found this Easter Egg." : "You found an Easter Egg!";
	        return true;
	    }
	    use() { }
	}

	const POSSIBLE_POWERUPS = [SuperJump, SuperSpeed, Helicopter, SuperBounce, ShockAbsorber, TimeTravel];
	/** A random power-up decides which power-up it acts like once it is picked up. */
	class RandomPowerUp extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/random.dts";
	        this.sounds = POSSIBLE_POWERUPS.map(x => new x(this.element).sounds).flat(); // Can play all the power-ups' sounds
	        this.pickedUpCount = 0;
	        this.pickUpName = '';
	    }
	    pickUp() {
	        // Loop until a power-up is found that can be picked up
	        while (true) {
	            let Random;
	            if (this.level.replay.mode === 'record')
	                Random = POSSIBLE_POWERUPS[Math.floor(Math.random() * 6)]; // Choose a random power-up
	            else
	                Random = POSSIBLE_POWERUPS[this.level.replay.randomPowerUpChoices.get(this.id)[this.pickedUpCount]]; // Select the one stored in the replay
	            let instance = new Random(this.element);
	            instance.level = this.level; // Prevent having to init()
	            instance.id = this.id;
	            if (instance.pickUp()) {
	                // We pretend we're them
	                this.pickUpName = instance.pickUpName;
	                this.customPickUpAlert = instance.customPickUpAlert;
	                this.an = instance.an;
	                this.autoUse = instance.autoUse;
	                this.cooldownDuration = instance.cooldownDuration;
	                this.lastInstance = instance;
	                this.pickedUpCount++;
	                if (this.level.replay.mode === 'record') {
	                    // Save the random choice to the replay
	                    let arr = this.level.replay.randomPowerUpChoices.get(this.id);
	                    if (!arr)
	                        arr = [], this.level.replay.randomPowerUpChoices.set(this.id, arr);
	                    arr.push(POSSIBLE_POWERUPS.indexOf(Random));
	                }
	                return true;
	            }
	        }
	    }
	    use(t) {
	        this.lastInstance.use(t);
	    }
	    getAllDtsPaths() {
	        return POSSIBLE_POWERUPS.map(x => new x(this.element).dtsPath);
	    }
	    reset() {
	        super.reset();
	        this.pickedUpCount = 0;
	    }
	}

	class PauseScreen {
	    constructor(menu) {
	        /** If true, can't be closed using the Escape key. */
	        this.preventClose = false;
	        this.initProperties();
	        menu.setupButton(this.yesButton, this.yesSrc, () => {
	            if (!state.level)
	                return;
	            state.level.stopAndExit();
	        });
	        menu.setupButton(this.noButton, this.noSrc, () => state.level.unpause());
	        menu.setupButton(this.restartButton, this.restartSrc, () => {
	            state.level.unpause();
	            state.level.restart(true);
	        });
	        window.addEventListener('keydown', (e) => {
	            if (!state.level || state.level.offline)
	                return;
	            if (state.menu !== menu)
	                return;
	            if (e.key === 'Escape') {
	                if (state.level.paused) {
	                    if (!this.preventClose)
	                        this.noButton.src = menu.uiAssetPath + this.noSrc + '_d.png';
	                }
	                else {
	                    state.level.pause();
	                }
	            }
	            else if (e.code === StorageManager.data.settings.gameButtonMapping.restart && state.level.paused) {
	                // Restart the level if we press the restart button
	                this.restartButton.click();
	                state.level.pressingRestart = true; // Prevents the level from restarting again immediately (kinda hacky 😅)
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (!state.level || state.level.offline)
	                return;
	            if (state.menu !== menu)
	                return;
	            if (state.level.paused && e.key === 'Escape' && this.noButton.src.endsWith('_d.png')) {
	                this.noButton.src = menu.uiAssetPath + this.noSrc + '_n.png';
	                state.level.unpause();
	            }
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        setEnterFullscreenButtonVisibility(true);
	    }
	    hide() {
	        this.div.classList.add('hidden');
	        setEnterFullscreenButtonVisibility(false);
	    }
	    async onReplayButtonClick(download) {
	        let level = state.level;
	        if (download) {
	            let serialized = await level.replay.serialize();
	            Replay.download(serialized, level.mission, false, true);
	            if (Util.isTouchDevice && Util.isInFullscreen())
	                state.menu.showAlertPopup('Downloaded', 'The .wrec has been downloaded.');
	        }
	        else {
	            let confirmed = await state.menu.showConfirmPopup('Confirm', "Do you want to watch this replay? Note that you can only watch it once. If you want to watch it more often, download it first. (alt-click (or long-press on touch devices))");
	            if (!confirmed)
	                return;
	            level.replay.mode = 'playback';
	            this.restartButton.click();
	        }
	    }
	    handleGamepadInput(gamepad) {
	        // A button to exit
	        if (gamepad.buttons[0].value > 0.5 && !previousButtonState[0]) {
	            state.level.stopAndExit();
	            mainAudioManager.play('buttonpress.wav');
	        }
	        // B button or pause button to continue
	        if (gamepad.buttons[1].value > 0.5 && !previousButtonState[1]) {
	            state.level.unpause();
	            mainAudioManager.play('buttonpress.wav');
	        }
	        if (gamepad.buttons[9].value > 0.5 && !previousButtonState[9]) {
	            state.level.unpause();
	            resetPressedFlag('pause');
	            mainAudioManager.play('buttonpress.wav');
	        }
	        // Restart button to restart
	        if (gamepad.buttons[8].value > 0.5 && !previousButtonState[8]) {
	            state.level.unpause();
	            state.level.restart(true);
	            state.level.pressingRestart = true;
	            mainAudioManager.play('buttonpress.wav');
	        }
	    }
	}

	class MbpPauseScreen extends PauseScreen {
	    constructor(menu) {
	        super(menu);
	        this.jukeboxButton = document.querySelector('#mbp-pause-jukebox');
	        menu.setupButton(this.replayButton, 'play/replay', (e) => this.onReplayButtonClick(e.altKey));
	        Util.onLongTouch(this.replayButton, () => this.onReplayButtonClick(true));
	        this.jukebox = new Jukebox(menu);
	        menu.setupButton(this.jukeboxButton, 'jukebox/jb_pausemenu', () => {
	            this.jukebox.show();
	        }, undefined, undefined, false);
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-pause-screen');
	        this.yesButton = document.querySelector('#mbp-pause-yes');
	        this.noButton = document.querySelector('#mbp-pause-no');
	        this.restartButton = document.querySelector('#mbp-pause-restart');
	        this.replayButton = document.querySelector('#mbp-pause-replay');
	        this.yesSrc = 'exit/yes';
	        this.noSrc = 'exit/no';
	        this.restartSrc = 'exit/restart';
	    }
	}
	const SONGS = {
	    'astrolabe.ogg': 'Astrolabe',
	    'beach party.ogg': 'Beach Party',
	    'challenge.ogg': 'Challenge',
	    'classic vibe.ogg': 'Classic Vibe',
	    'comforting mystery.ogg': 'Comforting Mystery',
	    'endurance.ogg': 'Endurance',
	    'flanked.ogg': 'Flanked',
	    'groove police.ogg': 'Groove Police',
	    'grudge.ogg': 'Grudge',
	    'mbp old shell.ogg': 'MBP Old Shell',
	    'metropolis.ogg': 'Metropolis',
	    'pianoforte.ogg': 'Pianoforte',
	    'quiet lab.ogg': 'Quiet Lab',
	    'rising temper.ogg': 'Rising Temper',
	    'seaside revisited.ogg': 'Seaside Revisited',
	    'shell.ogg': 'Shell',
	    'the race.ogg': 'The Race',
	    'tim trance.ogg': 'Tim Trance',
	    'xmas trance.ogg': 'Xmas Trance'
	};
	class Jukebox {
	    constructor(menu) {
	        this.div = document.querySelector('#jukebox');
	        this.songsContainer = document.querySelector('#jukebox-songs');
	        this.textElement = document.querySelector('#jukebox-text');
	        this.closeButton = document.querySelector('#jukebox-close');
	        this.prevButton = document.querySelector('#jukebox-prev');
	        this.playButton = document.querySelector('#jukebox-play');
	        this.nextButton = document.querySelector('#jukebox-next');
	        this.selectedIndex = null;
	        this._playing = true;
	        this.menu = menu;
	        menu.setupButton(this.closeButton, 'jukebox/close', () => this.hide());
	        menu.setupButton(this.prevButton, 'play/prev', () => this.select(Object.keys(SONGS)[this.selectedIndex - 1]), true);
	        menu.setupVaryingButton(this.playButton, ['jukebox/stop', 'jukebox/play'], () => {
	            var _a, _b;
	            if (this.playing) {
	                (_a = state.level.music) === null || _a === void 0 ? void 0 : _a.stop();
	                this.playing = false;
	            }
	            else {
	                if (this.selectedIndex !== null)
	                    this.select(Object.keys(SONGS)[this.selectedIndex]);
	                else {
	                    // Restart the default song
	                    (_b = state.level.music) === null || _b === void 0 ? void 0 : _b.play();
	                    this.playing = true;
	                }
	            }
	            this.updateText();
	        });
	        menu.setupButton(this.nextButton, 'play/next', () => this.select(Object.keys(SONGS)[this.selectedIndex + 1]), true);
	        window.addEventListener('keydown', (e) => {
	            if (!this.div.classList.contains('hidden') && e.key === 'Escape') {
	                this.closeButton.src = menu.uiAssetPath + 'jukebox/close_d.png';
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (!this.div.classList.contains('hidden') && e.key === 'Escape') {
	                this.closeButton.src = menu.uiAssetPath + 'jukebox/close_n.png';
	                this.hide();
	            }
	        });
	        // Create all the elements for the songs
	        for (let key in SONGS) {
	            let element = document.createElement('div');
	            element.textContent = SONGS[key];
	            this.songsContainer.appendChild(element);
	            element.addEventListener('mousedown', () => this.select(key));
	        }
	    }
	    get playing() {
	        return this._playing;
	    }
	    set playing(state) {
	        this._playing = state;
	        this.menu.setButtonVariant(this.playButton, 1 - Number(state)); // Automagically✨ update the button too
	    }
	    /** Selects a given song and plays it. */
	    select(song) {
	        if (!SONGS[song])
	            return;
	        let index = Object.keys(SONGS).indexOf(song);
	        this.selectedIndex = index;
	        for (let i = 0; i < this.songsContainer.children.length; i++) {
	            this.songsContainer.children[i].classList.remove('selected');
	            if (i === index)
	                this.songsContainer.children[i].classList.add('selected');
	        }
	        let level = state.level;
	        if (level.music)
	            level.music.stop();
	        level.music = level.audio.createAudioSource('music/' + song, level.audio.musicGain, undefined, true);
	        level.music.setLoop(true);
	        level.music.play();
	        this.playing = true;
	        this.updateNextPrevButtons();
	        this.updateText();
	    }
	    updateNextPrevButtons() {
	        // Enable or disable the next button based on if there are still songs to come
	        if (this.selectedIndex === null || this.selectedIndex === Object.keys(SONGS).length - 1) {
	            this.nextButton.src = this.menu.uiAssetPath + 'play/next_i.png';
	            this.nextButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.nextButton.src.endsWith('i.png'))
	                this.nextButton.src = this.menu.uiAssetPath + 'play/next_n.png';
	            this.nextButton.style.pointerEvents = '';
	        }
	        // Enable or disable the prev button based on if there are still songs to come
	        if (this.selectedIndex === null || this.selectedIndex === 0) {
	            this.prevButton.src = this.menu.uiAssetPath + 'play/prev_i.png';
	            this.prevButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.prevButton.src.endsWith('i.png'))
	                this.prevButton.src = this.menu.uiAssetPath + 'play/prev_n.png';
	            this.prevButton.style.pointerEvents = '';
	        }
	    }
	    updateText() {
	        if (this.selectedIndex === null)
	            this.textElement.innerHTML = '';
	        else
	            this.textElement.innerHTML = `Title: ${SONGS[Object.keys(SONGS)[this.selectedIndex]]}<br>${this.playing ? 'Playing' : 'Stopped'}`;
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        state.menu.pauseScreen.preventClose = true;
	        if (this.selectedIndex === null) {
	            // This runs if this was the first time in the current level that the jukebox was opened.
	            for (let child of this.songsContainer.children)
	                child.classList.remove('selected');
	            let index = Object.keys(SONGS).indexOf(state.level.originalMusicName);
	            if (index >= 0) {
	                this.songsContainer.children[index].classList.add('selected');
	                this.selectedIndex = index;
	            }
	            this.playing = true;
	            this.updateNextPrevButtons();
	            this.updateText();
	        }
	        // Scroll the current song into view
	        let selectedElem = [...this.songsContainer.children].find(x => x.classList.contains('selected'));
	        if (selectedElem)
	            selectedElem.scrollIntoView({ block: "nearest", inline: "nearest" });
	    }
	    hide() {
	        this.div.classList.add('hidden');
	        state.menu.pauseScreen.preventClose = false;
	    }
	    reset() {
	        this.selectedIndex = null;
	    }
	}

	const buttonToDisplayNameMbg = {
	    up: 'Move Forward',
	    down: 'Move Backward',
	    left: 'Move Left',
	    right: 'Move Right',
	    use: 'Use PowerUp',
	    jump: 'Jump',
	    cameraUp: 'Rotate Camera Up',
	    cameraDown: 'Rotate Camera Down',
	    cameraLeft: 'Rotate Camera Left',
	    cameraRight: 'Rotate Camera Right',
	    freeLook: 'Free Look',
	    restart: 'Restart',
	    blast: 'Use Blast'
	};
	const buttonToDisplayNameMbp = {
	    up: 'Move Forward',
	    down: 'Move Backward',
	    left: 'Move Left',
	    right: 'Move Right',
	    use: 'Use PowerUp',
	    jump: 'Jump',
	    cameraUp: 'Look Up',
	    cameraDown: 'Look Down',
	    cameraLeft: 'Look Left',
	    cameraRight: 'Look Right',
	    freeLook: 'Free Look',
	    restart: 'Respawn',
	    blast: 'Use Blast'
	};
	class OptionsScreen {
	    constructor(menu) {
	        /** Stores the button that's currently being rebound. */
	        this.currentlyRebinding = null;
	        /** Stores the value that we currently want to rebind to. */
	        this.rebindValue = null;
	        this.rebindConfirmWarningEnding = `Do you want to undo this<br>mapping?`;
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.homeButton, this.homeButtonSrc, () => {
	            this.hide();
	            menu.home.show();
	        }, undefined, undefined, state.modification === 'gold');
	        window.addEventListener('keydown', (e) => {
	            if (!this.currentlyRebinding || this.rebindValue)
	                return;
	            if (e.code === 'Escape') {
	                // Exits keybinding without changing anything
	                this.currentlyRebinding = null;
	                this.rebindDialog.classList.add('hidden');
	            }
	            else {
	                this.setKeybinding(this.currentlyRebinding, e.code);
	            }
	        });
	        window.addEventListener('mousedown', (e) => {
	            if (!this.currentlyRebinding || this.rebindValue)
	                return;
	            let buttonName = ["LMB", "MMB", "RMB"][e.button];
	            if (!buttonName)
	                return;
	            this.setKeybinding(this.currentlyRebinding, buttonName);
	        });
	        menu.setupButton(this.rebindConfirmYes, this.rebindConfirmYesSrc, () => {
	            // Find the other value and nullify its binding value (empty string)
	            for (let key in StorageManager.data.settings.gameButtonMapping) {
	                let typedKey = key;
	                let otherValue = StorageManager.data.settings.gameButtonMapping[typedKey];
	                if (otherValue === this.rebindValue)
	                    StorageManager.data.settings.gameButtonMapping[typedKey] = '';
	            }
	            // Bind the new value
	            StorageManager.data.settings.gameButtonMapping[this.currentlyRebinding] = this.rebindValue;
	            StorageManager.store();
	            this.currentlyRebinding = null;
	            this.rebindValue = null;
	            this.rebindConfirm.classList.add('hidden');
	            this.refreshKeybindings();
	        });
	        menu.setupButton(this.rebindConfirmNo, this.rebindConfirmNoSrc, () => {
	            // Cancel the rebinding process.
	            this.currentlyRebinding = null;
	            this.rebindValue = null;
	            this.rebindConfirm.classList.add('hidden');
	        });
	    }
	    async init() { }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    /** Returns a nice string representation of the key that a button is bound to. */
	    formatKeybinding(button) {
	        let str = Util.getKeyForButtonCode(StorageManager.data.settings.gameButtonMapping[button]);
	        if (str.startsWith('the'))
	            return str.slice(str.indexOf(' ') + 1, str.lastIndexOf(' ')); // If the string starts with 'the', then it's a mouse button, and we clean it up by only keeping the middle part (dropping 'the' and 'button')
	        else
	            return str;
	    }
	    /** Starts the rebinding process and shows a dialog. */
	    changeKeybinding(button) {
	        if (Util.isTouchDevice)
	            return; // Don't
	        let map = (state.modification === 'gold') ? buttonToDisplayNameMbg : buttonToDisplayNameMbp;
	        this.rebindDialog.classList.remove('hidden');
	        this.rebindDialog.children[1].innerHTML = `Press a new key or button for<br>"${map[button]}"`;
	        this.currentlyRebinding = button;
	    }
	    /** Updates the binding for a given button. */
	    setKeybinding(button, value) {
	        let map = (state.modification === 'gold') ? buttonToDisplayNameMbg : buttonToDisplayNameMbp;
	        // Check for collisions with other bindings
	        for (let key in StorageManager.data.settings.gameButtonMapping) {
	            let typedKey = key;
	            let otherValue = StorageManager.data.settings.gameButtonMapping[typedKey];
	            if (otherValue === value && typedKey !== button) {
	                // We found another binding that binds to the same key, bring up the conflict dialog.
	                this.rebindDialog.classList.add('hidden');
	                this.rebindConfirm.classList.remove('hidden');
	                this.rebindConfirm.children[1].innerHTML = `"${this.formatKeybinding(typedKey)}" is already bound to "${map[typedKey]}"!<br>` + this.rebindConfirmWarningEnding;
	                this.rebindValue = value;
	                return;
	            }
	        }
	        // Simply store the keybind.
	        StorageManager.data.settings.gameButtonMapping[button] = value;
	        StorageManager.store();
	        this.currentlyRebinding = null;
	        this.rebindDialog.classList.add('hidden');
	        this.refreshKeybindings();
	    }
	    showMarbleTexturePicker() {
	        return new Promise(resolve => {
	            // Show an image picker
	            let fileInput = document.createElement('input');
	            fileInput.setAttribute('type', 'file');
	            fileInput.setAttribute('accept', "image/x-png,image/gif,image/jpeg");
	            fileInput.onchange = async () => {
	                let file = fileInput.files[0];
	                await StorageManager.databasePut('keyvalue', file, 'marbleTexture'); // Store the Blob in the IndexedDB
	                resolve();
	            };
	            fileInput.click();
	        });
	    }
	}

	const SLIDER_KNOB_LEFT = 217;
	const SLIDER_KNOB_RIGHT = 344;
	const FRAME_RATE_OPTIONS = [30, 60, 90, 120, 144, 240, 360, Infinity];
	class MbpOptionsScreen extends OptionsScreen {
	    constructor() {
	        super(...arguments);
	        this.applyButton = document.querySelector('#mbp-options-apply');
	        this.generalButton = document.querySelector('#mbp-options-general');
	        this.hotkeysButton = document.querySelector('#mbp-options-hotkeys');
	        this.generalContainer = document.querySelector('#mbp-options-general-container');
	        this.hotkeysContainer = document.querySelector('#mbp-options-hotkeys-container');
	        /** Array of functions that cause each option element to be refreshed. */
	        this.updateFuncs = [];
	        this.rebindConfirmWarningEnding = `Do you want to undo this mapping?`; // Removed <br>
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-options');
	        this.homeButton = document.querySelector('#mbp-options-home');
	        this.rebindDialog = document.querySelector('#mbp-rebind-dialog');
	        this.rebindConfirm = document.querySelector('#mbp-rebind-confirm');
	        this.rebindConfirmYes = document.querySelector('#mbp-rebind-confirm-yes');
	        this.rebindConfirmNo = document.querySelector('#mbp-rebind-confirm-no');
	        this.homeButtonSrc = 'options/home';
	        this.rebindConfirmYesSrc = 'exit/yes';
	        this.rebindConfirmNoSrc = 'exit/no';
	    }
	    async init() {
	        this.menu.setupButton(this.applyButton, 'options/apply', () => { }, undefined, undefined, false); // no-op
	        this.menu.setupButton(this.generalButton, 'options/general', () => {
	            this.generalContainer.classList.remove('hidden');
	            this.hotkeysContainer.classList.add('hidden');
	            // Lock the one button in place
	            this.generalButton.src = this.generalButton.src.slice(0, -5) + 'd.png';
	            this.generalButton.setAttribute('data-locked', '');
	            this.hotkeysButton.src = this.hotkeysButton.src.slice(0, -5) + 'n.png';
	            this.hotkeysButton.removeAttribute('data-locked');
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.hotkeysButton, 'options/hotkeys', () => {
	            this.generalContainer.classList.add('hidden');
	            this.hotkeysContainer.classList.remove('hidden');
	            // Lock the one button in place
	            this.hotkeysButton.src = this.hotkeysButton.src.slice(0, -5) + 'd.png';
	            this.hotkeysButton.setAttribute('data-locked', '');
	            this.generalButton.src = this.generalButton.src.slice(0, -5) + 'n.png';
	            this.generalButton.removeAttribute('data-locked');
	        }, undefined, undefined, false);
	        this.generalButton.click();
	        this.updateSliders();
	        const handler = () => {
	            var _a;
	            if (this.currentSliderElement)
	                StorageManager.store();
	            else
	                return;
	            this.currentSliderElement = null;
	            (_a = this.soundTestingSound) === null || _a === void 0 ? void 0 : _a.stop();
	            this.soundTestingSound = null;
	        };
	        window.addEventListener('mouseup', handler);
	        window.addEventListener('touchend', handler);
	        // Add all the option elements
	        /* General */
	        this.addHeading(this.generalContainer, 'General');
	        // These here are commented out because, really, they're all no-ops.
	        //this.addDropdown(this.generalContainer, 'resolution', 'Screen Resolution', ['640x480', '800x600', '1024x768']);
	        //this.addDropdown(this.generalContainer, 'videoDriver', 'Video Driver', ['OpenGL', 'Direct3D']);
	        //this.addDropdown(this.generalContainer, 'screenStyle', 'Screen Style', ['Windowed', 'Full']);
	        //this.addDropdown(this.generalContainer, 'shadows', 'Shadows', ['Disabled', 'Enabled'], true);
	        //this.addDropdown(this.generalContainer, 'colorDepth', 'Color Depth', ['16 Bit', '32 Bit']);
	        this.addDropdown(this.generalContainer, 'alwaysFreeLook', 'Free-Look', ['Disabled', 'Enabled'], true);
	        this.addDropdown(this.generalContainer, 'invertMouse', 'Invert Mouse', ['None', 'X Only', 'Y only', 'X and Y']);
	        this.addDropdown(this.generalContainer, 'frameRateCap', 'Max Frame Rate', FRAME_RATE_OPTIONS.map(x => isFinite(x) ? x.toString() : 'Unlimited'), undefined, undefined, undefined, () => {
	            this.menu.showAlertPopup('About unlocking frame rate', `Browsers are v-synced by default, causing some input lag. Chrome can unlock its FPS by starting it with a special flag. Check <a href="https://www.reddit.com/r/KrunkerIO/comments/esz4gt/unlock_browser_fps_this_one_is_for_you/" target="_blank">this Reddit post</a> for more info. Once your FPS are unlocked, use this setting to ensure your CPU doesn't overheat.`);
	        });
	        this.addDropdown(this.generalContainer, 'showFrameRate', 'Frame Rate', ['Hidden', 'Visible'], true);
	        this.addDropdown(this.generalContainer, 'showThousandths', 'Thousandths', ['Disabled', 'Enabled'], true);
	        this.addMarbleTexturePicker(this.generalContainer);
	        this.addDropdown(this.generalContainer, 'marbleReflectivity', 'Reflective Marble', ['Contextual', 'Disabled', 'Enabled']);
	        this.addDropdown(this.generalContainer, 'fancyShaders', 'Fancy Shaders', ['Disabled', 'Enabled'], true);
	        this.addDropdown(this.generalContainer, 'pixelRatio', 'Pixel Ratio', ['Max 0.5', 'Max 1.0', 'Max 1.5', 'Max 2.0', 'Max ∞']);
	        this.addDropdown(this.generalContainer, 'canvasDesynchronized', 'Low-latency mode', ['Disabled', 'Enabled'], true, () => {
	            location.reload(); // Because we can't just modify a WebGL context after its creation
	        }, undefined, () => {
	            this.menu.showAlertPopup('About low-latency mode', `In Chromium-based browsers, enabling low-latency mode can considerably reduce visual latency during gameplay. On some systems however, this can introduce flickering artifacts.`);
	        });
	        this.addDropdown(this.generalContainer, 'inputType', 'Input Type', ['Auto', 'Keyboard + Mouse', 'Touch'], undefined, () => {
	            let before = Util.isTouchDevice;
	            Util.isTouchDevice = (StorageManager.data.settings.inputType === 1) ? false : (StorageManager.data.settings.inputType === 2) ? true : Util.checkIsTouchDevice();
	            if (before !== Util.isTouchDevice)
	                location.reload(); // Restart that shit, don't take any chances
	        });
	        this.addSlider(this.generalContainer, 'fov', 'Field of View', 30, 120, undefined, undefined, 1, x => x.toString());
	        this.addSlider(this.generalContainer, 'musicVolume', 'Music Volume', 0, 1, () => mainAudioManager.updateVolumes(), undefined, undefined, x => Math.ceil(x * 100).toString());
	        this.addSlider(this.generalContainer, 'mouseSensitivity', 'Mouse Speed', 0, 1);
	        this.addSlider(this.generalContainer, 'soundVolume', 'Sound Volume', 0, 1, () => mainAudioManager.updateVolumes(), () => {
	            if (!this.soundTestingSound) {
	                // Play this STUPID honk sound or whatever
	                this.soundTestingSound = mainAudioManager.createAudioSource('testing.wav');
	                this.soundTestingSound.setLoop(true);
	                this.soundTestingSound.play();
	            }
	        }, undefined, x => Math.ceil(x * 100).toString());
	        this.addSlider(this.generalContainer, 'keyboardSensitivity', 'Keyboard Speed', 0, 1);
	        /* Touch controls */
	        this.addHeading(this.generalContainer, 'Touch Controls');
	        this.addDropdown(this.generalContainer, 'joystickPosition', 'Joystick Position', ['Fixed', 'Dynamic'], undefined, undefined, true);
	        this.addSlider(this.generalContainer, 'joystickSize', 'Joystick Size', 100, 500, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'joystickLeftOffset', 'Joystick Left Offset', 0, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'joystickVerticalPosition', 'Joystick Vertical Pos', 0, 1, undefined, undefined, undefined, (x) => Math.floor(100 * x) + '%', true);
	        this.addDropdown(this.generalContainer, 'actionButtonOrder', 'Button Order (⤾)', Util.getPermutations(['Blast', 'Jump', 'Use']).map(x => x.join(' - ')), undefined, undefined, true);
	        this.addSlider(this.generalContainer, 'actionButtonSize', 'Button Size', 50, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'actionButtonRightOffset', 'Button Right Offset', 0, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'actionButtonBottomOffset', 'Button Bottom Offset', 0, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'actionButtonAsJoystickMultiplier', 'Button Sensitivity Fac', 0, 3, undefined, undefined, 0.1, (x) => (Math.floor(x * 10) / 10).toString(), true);
	        /* Hotkeys */
	        this.addHotkey(this.hotkeysContainer, 'up');
	        this.addHotkey(this.hotkeysContainer, 'left');
	        this.addHotkey(this.hotkeysContainer, 'down');
	        this.addHotkey(this.hotkeysContainer, 'right');
	        this.addHotkey(this.hotkeysContainer, 'cameraUp');
	        this.addHotkey(this.hotkeysContainer, 'cameraLeft');
	        this.addHotkey(this.hotkeysContainer, 'cameraDown');
	        this.addHotkey(this.hotkeysContainer, 'cameraRight');
	        this.addHotkey(this.hotkeysContainer, 'jump');
	        this.addHotkey(this.hotkeysContainer, 'use');
	        this.addHotkey(this.hotkeysContainer, 'freeLook');
	        this.addHotkey(this.hotkeysContainer, 'restart');
	        this.addHotkey(this.hotkeysContainer, 'blast');
	        // Preload dropdown images
	        await ResourceManager.loadImages(['small', 'medium', 'large', 'xlarge'].map(x => './assets/ui_mbp/options/dropdown-' + x + '.png'));
	    }
	    /** Handles dragging of the currently active slider. */
	    updateSliders() {
	        requestAnimationFrame(() => this.updateSliders());
	        if (!this.currentSliderElement)
	            return;
	        let box = this.currentSliderElement.getBoundingClientRect();
	        let leftOffset = currentMousePosition.x - box.left * SCALING_RATIO - SLIDER_KNOB_LEFT;
	        let completion = Util.clamp(leftOffset / (SLIDER_KNOB_RIGHT - SLIDER_KNOB_LEFT), 0, 1);
	        this.currentSliderCallback(completion);
	    }
	    /** Adds a heading element. */
	    addHeading(container, label) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_heading');
	        element.textContent = label;
	        container.appendChild(element);
	    }
	    /** Adds a dropdown element for a given option. */
	    addDropdown(container, setting, label, choices, boolean = false, onChange, smallText = false, onInfoClick) {
	        const close = () => {
	            // Hide the dropdown
	            clickPreventer.classList.add('hidden');
	            dropdownBackground.classList.add('hidden');
	            optionsContainer.classList.add('hidden');
	            button.style.zIndex = '';
	            selectionLabel.style.zIndex = '';
	        };
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_dropdown');
	        if (smallText)
	            element.classList.add('_small-text');
	        let p = document.createElement('p');
	        p.textContent = label + ':';
	        let button = document.createElement('img');
	        this.menu.setupButton(button, 'options/dropdown', () => {
	            if (clickPreventer.classList.contains('hidden')) {
	                // Show the dropdown
	                clickPreventer.classList.remove('hidden');
	                dropdownBackground.classList.remove('hidden');
	                optionsContainer.classList.remove('hidden');
	                button.style.zIndex = '2';
	                selectionLabel.style.zIndex = '2';
	            }
	            else {
	                close();
	            }
	        });
	        let selectionLabel = document.createElement('p');
	        // Element that prevents anything else from being pressed while the dropdown is shown
	        let clickPreventer = document.createElement('div');
	        clickPreventer.classList.add('hidden');
	        clickPreventer.addEventListener('click', () => close());
	        let dropdownBackground = document.createElement('img');
	        dropdownBackground.classList.add('hidden');
	        dropdownBackground.src = './assets/ui_mbp/options/dropdown-' + ['small', 'medium', 'large', 'xlarge'][Math.min(3, choices.length - 2)] + '.png'; // Choose the size dynamically based on the amount of choices
	        let optionsContainer = document.createElement('div');
	        optionsContainer.classList.add('hidden');
	        for (let option of choices) {
	            let elem = document.createElement('div');
	            elem.textContent = option;
	            optionsContainer.appendChild(elem);
	            elem.addEventListener('mousedown', async () => {
	                close();
	                selectionLabel.textContent = option;
	                let previousValue = StorageManager.data.settings[setting];
	                let newValue = (boolean ? Boolean(choices.indexOf(option)) : choices.indexOf(option)); // TypeScript stupid and I'm lazy
	                if (previousValue === newValue)
	                    return;
	                StorageManager.data.settings[setting] = newValue;
	                await StorageManager.store();
	                onChange === null || onChange === void 0 ? void 0 : onChange();
	            });
	        }
	        element.append(p, button, selectionLabel, clickPreventer, dropdownBackground, optionsContainer);
	        if (onInfoClick) {
	            let infoButton = document.createElement('img');
	            infoButton.src = './assets/svg/info_black_24dp.svg';
	            infoButton.classList.add('_info');
	            element.append(infoButton);
	            infoButton.addEventListener('click', onInfoClick);
	        }
	        container.appendChild(element);
	        this.updateFuncs.push(() => selectionLabel.textContent = choices[Number(StorageManager.data.settings[setting])]);
	    }
	    /** Adds a slider element for a given option. */
	    addSlider(container, setting, label, min, max, onChange, onDragStart, step = 0, showValue, smallText = false) {
	        const updateThumb = () => {
	            let completion = (StorageManager.data.settings[setting] - min) / (max - min);
	            thumb.style.left = Math.floor(Util.lerp(SLIDER_KNOB_LEFT, SLIDER_KNOB_RIGHT, completion)) + 'px';
	            if (showValue)
	                valueElem.textContent = showValue(StorageManager.data.settings[setting]);
	        };
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_slider');
	        if (smallText)
	            element.classList.add('_small-text');
	        let p = document.createElement('p');
	        p.textContent = label + ':';
	        let bar = document.createElement('img');
	        bar.src = './assets/ui_mbp/options/bar.png';
	        const handler = () => {
	            this.currentSliderElement = element;
	            this.currentSliderCallback = (completion) => {
	                StorageManager.data.settings[setting] = Util.roundToMultiple(Util.lerp(min, max, completion), step);
	                updateThumb();
	                onChange === null || onChange === void 0 ? void 0 : onChange();
	            };
	            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart();
	        };
	        bar.addEventListener('mousedown', handler);
	        bar.addEventListener('touchstart', handler);
	        let thumb = document.createElement('img');
	        thumb.src = './assets/ui_mbp/options/slider.png';
	        let valueElem = document.createElement('p');
	        element.append(p, bar, thumb);
	        if (showValue)
	            element.append(valueElem);
	        container.appendChild(element);
	        this.updateFuncs.push(updateThumb);
	    }
	    /** Adds a hotkey rebind element for a given key. */
	    addHotkey(container, key) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_hotkey');
	        let p = document.createElement('p');
	        let map = (state.modification === 'gold') ? buttonToDisplayNameMbg : buttonToDisplayNameMbp;
	        p.textContent = map[key] + ':';
	        let button = document.createElement('img');
	        this.menu.setupButton(button, 'options/bind', () => {
	            this.changeKeybinding(key);
	        });
	        let bindingLabel = document.createElement('p');
	        element.append(p, button, bindingLabel);
	        container.appendChild(element);
	        this.updateFuncs.push(() => bindingLabel.textContent = this.formatKeybinding(key));
	    }
	    /** Adds a configurable button element. */
	    addButton(container, label, buttonLabel, onClick) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_button');
	        let p = document.createElement('p');
	        p.textContent = label + ':';
	        let button = document.createElement('img');
	        this.menu.setupButton(button, 'options/bind', () => onClick());
	        let buttonLabelP = document.createElement('p');
	        buttonLabelP.textContent = buttonLabel;
	        element.append(p, button, buttonLabelP);
	        container.appendChild(element);
	        return element;
	    }
	    addMarbleTexturePicker(container) {
	        let element = this.addButton(container, 'Marble Texture', 'Select File', async () => {
	            await this.showMarbleTexturePicker();
	            resetButton.classList.remove('hidden');
	        });
	        // Add an additional button that removes the texture again
	        let resetButton = document.createElement('img');
	        resetButton.src = './assets/ui_mbp/mp/team/nomarble.png';
	        resetButton.id = 'mbp-reset-marble-texture-button';
	        resetButton.title = "Clear texture";
	        resetButton.classList.add('hidden');
	        resetButton.addEventListener('click', () => {
	            StorageManager.databaseDelete('keyvalue', 'marbleTexture');
	            resetButton.classList.add('hidden');
	        });
	        element.appendChild(resetButton);
	        this.updateFuncs.push(async () => {
	            if ((await StorageManager.databaseCount('keyvalue', 'marbleTexture')) === 0) {
	                resetButton.classList.add('hidden');
	            }
	            else {
	                resetButton.classList.remove('hidden');
	            }
	        });
	    }
	    refreshKeybindings() {
	        this.updateAllElements(); // Can't hurt lol
	    }
	    updateAllElements() {
	        for (let func of this.updateFuncs)
	            func();
	    }
	    show() {
	        super.show();
	        this.updateAllElements();
	    }
	}

	const numberSources = {
	    "0": "0.png",
	    "1": "1.png",
	    "2": "2.png",
	    "3": "3.png",
	    "4": "4.png",
	    "5": "5.png",
	    "6": "6.png",
	    "7": "7.png",
	    "8": "8.png",
	    "9": "9.png",
	    ":": "colon.png",
	    ".": "point.png",
	    "/": "slash.png",
	    "-": "dash.png"
	};
	const keybindRegex = /<func:bind (\w+)>/g;
	class Hud {
	    constructor(menu) {
	        this.frameTimeStore = [];
	        this.centerText = 'none';
	        this.helpText = '';
	        /** The time state at the last point the help text was updated. */
	        this.helpTextTimeState = null;
	        this.alertText = '';
	        /** The time state at the last point the alert text was updated. */
	        this.alertTextTimeState = null;
	        this.menu = menu;
	        this.hudCanvas = document.querySelector('#hud-canvas');
	        this.hudCtx = this.hudCanvas.getContext('2d', {
	            desynchronized: false // There is weird, buggy Chromium behavior when this is true in the MBG HUD. No clue why, yet.
	        });
	        this.fpsMeter = document.querySelector('#fps-meter');
	        this.fpsMeterValue = document.querySelector('#fps-meter-value');
	    }
	    async load() {
	        let imagePathsToLoad = [];
	        imagePathsToLoad.push(...Object.values(numberSources).map(x => {
	            let files = [x];
	            if (this.supportNumberColors && !x.includes('slash') && !x.includes('dash')) {
	                // Also load the colored variants
	                files.push(x.slice(0, x.lastIndexOf('.')) + '_red.png');
	                files.push(x.slice(0, x.lastIndexOf('.')) + '_green.png');
	            }
	            return files.map(y => this.menu.uiAssetPath + "game/numbers/" + y);
	        }).flat());
	        imagePathsToLoad.push(...["ready.png", "set.png", "go.png", "outofbounds.png", "powerup.png"].map(x => this.menu.uiAssetPath + "game/" + x));
	        if (StorageManager.data.settings.showFrameRate && this.supportFpsMeter) {
	            this.fpsMeter.classList.remove('hidden');
	        }
	        else {
	            this.fpsMeter.classList.add('hidden');
	        }
	        if (state.level.mission.hasBlast) {
	            imagePathsToLoad.push(...["blastbar.png", "blastbar_charged.png", "blastbar_bargreen.png", "blastbar_bargray.png"].map(x => "./assets/ui_mbp/game/" + x));
	        }
	        imagePathsToLoad.push(...["./assets/ui_mbp/game/transparency.png"]);
	        await ResourceManager.loadImages(imagePathsToLoad);
	        if (Util.isTouchDevice)
	            this.setupTouchControls();
	        this.helpTextTimeState = null;
	        this.alertTextTimeState = null;
	    }
	    setupTouchControls() {
	        // Change the offset based on whether or not there's a gem counter
	        pauseButton.style.top = state.level.totalGems ? '60px' : '';
	        restartButton.style.top = state.level.totalGems ? '60px' : '';
	        freeLookButton.style.top = state.level.totalGems ? '60px' : '';
	        // Kinda hacky here, don't wanna clean up: (Yes there's a good reason we don't set display)
	        blastButton.style.visibility = state.level.mission.hasBlast ? '' : 'hidden';
	        blastButton.style.pointerEvents = state.level.mission.hasBlast ? '' : 'none';
	        freeLookButton.style.visibility = StorageManager.data.settings.alwaysFreeLook ? 'hidden' : '';
	        freeLookButton.style.pointerEvents = StorageManager.data.settings.alwaysFreeLook ? 'none' : '';
	        this.fpsMeter.style.transform = 'scale(0.5)';
	        this.fpsMeter.querySelector('img').style.borderRight = '50px solid #ffffff4d'; // To make it visible with rounded corners
	        this.fpsMeterValue.style.marginRight = '50px';
	        // Adjust layout based on user settings:
	        let joystickSize = StorageManager.data.settings.joystickSize;
	        let joystickHandleSize = JOYSTICK_HANDLE_SIZE_FACTOR * joystickSize;
	        movementJoystick.style.width = joystickSize + 'px';
	        movementJoystick.style.height = joystickSize + 'px';
	        movementJoystick.style.borderRadius = joystickHandleSize / 2 + 'px';
	        movementJoystickHandle.style.width = joystickHandleSize + 'px';
	        movementJoystickHandle.style.height = joystickHandleSize + 'px';
	        let scale = StorageManager.data.settings.actionButtonSize / 120;
	        actionButtonContainer.style.right = StorageManager.data.settings.actionButtonRightOffset / scale + 'px';
	        actionButtonContainer.style.bottom = StorageManager.data.settings.actionButtonBottomOffset / scale + 'px';
	        actionButtonContainer.style.transform = `scale(${scale})`;
	        // Reorder the action buttons as needed
	        let offsets = [{ right: 0, bottom: 135 }, { right: 0, bottom: 0 }, { right: 135, bottom: 0 }];
	        let arr = Util.getPermutations([blastButton, jumpButton, useButton])[StorageManager.data.settings.actionButtonOrder];
	        for (let button of arr) {
	            button.style.right = offsets[arr.indexOf(button)].right + 'px';
	            button.style.bottom = offsets[arr.indexOf(button)].bottom + 'px';
	        }
	    }
	    setSize(width, height, pixelRatio) {
	        let canvasWidth = Math.ceil(width * pixelRatio);
	        let canvasHeight = Math.ceil(height * pixelRatio);
	        this.hudCanvas.setAttribute("width", canvasWidth.toString());
	        this.hudCanvas.setAttribute("height", canvasHeight.toString());
	        let scalingRatio = computeUiScalingRatio(width, height);
	        this.width = Math.ceil(width * scalingRatio);
	        this.height = Math.ceil(height * scalingRatio);
	    }
	    /** Renders the entire HUD onto a canvas. */
	    renderHud(timeState) {
	        var _a, _b, _c, _d;
	        const ctx = this.hudCtx;
	        const level = state.level;
	        const { width, height } = this;
	        // Scale the context so that it spans the entire, actual width of the canvas
	        let scale = this.hudCanvas.width / this.width;
	        ctx.resetTransform();
	        ctx.scale(scale, scale);
	        ctx.clearRect(0, 0, width, height);
	        // Draw the clock background
	        if (this.showClockBackground) {
	            let clockBackground = ResourceManager.getImageFromCache('./assets/ui_mbp/game/transparency.png');
	            ctx.drawImage(clockBackground, Math.floor(width / 2 - 220 / 2 + 3), -10, 220, 79);
	        }
	        // This might seem a bit strange, but the time we display is actually a few milliseconds in the PAST (unless the user is currently in TT or has finished), for the reason that time was able to go backwards upon finishing or collecting TTs due to CCD time correction. That felt wrong, so we accept this inaccuracy in displaying time for now.
	        let timeToDisplay = timeState.gameplayClock;
	        if (level.finishTime)
	            timeToDisplay = level.finishTime.gameplayClock;
	        if (level.currentTimeTravelBonus === 0 && !level.finishTime)
	            timeToDisplay = Math.max(timeToDisplay - 1000 / PHYSICS_TICK_RATE, 0);
	        level.maxDisplayedTime = Math.max(timeToDisplay, level.maxDisplayedTime);
	        if (level.currentTimeTravelBonus === 0 && !level.finishTime)
	            timeToDisplay = level.maxDisplayedTime;
	        timeToDisplay = Math.min(timeToDisplay, MAX_TIME);
	        // Draw the clock
	        this.drawNumbers(Util.secondsToTimeString(timeToDisplay / 1000), width / 2, 0, true, this.determineClockColor(timeToDisplay));
	        // Draw the gem count
	        if (level.totalGems > 0) {
	            let string = Util.leftPadZeroes(level.gemCount.toString(), this.gemCountMinDigits) + '/' + Util.leftPadZeroes(level.totalGems.toString(), this.gemCountMinDigits);
	            this.drawNumbers(string, 30, 0, false);
	        }
	        // Draw the power-up border (always there)
	        let powerUpBorder = ResourceManager.getImageFromCache(this.menu.uiAssetPath + "game/powerup.png");
	        ctx.drawImage(powerUpBorder, width - powerUpBorder.width - 5, 5);
	        // Draw the center text
	        if (this.centerText !== 'none') {
	            let image = ResourceManager.getImageFromCache(this.menu.uiAssetPath + 'game/' + this.centerText + '.png');
	            ctx.drawImage(image, Math.floor((width - image.width) / 2), Math.floor(height * 0.3));
	        }
	        let helpTextTime = (_b = (_a = this.helpTextTimeState) === null || _a === void 0 ? void 0 : _a.timeSinceLoad) !== null && _b !== void 0 ? _b : -Infinity;
	        let alertTextTime = (_d = (_c = this.alertTextTimeState) === null || _c === void 0 ? void 0 : _c.timeSinceLoad) !== null && _d !== void 0 ? _d : -Infinity;
	        let helpTextCompletion = Util.clamp((timeState.timeSinceLoad - helpTextTime - 3000) / 1000, 0, 1) ** 2;
	        let alertTextCompletion = Util.clamp((timeState.timeSinceLoad - alertTextTime - 3000) / 1000, 0, 1) ** 2;
	        // Draw the help text
	        if (helpTextCompletion < 1) {
	            let white = { r: 255, g: 255, b: 255, a: 255 };
	            let black = { r: 0, g: 0, b: 0, a: 255 };
	            let color = Util.lerpColors(white, black, Util.lerp(0, 0.5, helpTextCompletion));
	            ctx.font = '24px DomCasualRegular';
	            ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
	            ctx.textAlign = 'center';
	            ctx.textBaseline = 'top';
	            ctx.shadowColor = state.modification === 'gold' ? 'black' : '#777777';
	            ctx.shadowOffsetX = 1;
	            ctx.shadowOffsetY = 1;
	            ctx.globalAlpha = 1 - helpTextCompletion;
	            let lines = this.breakTextIntoLines(this.helpText, width);
	            for (let i = 0; i < lines.length; i++) {
	                ctx.fillText(lines[i], Math.floor(width / 2), Math.floor(height * 0.45) + 24 * 1.2 * i);
	            }
	            ctx.shadowColor = 'transparent';
	            ctx.shadowOffsetX = 0;
	            ctx.shadowOffsetY = 0;
	            ctx.globalAlpha = 1;
	        }
	        // Draw the alert text
	        if (alertTextCompletion < 1) {
	            let yellow = state.modification === 'gold' ? { r: 255, g: 226, b: 64, a: 255 } : { r: 228, g: 211, b: 64, a: 129 };
	            let black = { r: 0, g: 0, b: 0, a: 255 };
	            let color = Util.lerpColors(yellow, black, Util.lerp(0, 0.5, alertTextCompletion));
	            ctx.font = '24px DomCasualRegular';
	            ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
	            ctx.textAlign = 'center';
	            ctx.textBaseline = 'bottom';
	            ctx.shadowColor = state.modification === 'gold' ? 'black' : 'rgb(119, 102, 34)';
	            ctx.shadowOffsetX = 1;
	            ctx.shadowOffsetY = 1;
	            ctx.globalAlpha = 1 - alertTextCompletion;
	            let lines = this.breakTextIntoLines(this.alertText, width);
	            for (let i = 0; i < lines.length; i++) {
	                ctx.fillText(lines[i], Math.floor(width / 2), height - 30 - 24 * 1.2 * (lines.length - i - 1));
	            }
	            ctx.shadowColor = 'transparent';
	            ctx.shadowOffsetX = 0;
	            ctx.shadowOffsetY = 0;
	            ctx.globalAlpha = 1;
	        }
	        // Draw debug mode text
	        if (mainRenderer.debugMode !== 0) {
	            ctx.font = '24px DomCasualRegular';
	            ctx.fillStyle = 'white';
	            ctx.textAlign = 'center';
	            ctx.textBaseline = 'bottom';
	            ctx.shadowColor = 'black';
	            ctx.shadowOffsetX = 1;
	            ctx.shadowOffsetY = 1;
	            ctx.globalAlpha = 1;
	            let debugText = "Debug Rendering: ";
	            switch (mainRenderer.debugMode) {
	                case 1:
	                    debugText += "UV";
	                    break;
	                case 2:
	                    debugText += "Normal (World)";
	                    break;
	                case 3:
	                    debugText += "Normal (Map)";
	                    break;
	                case 4:
	                    debugText += "Normal (Multiplied)";
	                    break;
	                case 5:
	                    debugText += "Tangent";
	                    break;
	                case 6:
	                    debugText += "Tangent A";
	                    break;
	                case 7:
	                    debugText += "TBN[T]";
	                    break;
	                case 8:
	                    debugText += "TBN[B]";
	                    break;
	                case 9:
	                    debugText += "TBN[N]";
	                    break;
	                default:
	                    debugText = "";
	                    break;
	            }
	            ctx.fillText(debugText, Math.floor(width / 2), 100);
	            ctx.shadowColor = 'transparent';
	            ctx.shadowOffsetX = 0;
	            ctx.shadowOffsetY = 0;
	            ctx.globalAlpha = 1;
	        }
	        // Draw the blast meter
	        if (level.mission.hasBlast) {
	            let amount = level.blastAmount;
	            let offset = new Vector2(7, 34);
	            if (Util.isTouchDevice)
	                offset.set(20, 47); // To make it visible with rounded corners
	            let blastMeterFillSrc = `./assets/ui_mbp/game/blastbar_bar${(amount >= 0.2) ? 'green' : 'gray'}.png`;
	            let fillImage = ResourceManager.getImageFromCache(blastMeterFillSrc);
	            ctx.drawImage(fillImage, offset.x + 5, height - offset.y + 5, Util.clamp(amount, 0, 1) * 109, 17);
	            let bodyImage = ResourceManager.getImageFromCache((amount > 1) ? './assets/ui_mbp/game/blastbar_charged.png' : './assets/ui_mbp/game/blastbar.png');
	            ctx.drawImage(bodyImage, offset.x, height - offset.y);
	        }
	    }
	    determineClockColor(timeToDisplay) {
	        if (state.modification === 'gold')
	            return;
	        const level = state.level;
	        if (level.finishTime)
	            return 'green'; // Even if not qualified
	        if (level.timeState.currentAttemptTime < GO_TIME || level.currentTimeTravelBonus > 0)
	            return 'green';
	        if (timeToDisplay >= level.mission.qualifyTime)
	            return 'red';
	        if (level.timeState.currentAttemptTime >= GO_TIME && isFinite(level.mission.qualifyTime) && state.modification === 'platinum') {
	            // Create the flashing effect
	            let alarmStart = level.mission.computeAlarmStartTime();
	            let elapsed = timeToDisplay - alarmStart;
	            if (elapsed < 0)
	                return;
	            if (Math.floor(elapsed / 1000) % 2 === 0)
	                return 'red';
	        }
	        return; // Default yellow
	    }
	    drawNumbers(string, x, y, isClock, specialColor) {
	        const defaultWidth = 43;
	        const defaultMarginRight = -19;
	        let currentX = 0;
	        if (isClock) {
	            let totalWidth = (string.length - 1) * (defaultWidth + defaultMarginRight) - (2 * (defaultWidth + defaultMarginRight - 10)) + defaultWidth;
	            x = Math.floor(x - totalWidth / 2);
	        }
	        // Draw every symbol
	        for (let i = 0; i < string.length; i++) {
	            let char = string[i];
	            let path = this.menu.uiAssetPath + "game/numbers/" + numberSources[char];
	            if (this.supportNumberColors && specialColor)
	                path = path.slice(0, path.lastIndexOf('.')) + '_' + specialColor + '.png';
	            let image = ResourceManager.getImageFromCache(path);
	            if (char === ':' || char === '.')
	                currentX -= 3;
	            this.hudCtx.drawImage(image, x + currentX, 0);
	            currentX += defaultWidth + defaultMarginRight;
	            if (char === ':' || char === '.')
	                currentX -= 7;
	        }
	    }
	    /** Breaks a text into a list of lines that together make up that text. Lines are created by regular line break characters or by lines being broken up because they're too wide. */
	    breakTextIntoLines(text, maxWidth) {
	        let lines = text.split('\n');
	        for (let i = 0; i < lines.length; i++) {
	            let line = lines[i];
	            let metrics = this.hudCtx.measureText(line);
	            // Check if the line is too wide
	            if (metrics.width > maxWidth) {
	                let words = line.split(' ');
	                let low = 0;
	                let high = words.length - 1;
	                let ans = 0;
	                // Do a binary search on how many words we can include in the line before it becomes too wide
	                while (low <= high) {
	                    let mid = Math.floor(low + (high - low + 1) / 2);
	                    let text = words.slice(0, mid + 1).join(' ');
	                    let width = this.hudCtx.measureText(text).width;
	                    if (width <= maxWidth) {
	                        low = mid + 1;
	                        ans = mid;
	                    }
	                    else {
	                        high = mid - 1;
	                    }
	                }
	                // Create two new lines, the updated shorter one and the remaining text as the following line.
	                let updatedLine = words.slice(0, ans + 1).join(' ');
	                let nextLine = words.slice(ans + 1).join(' ');
	                lines[i] = updatedLine;
	                lines.splice(i + 1, 0, nextLine);
	            }
	        }
	        return lines;
	    }
	    /** Makes the powerup button visible/invisible depending on state and forceUpdate, see code. */
	    setPowerupButtonState(enabled, forceUpdate = false) {
	        if (Util.isTouchDevice) {
	            setUseEnabled(enabled);
	            if (enabled || forceUpdate)
	                useButton.style.opacity = '0.5';
	            if (!enabled && forceUpdate)
	                useButton.style.opacity = '0.2';
	        }
	    }
	    /** Displays a help message in the middle of the screen. */
	    displayHelp(message, playSound = false) {
	        keybindRegex.lastIndex = 0;
	        let match;
	        // Search the string for possible keybind references. If found, replace them with the key bound to that keybind.
	        while ((match = keybindRegex.exec(message)) !== null) {
	            let gameButton = {
	                "moveforward": "up",
	                "movebackward": "down",
	                "moveleft": "left",
	                "moveright": "right",
	                "jump": "jump",
	                "mousefire": "use",
	                "panup": "cameraUp",
	                "pandown": "cameraDown",
	                "panleft": "cameraLeft",
	                "panright": "cameraRight",
	                "turnup": "cameraUp",
	                "turndown": "cameraDown",
	                "turnleft": "cameraLeft",
	                "turnright": "cameraRight",
	                "freelook": "freeLook",
	                "useblast": "blast"
	            }[match[1].toLowerCase()];
	            if (!gameButton)
	                continue;
	            let keyName = Util.getKeyForButtonCode(StorageManager.data.settings.gameButtonMapping[gameButton]);
	            message = message.slice(0, match.index) + keyName + message.slice(match.index + match[0].length);
	            keybindRegex.lastIndex -= match[0].length;
	        }
	        // A few hardcoded messages from Marble Blast Mobile
	        if (message === 'MSG_FINDALLTHEGEMS')
	            message = "Find all the gems!";
	        if (message === 'MSG_RACETOTHEFINISH')
	            message = "Race to the finish!";
	        this.helpText = message;
	        this.helpTextTimeState = Util.jsonClone(state.level.timeState);
	        if (playSound)
	            state.level.audio.play('infotutorial.wav');
	    }
	    /** Displays an alert at the bottom of the screen. */
	    displayAlert(message) {
	        this.alertText = message;
	        this.alertTextTimeState = Util.jsonClone(state.level.timeState);
	    }
	    setCenterText(type) {
	        this.centerText = type;
	    }
	    displayFps() {
	        var _a;
	        if (!(StorageManager.data.settings.showFrameRate && this.supportFpsMeter))
	            return;
	        let now = performance.now();
	        this.frameTimeStore.push(now);
	        // Remove all frame times that were over a second ago
	        while (this.frameTimeStore.length && this.frameTimeStore[0] + 1000 <= now)
	            this.frameTimeStore.shift();
	        let value = this.frameTimeStore.length;
	        value /= Math.min(1, (_a = state.level.timeState.timeSinceLoad / 1000) !== null && _a !== void 0 ? _a : 1); // Hack to make it reach the final frame rate faster
	        value = Math.floor(value);
	        let settingsTarget = FRAME_RATE_OPTIONS[StorageManager.data.settings.frameRateCap];
	        if (value === 59 || value === 119 || value === 143 || value === 239 || value === settingsTarget - 1)
	            value++; // Snap to the most common frame rates
	        if (value === 61 || value === 121 || value === 145 || value === 241 || value === settingsTarget + 1)
	            value--;
	        this.fpsMeterValue.textContent = 'FPS: ' + value;
	    }
	}

	class MbpHud extends Hud {
	    constructor() {
	        super(...arguments);
	        this.gemCountMinDigits = 3;
	        this.showClockBackground = true;
	        this.supportNumberColors = true;
	        this.supportFpsMeter = true;
	    }
	}

	class Sky extends Shape {
	    constructor(type) {
	        super();
	        this.collideable = false;
	        this.dtsPath = `shapes/skies/${type}/${type}.dts`;
	    }
	}

	class Glass extends Shape {
	    constructor(dataBlock) {
	        super();
	        let dim = /glass_(\d+)shape/.exec(dataBlock)[1];
	        this.dtsPath = `shapes/glass/${dim}x3.dts`;
	        this.colliderDtsPath = `shapes/glass/col/${dim}x3.dts`;
	    }
	}

	class Blast extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = 'shapes/items/blast.dts';
	        this.autoUse = true;
	        this.sounds = ["publastvoice.wav"];
	        this.pickUpName = "Blast PowerUp";
	    }
	    pickUp() {
	        this.level.audio.play(this.sounds[0]);
	        return true;
	    }
	    use() {
	        this.level.blastAmount = 1.03;
	    }
	}

	class MegaMarble extends PowerUp {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = 'shapes/items/megamarble.dts';
	        this.sounds = ["pumegamarblevoice.wav", "dosuperjump.wav", "mega_bouncehard1.wav", "mega_bouncehard2.wav", "mega_bouncehard3.wav", "mega_bouncehard4.wav", "mega_roll.wav"];
	        this.pickUpName = "Mega Marble PowerUp";
	    }
	    pickUp() {
	        return this.level.pickUpPowerUp(this);
	    }
	    use() {
	        this.level.marble.enableMegaMarble(this.level.timeState);
	        this.level.deselectPowerUp();
	        this.level.audio.play(this.sounds[1]);
	    }
	}

	var materialVert = "precision highp float;\nprecision highp int;\n\n#include <definitions>\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 tangent;\nattribute vec2 uv;\nattribute float meshInfoIndex;\n\nuniform highp sampler2D meshInfos; // This is where mesh transformation and other things about the mesh are stored in\nuniform int meshInfoTextureWidth;\nuniform int meshInfoTextureHeight;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform bool skipTransparent;\nuniform mat4 directionalLightTransform;\nuniform vec3 eyePosition;\nuniform float materialOpacity;\n\nvarying vec4 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying vec4 vShadowPosition;\nvarying vec3 vReflect;\nvarying mat3 vTbn;\nvarying vec4 vTangent;\nvarying float vFragDepth;\nvarying float vIsPerspective;\nvarying vec3 eyeDirection;\n\n#ifdef IS_WEBGL1\n\tmat3 transpose(mat3 inMatrix) {\n\t\tvec3 i0 = inMatrix[0];\n\t\tvec3 i1 = inMatrix[1];\n\t\tvec3 i2 = inMatrix[2];\n\n\t\tmat3 outMatrix = mat3(\n\t\t\tvec3(i0.x, i1.x, i2.x),\n\t\t\tvec3(i0.y, i1.y, i2.y),\n\t\t\tvec3(i0.z, i1.z, i2.z)\n\t\t);\n\n\t\treturn outMatrix;\n\t}\n\n\t// http://www.thetenthplanet.de/archives/1180\n\tmat3 inverse(mat3 M) {\n\t\tmat3 M_t = transpose(M);\n\t\tfloat det = dot(cross(M_t[0], M_t[1]), M_t[2]);\n\t\tmat3 adjugate = mat3(cross(M_t[1], M_t[2]), cross(M_t[2], M_t[0]), cross(M_t[0], M_t[1]));\n\t\treturn adjugate / det;\n\t}\n#endif\n\n// _ here because on some systems, \"mod\" is already defined?\nint _mod(int a, int n) {\n\t#ifdef IS_WEBGL1\n\t\treturn a - n * (a / n);\n\t#else\n\t\treturn a % n;\n\t#endif\n}\n\n// Gets the mesh info for the mesh at a specific index. The mesh info contains its transformation and other things.\nmat4 getMeshInfo(int index) {\n\t// Figure out where we need to sample the texture\n\tivec2 coords = ivec2(\n\t\t_mod(4 * index, meshInfoTextureWidth),\n\t\t(4 * index) / meshInfoTextureWidth\n\t);\n\n\t#ifdef IS_WEBGL1\n\t\t// Primitive way, sample with texture coordinates\n\t\treturn mat4(\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(0, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(1, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(2, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(3, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight))\n\t\t);\n\t#else\n\t\t// Better way, sample with pixel coordinates\n\t\treturn mat4(\n\t\t\ttexelFetch(meshInfos, coords + ivec2(0, 0), 0),\n\t\t\ttexelFetch(meshInfos, coords + ivec2(1, 0), 0),\n\t\t\ttexelFetch(meshInfos, coords + ivec2(2, 0), 0),\n\t\t\ttexelFetch(meshInfos, coords + ivec2(3, 0), 0)\n\t\t);\n\t#endif\n}\n\nbool isPerspectiveMatrix(mat4 m) {\n\treturn m[2][3] == -1.0; // Taken from three.js, no clue how this works\n}\n\nvoid main() {\n\t#ifdef IS_SKY\n\t\t// https://gamedev.stackexchange.com/a/60377\n\t\tmat4 inverseProjection = inverseProjectionMatrix;\n\t\tmat3 inverseModelView = transpose(mat3(viewMatrix));\n\t\tvec3 unprojected = (inverseProjection * vec4(position, 1.0)).xyz;\n\t\teyeDirection = inverseModelView * unprojected;\n\t\t\n\t\tgl_Position = vec4(position, 1.0);\n\t#else\n\t\tmat4 meshInfo = getMeshInfo(int(meshInfoIndex + 0.1)); // + 0.1 to make sure it casts correctly, lol\n\t\tmat4 transform = meshInfo;\n\t\ttransform[0][3] = 0.0; // The last row of a transformation matrix is always the same, so set it to what it should be\n\t\ttransform[1][3] = 0.0;\n\t\ttransform[2][3] = 0.0;\n\t\ttransform[3][3] = 1.0;\n\t\tfloat opacity = meshInfo[0][3];\n\t\tint meshFlags = int(meshInfo[1][3]);\n\n\t\topacity *= materialOpacity;\n\t\tvOpacity = opacity;\n\n\t\tif (skipTransparent && opacity < 1.0) {\n\t\t\t// The object isn't fully opaque, so skip it\n\t\t\tgl_Position = vec4(0.0);\n\t\t\treturn;\n\t\t}\n\n\t\tvec4 worldPosition = transform * vec4(position, 1.0);\n\t\tvPosition = worldPosition;\n\n\t\tmat4 mvp = projectionMatrix * viewMatrix * transform; // Combine them into a single matrix to reduce possible precision errors\n\t\tgl_Position = mvp * vec4(position, 1.0);\n\n\t\tvUv = uv;\n\t\t#ifdef FLIP_Y\n\t\t\tvUv.y = 1.0 - vUv.y;\n\t\t#endif\n\n\t\t// Compute the transformation matrix for normals (not tangents, tho!)\n\t\t// Note that when the transformation doesn't involve any scaling, the upper mat3 part is orthonormal meaning its inverse is equal to its transpose. In this case, normalTransform == mat3(transform).\n\t\tmat3 normalTransform = transpose(inverse(mat3(transform)));\n\n\t\tvec3 transformedNormal = normalTransform * normal;\n\t\t#ifdef NORMALIZE_NORMALS\n\t\t\t// Many normals, like those used in the tornado, are actually not normalized\n\t\t\ttransformedNormal = normalize(transformedNormal);\n\t\t#endif\n\t\tvNormal = transformedNormal;\n\n\t\tvTangent = tangent; // Needed so that it doesn't get optimized out (fucks with vertex attributes somehow)\n\t\t#ifdef USE_NORMAL_MAP\n\t\t\tvec3 N = transformedNormal;\n\t\t\tvec3 T = normalize((transform * vec4(tangent.xyz, 0.0)).xyz);\n\t\t\t// re-orthogonalize T with respect to N\n\t\t\tT = normalize(T - dot(T, N) * N);\n\t\t\t// then retrieve perpendicular vector B with the cross product of T and N\n\t\t\tvec3 B = cross(N, T) * tangent.w;\n\t\t\tmat3 tbn = mat3(T, B, N);\n\t\t\tvTbn = tbn;\n\t\t#endif\n\n\t\t#if defined(RECEIVE_SHADOWS) || defined(IS_SHADOW)\n\t\t\t// Compute where we are within shadow camera view space\n\t\t\tvShadowPosition = directionalLightTransform * worldPosition;\n\t\t#endif\n\n\t\t#if defined(USE_ENV_MAP) && !defined(USE_ACCURATE_REFLECTION_RAY)\n\t\t\t// Compute the reflection ray\n\t\t\tvec3 incidentRay = normalize(worldPosition.xyz - eyePosition);\n\t\t\tvec3 reflected = reflect(incidentRay, normalize(transformedNormal));\n\t\t\tvReflect = reflected;\n\t\t#endif\n\n\t\t#ifdef LOG_DEPTH_BUF\n\t\t\t// Some values we need to pass along for logarithmic depth buffer stuffs\n\t\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\t\tvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\n\t\t#endif\n\t#endif\n}";

	var materialFrag = "precision mediump float;\n\n#define SHADOW_RADIUS 2\n#include <definitions>\n\n// This condition here is necessary to save on varying vectors; some mobile devices (*cough* iPhones *cough*) only support 8 varying vec4s, and this separation here makes sure we stay just under that. If, in the future, more varyings will be necessary, this condition can always be refined more. Also, apparently I'm not allowed to indent 'varying'.\n#ifdef IS_SKY\nvarying vec3 eyeDirection;\n#else\nvarying vec4 vPosition;\nvarying vec2 vUv;\nvarying vec3 vNormal;\n//varying vec4 vTangent; // Using this drops support with WebGL 1 on iOS, too many varyings\nvarying float vOpacity;\nvarying vec4 vShadowPosition;\nvarying vec3 vReflect;\nvarying mat3 vTbn; // Matrix used to transform the normal map vectors\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#endif\n\nuniform sampler2D diffuseMap;\nuniform samplerCube envMap;\nuniform sampler2D normalMap;\nuniform sampler2D specularMap;\nuniform sampler2D noiseMap;\n\nuniform float reflectivity;\nuniform highp vec3 eyePosition;\nuniform float specularIntensity;\nuniform float shininess;\nuniform float logDepthBufFC;\nuniform float secondaryMapUvFactor;\nuniform int debugMode;\n\nuniform vec3 ambientLight;\nuniform vec3 directionalLightColor;\nuniform vec3 directionalLightDirection;\nuniform mediump sampler2D directionalLightShadowMap;\n\n#if defined(LOG_DEPTH_BUF) && defined(IS_WEBGL1)\n\t#extension GL_EXT_frag_depth : enable // For some reason, the extension needs to be enabled in-shader\n#endif\n\n// Computes standard Lambertian reflectance\nfloat lambert(vec3 normal, vec3 lightPosition) {\n\tfloat result = dot(normal, lightPosition);\n\treturn max(result, 0.0);\n}\n\n#ifdef IS_WEBGL1\n\tmat3 transpose(mat3 inMatrix) {\n\t\tvec3 i0 = inMatrix[0];\n\t\tvec3 i1 = inMatrix[1];\n\t\tvec3 i2 = inMatrix[2];\n\n\t\tmat3 outMatrix = mat3(\n\t\t\tvec3(i0.x, i1.x, i2.x),\n\t\t\tvec3(i0.y, i1.y, i2.y),\n\t\t\tvec3(i0.z, i1.z, i2.z)\n\t\t);\n\n\t\treturn outMatrix;\n\t}\n#endif\n\nvec4 sampleCubeTexture(samplerCube tex, vec3 uvw) {\n\t#ifdef ENV_MAP_Z_UP\n\t\tuvw.yz = vec2(uvw.z, -uvw.y); // Rotate the \"cube\" about the x-axis because by default, cubemaps are Y-up but we're in Z-up space\n\t#endif\n\n\treturn textureCube(tex, uvw);\n}\n\n// Gets the intensity of a shadow given a point in shadow camera view space\nfloat getShadowIntensity(sampler2D map, vec4 shadowPosition, int mapSize) {\n\tvec3 projectedTexcoord = shadowPosition.xyz / shadowPosition.w;\n\tprojectedTexcoord = (projectedTexcoord + vec3(1.0)) / 2.0; // From [-1, 1] to [0, 1]\n\n\t// Check if we're even within the bounds of the shadow texture\n\tbool inBounds =\n\t\tmin(projectedTexcoord.x, min(projectedTexcoord.y, projectedTexcoord.z)) > 0.0 &&\n\t\tmax(projectedTexcoord.x, max(projectedTexcoord.y, projectedTexcoord.z)) < 1.0;\n\t\n\tif (!inBounds) return 0.0; // If not, say there's no shadow\n\n\tfloat mapSizeF = float(mapSize);\n\tfloat total = 0.0;\n\n\t// Sample the texture in an area to soften it a bit\n\tfor (int x = -SHADOW_RADIUS; x <= SHADOW_RADIUS; x++) {\n\t\tfor (int y = -SHADOW_RADIUS; y <= SHADOW_RADIUS; y++) {\n\t\t\tvec2 uv = projectedTexcoord.xy + vec2(float(x) / mapSizeF, float(y) / mapSizeF);\n\t\t\tfloat depthValue = texture2D(map, uv.xy).r;\n\t\t\tif (depthValue < projectedTexcoord.z) total += 1.0;\n\t\t}\n\t}\n\n\treturn mix(total / float((SHADOW_RADIUS*2+1)*(SHADOW_RADIUS*2+1)), 0.0, projectedTexcoord.z * projectedTexcoord.z);\n}\n\n// Fresnel-Schlick approximation\nfloat fresnel(vec3 direction, vec3 normal, bool invert) {\n\tvec3 nDirection = normalize(direction);\n\tvec3 nNormal = normalize(normal);\n\tvec3 halfDirection = normalize(nNormal + nDirection);\n\n\tfloat exponent = 5.0;\n\tfloat cosine = dot(halfDirection, nDirection);\n\tfloat product = max(cosine, 0.0);\n\tfloat factor = invert ? 1.0 - pow(product, exponent) : pow(product, exponent);\n\t\n\treturn factor;\n}\n\nvoid main() {\n\t#if defined(LOG_DEPTH_BUF) && !defined(IS_SKY)\n\t\t// We always need to set gl_FragDepthEXT when it's present in the file, otherwise it gets real weird\n\t\t// Also: Doing a strict comparison with == 1.0 can cause noise artifacts\n\t\tgl_FragDepthEXT = (vIsPerspective != 0.0)? log2(vFragDepth) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n\t#endif\n\n\t#ifdef IS_SKY\n\t\t// We simply sample the skybox cube texture and we're done.\n\t\tvec4 sampled = sampleCubeTexture(envMap, eyeDirection);\n\t\tgl_FragColor = sampled;\n\t#elif defined(IS_SHADOW)\n\t\tbool hasDirectionalLight = dot(directionalLightDirection, directionalLightDirection) > 0.0;\n\t\tfloat intensity = getShadowIntensity(directionalLightShadowMap, vShadowPosition, 250);\n\t\tif (!hasDirectionalLight) intensity = 0.0;\n\t\t\n\t\tgl_FragColor = vec4(vec3(0.0), intensity * 0.25); // Note that this intensity differs from the one used in the normal shader path. That's because with a separate shadow material, it's actually difficult to figure out how dark the shadow should be - so whatever value we picked here just looked the least odd.\n\t#else\n\t\tvec4 diffuse = vec4(1.0);\n\n\t\t#ifdef USE_DIFFUSE_MAP\n\t\t\tdiffuse = texture2D(diffuseMap, vUv);\n\t\t\t#ifndef TRANSPARENT\n\t\t\t\tdiffuse.a = 1.0;\n\t\t\t#endif\n\t\t#endif\n\n\t\t#ifdef USE_NOISE_MAP\n\t\t\t// Sample the noise texture multiple times to create the tiling effect found in MBU textures. Code is taken from MBU shaders!\n\n\t\t\tvec2 noiseIndex;\n\t\t\tvec4 noiseColor[4];\n\t\t\tvec2 halfPixel = vec2(1.0 / 64.0, 1.0 / 64.0);\n\n\t\t\tnoiseIndex.x = floor(vUv.x - halfPixel.x) / 63.0 + 0.5/64.0;\n\t\t\tnoiseIndex.y = floor(vUv.y - halfPixel.y) / 63.0 + 0.5/64.0;\n\t\t\tnoiseColor[0] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\n\n\t\t\tnoiseIndex.x = floor(vUv.x - halfPixel.x) / 63.0 + 0.5/64.0;\n\t\t\tnoiseIndex.y = floor(vUv.y + halfPixel.y) / 63.0 + 0.5/64.0;\n\t\t\tnoiseColor[1] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\n\n\t\t\tnoiseIndex.x = floor(vUv.x + halfPixel.x) / 63.0 + 0.5/64.0;\n\t\t\tnoiseIndex.y = floor(vUv.y + halfPixel.y) / 63.0 + 0.5/64.0;\n\t\t\tnoiseColor[2] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\n\n\t\t\tnoiseIndex.x = floor(vUv.x + halfPixel.x) / 63.0 + 0.5/64.0;\n\t\t\tnoiseIndex.y = floor(vUv.y - halfPixel.y) / 63.0 + 0.5/64.0;\n\t\t\tnoiseColor[3] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\n\n\t\t\tvec4 finalNoiseCol = (noiseColor[0] + noiseColor[1] + noiseColor[2] + noiseColor[3]) / 4.0;\n\t\t\tdiffuse.rgb *= 1.0 + finalNoiseCol.r; // This isn't how MBU does it afaik but it looks good :o\n\t\t#endif\n\n\t\tdiffuse.a *= vOpacity; // Multiply the diffuse by the whole mesh's opacity (and the material's opacity)\n\n\t\tvec3 incomingLight = vec3(0.0);\n\t\tvec3 specularLight = vec3(0.0);\n\n\t\t#ifdef EMISSIVE\n\t\t\tincomingLight = vec3(1.0);\n\t\t#else\n\t\t\tincomingLight += ambientLight;\n\n\t\t\tvec3 normal = vNormal;\n\n\t\t\t#ifdef USE_NORMAL_MAP\n\t\t\t\t// Overwrite the normal with the sampled one\n\t\t\t\tvec3 map = texture2D(normalMap, secondaryMapUvFactor * vUv).xyz;\n\t\t\t\tmap = map * 255.0/127.0 - 128.0/127.0;\n\t\t\t\t#ifdef INVERT_U\n\t\t\t\t\tmap.x = -map.x;\n\t\t\t\t#endif\n\t\t\t\tnormal = vTbn * map; // Don't normalize here! Reduces aliasing effects\n\t\t\t#endif\n\n\t\t\tvec3 addedLight = directionalLightColor * lambert(normal, -directionalLightDirection);\n\n\t\t\t#ifdef SATURATE_INCOMING_LIGHT\n\t\t\t\t// MBG saturates the incoming light to be at most 1.0\n\t\t\t\taddedLight = min(vec3(1.0), incomingLight + addedLight) - incomingLight;\n\t\t\t#endif\n\n\t\t\t#ifdef RECEIVE_SHADOWS\n\t\t\t\t// When the direction has zero length, we make the assumption that there is no directional light in the scene.\n\t\t\t\tbool hasDirectionalLight = dot(directionalLightDirection, directionalLightDirection) > 0.0;\n\t\t\t\tfloat intensity = getShadowIntensity(directionalLightShadowMap, vShadowPosition, 250);\n\t\t\t\tif (!hasDirectionalLight) intensity = 0.0;\n\n\t\t\t\taddedLight *= mix(1.0, 0.666, intensity);\n\t\t\t#endif\n\t\t\t\n\t\t\tincomingLight += addedLight;\n\n\t\t\t#ifdef USE_SPECULAR\n\t\t\t\tvec3 viewDir = normalize(eyePosition - vPosition.xyz);\n\t\t\t\tvec3 halfwayDir = normalize(-directionalLightDirection + viewDir); // Blinn-Phong\n\n\t\t\t\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n\n\t\t\t\t#ifdef USE_SPECULAR_MAP\n\t\t\t\t\tspec *= texture2D(specularMap, secondaryMapUvFactor * vUv).r;\n\t\t\t\t#endif\n\n\t\t\t\tspecularLight += vec3(specularIntensity * spec);\n\t\t\t#endif\n\t\t#endif\n\n\t\tvec4 shaded = diffuse * vec4(incomingLight, 1.0);\n\t\tshaded.rgb += specularLight;\n\n\t\t#ifdef USE_ENV_MAP\n\t\t\t#ifdef USE_FRESNEL\n\t\t\t\t// Fresnel causes the reflectivity to increase with incresing angle of incidence\n\t\t\t\tvec3 viewDir = normalize(eyePosition - vPosition.xyz);\n\t\t\t\tfloat fac = fresnel(viewDir, normal, true);\n\t\t\t#else\n\t\t\t\tfloat fac = 1.0;\n\t\t\t#endif\n\n\t\t\t#ifdef USE_ACCURATE_REFLECTION_RAY\n\t\t\t\t// The reflection ray tends to be much more accurate when computed using the interpolated normal rather than interpolating the reflection ray itself; but it's more expensive and sometimes looks too boring\n\t\t\t\tvec3 incidentRay = normalize(vPosition.xyz - eyePosition);\n\t\t\t\tvec3 reflectionRay = reflect(incidentRay, normalize(vNormal));\n\t\t\t#else\n\t\t\t\tvec3 reflectionRay = vReflect;\n\t\t\t#endif\n\n\t\t\tvec4 sampled = sampleCubeTexture(envMap, reflectionRay);\n\t\t\tsampled.a *= vOpacity;\n\t\t\t\n\t\t\tshaded = mix(shaded, sampled, fac * reflectivity);\n\t\t#endif\n\n\t\t#ifdef USE_NORMAL_MAP\n\t\t\tif (debugMode == 0) {}\n\t\t\telse if (debugMode == 1) {\n\t\t\t\tshaded = vec4(mod(vUv, 1.0f), 0, 1);\n\t\t\t}\n\t\t\telse if (debugMode == 2) {\n\t\t\t\tshaded = vec4((vNormal + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t\telse if (debugMode == 3) {\n\t\t\t\tshaded = vec4((map + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t\telse if (debugMode == 4) {\n\t\t\t\tshaded = vec4((normal + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t\t/*\n\t\t\tif (debugMode == 5) {\n\t\t\t\tshaded = vec4((vTangent.xyz + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t\tif (debugMode == 6) {\n\t\t\t\tshaded = vec4(vec3((vTangent.w + 1.0f) / 2.0f), 1);\n\t\t\t}\n\t\t\t*/\n\t\t\telse if (debugMode == 7) {\n\t\t\t\tshaded = vec4((vTbn[0] + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t\telse if (debugMode == 8) {\n\t\t\t\tshaded = vec4((vTbn[1] + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t\telse if (debugMode == 9) {\n\t\t\t\tshaded = vec4((vTbn[2] + 1.0f) / 2.0f, 1);\n\t\t\t}\n\t\t#endif\n\t\tgl_FragColor = shaded;\n\t\t#ifdef USE_PREMULTIPLIED_ALPHA\n\t\t\tgl_FragColor.rgb *= gl_FragColor.a;\n\t\t#endif\n\t#endif\n}";

	/** A scene is responsible for holding the description of a renderable world and preparing it for efficient rendering. */
	class Scene extends Group {
	    constructor(renderer) {
	        super();
	        this.allDefineChunks = new Set();
	        this.ambientLights = [];
	        this.directionalLights = [];
	        this.particleManager = null;
	        this.firstUpdate = true;
	        this.compiled = false;
	        this.preparedForRender = false;
	        this.renderer = renderer;
	    }
	    addAmbientLight(light) {
	        this.ambientLights.push(light);
	    }
	    addDirectionalLight(light) {
	        this.directionalLights.push(light);
	    }
	    /**
	     * Compiles the scene and all its meshes into neatly-packed buffers and draw calls for efficient rendering. After a scene has been
	     * compiled, no meshes can be added to or removed from it. In a general 3D engine this would be a very hard limitation, however it
	     * it perfect for Marble Blast, as the number of objects is constant at all times. We can exploit this fact to do some heavy-lifting
	     * ahead-of-time to save on draw calls and massively reduce rendering CPU overhead, a common problem for WebGL applications.
	     *
	     * During the compilation, all meshes will be scanned for the materials they use, and data is arranged in such a way that a single draw
	     * call is enough to draw all geometry of a single material, eliminating the need for per-mesh draw calls. There is, however, some data
	     * about meshes that cannot be precomputed as it is dynamic; mainly their transform and opacity. We therefore store this data in a
	     * floating-point texture that the vertex shader will dynamically read from. Whenever meshes change, we only need to update this texture
	     * once and we're set.
	     *
	     * As is usual with 3D renderers, transparent objects need to get different treatment as they have to be rendered using the painter's
	     * algorithm (back-to-front) for correct layering. Scene compilation also checks materials for transparency and separates opaque and
	     * transparent objects. Transparent objects, however, cannot be neatly precompiled and preplanned as opaque objects do.
	     */
	    compile() {
	        let { gl } = this.renderer;
	        let materialMap = new Map();
	        let allMeshes = [];
	        this.traverse(obj => obj instanceof Mesh && allMeshes.push(obj));
	        this.allMeshes = allMeshes;
	        // Create the arrays that will form VBO data
	        let positions = [];
	        let normals = [];
	        let tangents = [];
	        let uvs = [];
	        let meshInfoIndices = [];
	        let shadowCasterIndices = [];
	        for (let [index, mesh] of allMeshes.entries()) {
	            mesh.geometry.validate();
	            mesh.vboOffset = meshInfoIndices.length;
	            mesh.compileMaterialIndices();
	            let verts = mesh.geometry.positions.length / 3;
	            Util.pushArray(positions, mesh.geometry.positions);
	            Util.pushArray(normals, mesh.geometry.normals);
	            Util.pushArray(uvs, mesh.geometry.uvs);
	            Util.pushArray(meshInfoIndices, Array(verts).fill(index));
	            let hasNormalMap = mesh.materials.some(x => x.normalMap);
	            if (hasNormalMap) {
	                // Normal map calculations require us to do operations in so-called "tangent space", for which we need an extra tangent vector in addition to the normal
	                this.computeTangents(mesh.geometry.positions, mesh.geometry.normals, mesh.geometry.uvs, tangents);
	            }
	            else {
	                // No normal maps are used, no reason to compute any tangents
	                Util.pushArray(tangents, Array(4 * verts).fill(0));
	            }
	            for (let data of mesh.materialIndices) {
	                let material = data.material;
	                let defineChunk = material.getDefineChunk();
	                this.allDefineChunks.add(defineChunk);
	                if (!this.renderer.materialShaders.has(defineChunk)) {
	                    // New material, create a shader for it
	                    let program = new Program(this.renderer, materialVert, materialFrag, defineChunk);
	                    this.renderer.materialShaders.set(defineChunk, program);
	                }
	                if (mesh.castShadows)
	                    Util.pushArray(shadowCasterIndices, data.indices);
	                if (material.transparent || material.opacity < 1) {
	                    mesh.hasTransparentMaterials = true;
	                    continue; // We do only opaque stuff here
	                }
	                this.updateMaterialGroup(materialMap, data);
	            }
	        }
	        let opaqueMaterialGroups = [...materialMap].map(x => x[1]);
	        // Group material groups by define chunk to minimize the amount of calls to gl.useProgram. Then, make sure materials with the lowest render order go first.
	        opaqueMaterialGroups.sort((a, b) => a.defineChunk.localeCompare(b.defineChunk)).sort((a, b) => a.material.renderOrder - b.material.renderOrder);
	        this.opaqueMaterialGroups = opaqueMaterialGroups;
	        // Will form the data for our index buffer
	        let indices = [];
	        for (let group of opaqueMaterialGroups) {
	            group.offset = indices.length;
	            for (let data of group.indexGroups)
	                Util.pushArray(indices, data.indices);
	        }
	        // Create all vertex buffers
	        this.positionBuffer = new VertexBuffer(this.renderer, new Float32Array(positions), { 'position': 3 });
	        this.normalBuffer = new VertexBuffer(this.renderer, new Float32Array(normals), { 'normal': 3 });
	        this.tangentBuffer = new VertexBuffer(this.renderer, new Float32Array(tangents), { 'tangent': 4 });
	        this.uvBuffer = new VertexBuffer(this.renderer, new Float32Array(uvs), { 'uv': 2 });
	        this.meshInfoIndexBuffer = new VertexBuffer(this.renderer, new Float32Array(meshInfoIndices), { 'meshInfoIndex': 1 });
	        // Group the vertex buffers so they can be put into a single VAO
	        this.bufferGroup = new VertexBufferGroup([this.positionBuffer, this.normalBuffer, this.tangentBuffer, this.uvBuffer, this.meshInfoIndexBuffer]);
	        // Now, create our data texture to hold mesh information
	        let maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	        let textureWidth = this.meshInfoTextureWidth = Util.ceilPowerOf2(Math.min(4 * allMeshes.length, maxTextureSize)); // (WebGL1) textures need to have power-of-two dimension
	        let textureHeight = this.meshInfoTextureHeight = Util.ceilPowerOf2(Math.ceil(4 * allMeshes.length / Math.max(maxTextureSize, textureWidth)));
	        let internalFormat = (gl instanceof WebGLRenderingContext) ? gl.RGBA : gl.RGBA32F;
	        this.meshInfoBuffer = new Float32Array(4 * textureWidth * textureHeight); // One mat4 per mesh
	        this.meshInfoTexture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, this.meshInfoTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, textureWidth, textureHeight, 0, gl.RGBA, gl.FLOAT, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); // LINEAR would make no sense here
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        // Now, allocate the index buffers
	        let opaqueIndexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, opaqueIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
	        this.opaqueIndexBuffer = opaqueIndexBuffer;
	        this.shadowCasterIndices = shadowCasterIndices;
	        this.shadowCasterIndexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.shadowCasterIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(shadowCasterIndices), gl.STATIC_DRAW);
	        // Allocate the index buffer for transparent objects. Since technically, every mesh could become transparent at some point, we need to make this buffer big enough to fit all meshes.
	        let totalIndexCount = allMeshes.map(x => x.geometry.indices.length).reduce((a, b) => a + b, 0);
	        let transparentIndexBuffer = gl.createBuffer();
	        let transparentIndexBufferData = new Uint32Array(totalIndexCount);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, transparentIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, transparentIndexBufferData, gl.DYNAMIC_DRAW);
	        this.transparentIndexBuffer = transparentIndexBuffer;
	        this.transparentIndexBufferData = transparentIndexBufferData;
	        // Now, let's prepare the lights.
	        // Ambient light is simple: Simply condense all ambient lights into one by adding up their colors.
	        let totalAmbientLight = new Vector3();
	        this.ambientLights.forEach(x => totalAmbientLight.add(x.color));
	        this.ambientLightBuffer = new Float32Array(totalAmbientLight.toArray());
	        // For directional lights, there's no correct solution for more than one light, so we just average the direction vectors and sum the colors.
	        let totalDirectionalLight = new Vector3();
	        let directionalLightDirection = new Vector3();
	        for (let light of this.directionalLights) {
	            totalDirectionalLight.add(light.color);
	            directionalLightDirection.addScaledVector(light.direction, 1 / this.directionalLights.length);
	        }
	        this.directionalLightColorBuffer = new Float32Array(totalDirectionalLight.toArray());
	        this.directionalLightDirectionBuffer = new Float32Array(directionalLightDirection.toArray());
	        this.directionalLightTransformBuffer = new Float32Array(16);
	        this.compiled = true;
	    }
	    /** Updates (or creates) a material group and adds index data to it. */
	    updateMaterialGroup(materialMap, data) {
	        let material = data.material;
	        let materialHash = material.getHash();
	        let materialGroup = materialMap.get(materialHash);
	        if (!materialGroup) {
	            materialGroup = {
	                material,
	                indexGroups: [],
	                defineChunk: material.getDefineChunk(),
	                offset: 0,
	                count: 0,
	                minDistance: Infinity
	            };
	            materialMap.set(materialHash, materialGroup);
	        }
	        materialGroup.indexGroups.push(data);
	        materialGroup.count += data.indices.length;
	        return materialGroup;
	    }
	    // Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”. Terathon Software 3D Graphics Library, 2001. http://www.terathon.com/code/tangent.html
	    computeTangents(positions, normals, uvs, tangents) {
	        let verts = positions.length / 3;
	        let tris = verts / 3;
	        let v1 = new Vector3();
	        let v2 = new Vector3();
	        let v3 = new Vector3();
	        let w1 = new Vector2();
	        let w2 = new Vector2();
	        let w3 = new Vector2();
	        let sdir = new Vector3();
	        let tdir = new Vector3();
	        let normal = new Vector3();
	        let tangent = new Vector3();
	        for (let i = 0; i < tris; i++) {
	            v1.set(positions[9 * i + 0], positions[9 * i + 1], positions[9 * i + 2]);
	            v2.set(positions[9 * i + 3], positions[9 * i + 4], positions[9 * i + 5]);
	            v3.set(positions[9 * i + 6], positions[9 * i + 7], positions[9 * i + 8]);
	            w1.set(uvs[6 * i + 0], uvs[6 * i + 1]);
	            w2.set(uvs[6 * i + 2], uvs[6 * i + 3]);
	            w3.set(uvs[6 * i + 4], uvs[6 * i + 5]);
	            let x1 = v2.x - v1.x;
	            let x2 = v3.x - v1.x;
	            let y1 = v2.y - v1.y;
	            let y2 = v3.y - v1.y;
	            let z1 = v2.z - v1.z;
	            let z2 = v3.z - v1.z;
	            let s1 = w2.x - w1.x;
	            let s2 = w3.x - w1.x;
	            let t1 = w2.y - w1.y;
	            let t2 = w3.y - w1.y;
	            let r = 1 / (s1 * t2 - s2 * t1);
	            sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
	            tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
	            for (let j = 0; j < 3; j++) {
	                normal.set(normals[9 * i + 3 * j + 0], normals[9 * i + 3 * j + 1], normals[9 * i + 3 * j + 2]);
	                // Gram-Schmidt orthogonalize
	                tangent.copy(sdir).addScaledVector(normal, -normal.dot(sdir)).normalize();
	                // Calculate handedness
	                let w = (normal.cross(sdir).dot(tdir) < 0) ? -1 : 1;
	                tangents.push(tangent.x, tangent.y, tangent.z, w);
	            }
	        }
	    }
	    /**
	     * Prepares a scene for rendering by updating shadow maps and preparing transparent objects. Has to be called before each render.
	     * This is kept separate from `render` because a scene can be rendered multiple times per frame (for cubemaps, for example). It
	     * would be a waste to prepare the scene for each of those renders as the state hasn't changed.
	     */
	    prepareForRender(camera) {
	        var _a;
	        let { gl } = this.renderer;
	        this.update();
	        (_a = this.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.renderShadowMap(this);
	        let temp = new Vector3();
	        let cameraPosition = camera.position;
	        let transparentMeshes = this.allMeshes.filter(x => x.hasTransparentMaterials || (x.opacity < 1 && x.opacity > 0)); // Find out which meshes are transparent so we don't sort opaque stuff too
	        // Compute the distances to the camera
	        for (let mesh of transparentMeshes) {
	            mesh.distanceToCamera = temp.setFromMatrixPosition(mesh.worldTransform).distanceToSquared(cameraPosition);
	        }
	        // Sort transparent meshes using the painter's algorithm, furthest first
	        let sortedMeshes = transparentMeshes.sort((a, b) => b.distanceToCamera - a.distanceToCamera);
	        let materialMap = new Map();
	        // Create the material groups for the transparent objects
	        for (let mesh of sortedMeshes) {
	            for (let data of mesh.materialIndices) {
	                let material = data.material;
	                let effectiveOpacity = mesh.opacity * material.opacity;
	                if ((!material.transparent && effectiveOpacity === 1) || effectiveOpacity === 0)
	                    continue;
	                let group = this.updateMaterialGroup(materialMap, data);
	                group.minDistance = Math.min(group.minDistance, mesh.distanceToCamera);
	            }
	        }
	        // We also need to sort the individual material groups by distance to get more accurate results. This is because
	        // what we're doing is actually inaccurate, since we're drawing all geometry of a single material at once, which
	        // works fine for opaque objects where order doesn't matter, but falls apart for transparent objects where correct
	        // depth sorting is paramount. To reduce errors as much as possible, make sure we draw the materials with the furthest
	        // minimum distance to the camera first.
	        let materialGroups = [...materialMap].map(x => x[1]);
	        materialGroups.sort((a, b) => b.minDistance - a.minDistance);
	        this.transparentMaterialGroups = materialGroups;
	        // Populate the index buffer
	        let offset = 0;
	        for (let group of materialGroups) {
	            group.offset = offset;
	            for (let data of group.indexGroups) {
	                this.transparentIndexBufferData.set(data.indexBuffer, offset); // We're using .set here which should cause a fast memcpy in the JS engine
	                offset += data.indices.length;
	            }
	        }
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.transparentIndexBuffer);
	        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, this.transparentIndexBufferData, 0, offset);
	        this.preparedForRender = true;
	    }
	    /** Updates this scene and its meshes. */
	    update() {
	        let { gl } = this.renderer;
	        // Update the world transform of all meshes that need an update
	        this.updateWorldTransform();
	        for (let i = 0; i < this.allMeshes.length; i++) {
	            let mesh = this.allMeshes[i];
	            if (mesh.needsVertexBufferUpdate) {
	                // Geomtry has changed, we need to update the VBOs
	                let offset = mesh.vboOffset;
	                this.positionBuffer.set(mesh.geometry.positions, offset * 3);
	                this.normalBuffer.set(mesh.geometry.normals, offset * 3);
	                this.uvBuffer.set(mesh.geometry.uvs, offset * 2);
	                mesh.needsVertexBufferUpdate = false;
	            }
	            if (this.firstUpdate || mesh.needsMeshInfoBufferUpdate) {
	                mesh.updateMeshInfoBuffer(this.meshInfoBuffer, 16 * i);
	            }
	        }
	        // Update the mesh info data texture
	        gl.bindTexture(gl.TEXTURE_2D, this.meshInfoTexture);
	        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.meshInfoTextureWidth, this.meshInfoTextureHeight, gl.RGBA, gl.FLOAT, this.meshInfoBuffer);
	        // Write the updated VBOs to the GPU. If nothing changed, these calls won't do anything.
	        this.positionBuffer.update();
	        this.normalBuffer.update();
	        this.uvBuffer.update();
	        // We also need to update the shadow camera transform
	        this.updateDirectionalLights();
	        this.firstUpdate = false;
	    }
	    updateDirectionalLights() {
	        let firstLight = this.directionalLights[0];
	        if (!firstLight)
	            return;
	        if (firstLight.camera) {
	            let mat4 = new Matrix4();
	            mat4.multiplyMatrices(firstLight.camera.projectionMatrix, firstLight.camera.matrixWorldInverse);
	            this.directionalLightTransformBuffer.set(mat4.elements, 0);
	        }
	    }
	    /** Disposes all GPU resources used by this scene. */
	    dispose() {
	        let { gl } = this.renderer;
	        this.positionBuffer.dispose();
	        this.normalBuffer.dispose();
	        this.tangentBuffer.dispose();
	        this.uvBuffer.dispose();
	        this.meshInfoIndexBuffer.dispose();
	        gl.deleteTexture(this.meshInfoTexture);
	        gl.deleteBuffer(this.opaqueIndexBuffer);
	        gl.deleteBuffer(this.transparentIndexBuffer);
	        gl.deleteBuffer(this.shadowCasterIndexBuffer);
	        this.particleManager.dispose();
	        for (let light of this.directionalLights)
	            light.dispose();
	    }
	}

	/** Represents a simple ambient light that lights up everything uniformly. */
	class AmbientLight {
	    constructor(color) {
	        this.color = color;
	    }
	}

	/** Represents a light source that casts light globally in a specific direction. Can cast shadows. */
	class DirectionalLight {
	    constructor(renderer, color, direction) {
	        this.camera = null;
	        this.renderer = renderer;
	        this.color = color;
	        this.direction = direction;
	    }
	    /** Turns on shadow casting for this light and sets up the necessary textures and buffers. */
	    enableShadowCasting(textureResolution, camera) {
	        Util.assert(Util.isPowerOf2(textureResolution)); // We never know 😓
	        let { gl } = this.renderer;
	        this.camera = camera;
	        // Create the texture that will store the depth information
	        let depthTexture = gl.createTexture();
	        let depthComponent = (gl instanceof WebGLRenderingContext) ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT32F;
	        let type = (gl instanceof WebGLRenderingContext) ? gl.UNSIGNED_INT : gl.FLOAT;
	        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, depthComponent, textureResolution, textureResolution, 0, gl.DEPTH_COMPONENT, type, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        this.depthTexture = depthTexture;
	        // Create the framebuffer
	        let depthFramebuffer = gl.createFramebuffer();
	        gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
	        this.depthFramebuffer = depthFramebuffer;
	        // "For a bunch of reasons we also need to create a color texture and attach it as a color attachment even though we won't actually use it."
	        let unusedTexture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, unusedTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureResolution, textureResolution, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        this.colorTexture = unusedTexture;
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, unusedTexture, 0);
	        this.depthTexture = depthTexture;
	        this.textureResolution = textureResolution;
	    }
	    /**
	     * Updates the position of the shadow camera.
	     * @param offset Specifies the offset in the direction of the light from `position`.
	     */
	    updateCamera(position, offset) {
	        if (!this.camera)
	            return;
	        this.camera.position.copy(position.clone().addScaledVector(this.direction, offset));
	        this.camera.lookAt(this.camera.position.clone().add(this.direction));
	        this.camera.updateMatrixWorld();
	    }
	    /** Renders to the shadow map with all shadow casters from the given scene. */
	    renderShadowMap(scene) {
	        if (!this.camera)
	            return;
	        let { gl, shadowMapProgram } = this.renderer;
	        gl.depthMask(true);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.depthFramebuffer);
	        gl.viewport(0, 0, this.textureResolution, this.textureResolution);
	        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	        shadowMapProgram.use();
	        shadowMapProgram.bindVertexBufferGroup(scene.bufferGroup);
	        gl.uniformMatrix4fv(shadowMapProgram.getUniformLocation('viewMatrix'), false, new Float32Array(this.camera.matrixWorldInverse.elements));
	        gl.uniformMatrix4fv(shadowMapProgram.getUniformLocation('projectionMatrix'), false, new Float32Array(this.camera.projectionMatrix.elements));
	        gl.uniform1i(shadowMapProgram.getUniformLocation('meshInfoTextureWidth'), scene.meshInfoTextureWidth);
	        gl.uniform1i(shadowMapProgram.getUniformLocation('meshInfoTextureHeight'), scene.meshInfoTextureHeight);
	        gl.uniform1i(shadowMapProgram.getUniformLocation('meshInfos'), 7);
	        this.renderer.bindTexture(scene.meshInfoTexture, 7, gl.TEXTURE_2D);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, scene.shadowCasterIndexBuffer);
	        gl.drawElements(gl.TRIANGLES, scene.shadowCasterIndices.length, gl.UNSIGNED_INT, 0); // A single draw call is enough
	    }
	    /** Binds the shadow map to texture unit 2. */
	    bindShadowMap() {
	        let { gl } = this.renderer;
	        this.renderer.bindTexture(this.depthTexture, 2, gl.TEXTURE_2D);
	    }
	    dispose() {
	        if (!this.camera)
	            return;
	        let { gl } = this.renderer;
	        gl.deleteTexture(this.depthTexture);
	        gl.deleteTexture(this.colorTexture);
	        gl.deleteFramebuffer(this.depthFramebuffer);
	    }
	}

	const DEFAULT_ROOT_NODE_SIZE = 1;
	const MIN_DEPTH = -52; // Huge
	const MAX_DEPTH = 8;
	let v1$3 = new Vector3();
	let v2$1 = new Vector3();
	let b1 = new Box3();
	/** A dynamic, loose octree of bounding boxes for efficient spatial operations such as raytracing. Implemented without any cringe. */
	class Octree {
	    constructor() {
	        this.beforeOperation = null;
	        this.root = new OctreeNode(this, 0);
	        // Init the octree to a 1x1x1 cube
	        this.root.min.set(0, 0, 0);
	        this.root.size = DEFAULT_ROOT_NODE_SIZE;
	        this.objectToNode = new WeakMap();
	    }
	    insert(object) {
	        let node = this.objectToNode.get(object);
	        if (node)
	            return; // Don't insert if already contained in the tree
	        while (!this.root.largerThan(object) || !this.root.containsCenter(object)) {
	            // The root node does not fit the object; we need to grow the tree.
	            if (this.root.depth === MIN_DEPTH) {
	                console.log(object);
	                console.warn(`Can't insert ${this.root.largerThan(object) ? 'distant' : 'large'} object into octree; the octree has already expanded to its maximum size.`);
	                this.shrink(); // Since the growing was unsuccessful, let's try to shrink down again
	                return;
	            }
	            this.grow(object);
	        }
	        let emptyBefore = this.root.count === 0;
	        this.root.insert(object);
	        if (emptyBefore)
	            this.shrink(); // See if we can fit the octree better now that we actually have an element in it
	    }
	    remove(object) {
	        let node = this.objectToNode.get(object);
	        if (!node)
	            return;
	        node.remove(object);
	        this.objectToNode.delete(object);
	        this.shrink(); // Try shrinking the octree
	    }
	    /** Updates an object in the tree whose bounding box has changed. */
	    update(object) {
	        let node = this.objectToNode.get(object);
	        if (!node) {
	            this.insert(object);
	            return;
	        }
	        let success = node.update(object);
	        if (!success) {
	            this.objectToNode.delete(object);
	            this.insert(object);
	        }
	    }
	    /** Expand the octree towards an object that doesn't fit in it. */
	    grow(towards) {
	        // We wanna grow towards all the vertices of the object's bounding box that lie outside the octree, so we determine the average position of those vertices:
	        let averagePoint = v1$3.set(0, 0, 0);
	        let count = 0;
	        for (let i = 0; i < 8; i++) {
	            let vec = v2$1;
	            vec.setComponent(0, (i & 0b001) ? towards.boundingBox.min.x : towards.boundingBox.max.x);
	            vec.setComponent(1, (i & 0b010) ? towards.boundingBox.min.y : towards.boundingBox.max.y);
	            vec.setComponent(2, (i & 0b100) ? towards.boundingBox.min.z : towards.boundingBox.max.z);
	            if (!this.root.containsPoint(vec)) {
	                averagePoint.add(vec);
	                count++;
	            }
	        }
	        averagePoint.multiplyScalar(1 / count); // count should be greater than 0, because that's why we're growing in the first place.
	        // Determine the direction from the root center to the determined point
	        let rootCenter = v2$1.copy(this.root.min).addScalar(this.root.size / 2);
	        let direction = averagePoint.sub(rootCenter); // Determine the "direction of growth"
	        // Create a new root. The current root will become a quadrant in this new root.
	        let newRoot = new OctreeNode(this, this.root.depth - 1);
	        newRoot.min.copy(this.root.min);
	        newRoot.size = this.root.size * 2;
	        if (direction.x < 0)
	            newRoot.min.x -= this.root.size;
	        if (direction.y < 0)
	            newRoot.min.y -= this.root.size;
	        if (direction.z < 0)
	            newRoot.min.z -= this.root.size;
	        if (this.root.count > 0) {
	            let octantIndex = ((direction.x < 0) ? 1 : 0) + ((direction.y < 0) ? 2 : 0) + ((direction.z < 0) ? 4 : 0);
	            newRoot.createOctants();
	            newRoot.octants[octantIndex] = this.root;
	            this.root.parent = newRoot;
	            newRoot.count = this.root.count;
	            newRoot.merge();
	        }
	        this.root = newRoot;
	    }
	    /** Tries to shrink the octree if large parts of it are empty. */
	    shrink() {
	        if (this.root.size <= DEFAULT_ROOT_NODE_SIZE)
	            return;
	        if (this.root.count === 0) {
	            // Reset to default empty octree
	            this.root.min.set(0, 0, 0);
	            this.root.size = DEFAULT_ROOT_NODE_SIZE;
	            this.root.depth = 0;
	            return;
	        }
	        if (!this.root.octants) {
	            // We don't have any octants, but are still holding objects. Therefore, create temporary utility octants to see if we can still shrink in case all the root's objects fit inside one hypothetical octant.
	            this.root.createOctants();
	            let fittingOctant = null;
	            for (let object of this.root.objects) {
	                if (this.root.octants[0].largerThan(object)) {
	                    for (let j = 0; j < 8; j++) {
	                        let octant = this.root.octants[j];
	                        if (octant.containsCenter(object)) {
	                            if (fittingOctant && fittingOctant !== octant) {
	                                return;
	                            }
	                            fittingOctant = octant;
	                        }
	                    }
	                }
	                else {
	                    // An object doesn't fit into an octant, so we definitely can't shrink
	                    return;
	                }
	            }
	            // All objects fit into an octant, therefore shrink
	            this.root.size /= 2;
	            this.root.min.copy(fittingOctant.min);
	            this.root.depth++;
	            this.root.octants = null; // Don't need these anymore
	            this.shrink(); // And again
	            return;
	        }
	        // Find the only non-empty octant
	        let nonEmptyOctant;
	        for (let i = 0; i < 8; i++) {
	            let octant = this.root.octants[i];
	            if (octant.count > 0) {
	                if (nonEmptyOctant)
	                    return; // There are more than two non-empty octants -> don't shrink.
	                else
	                    nonEmptyOctant = octant;
	            }
	        }
	        // Make the only non-empty octant the new root
	        this.root = nonEmptyOctant;
	        nonEmptyOctant.parent = null;
	        this.shrink(); // I'll fuckin do it again
	    }
	    intersectAabb(aabb) {
	        var _a;
	        (_a = this.beforeOperation) === null || _a === void 0 ? void 0 : _a.call(this);
	        let intersections = [];
	        this.root.intersectAabb(aabb, intersections);
	        return intersections;
	    }
	}
	class OctreeNode {
	    constructor(octree, depth) {
	        this.parent = null;
	        /** The min corner of the bounding box. */
	        this.min = new Vector3();
	        this.octants = null;
	        /** A list of objects contained in this node. Note that the node doesn't need to be a leaf node for this set to be non-empty; since this is an octree of bounding boxes, some volumes cannot fit into an octant and therefore need to be stored in the node itself. */
	        this.objects = new Set();
	        /** The total number of objects in the subtree with this node as its root. */
	        this.count = 0;
	        this.octree = octree;
	        this.depth = depth;
	    }
	    insert(object) {
	        this.count++;
	        if (this.octants) {
	            // First we check if the object can fit into any of the octants (they all have the same size, so checking only one suffices)
	            if (this.octants[0].largerThan(object)) {
	                // Try to insert the object into one of the octants...
	                for (let i = 0; i < 8; i++) {
	                    let octant = this.octants[i];
	                    if (octant.containsCenter(object)) {
	                        octant.insert(object);
	                        return;
	                    }
	                }
	            }
	            // No octant fit the object, so add it to the list of objects instead
	            this.objects.add(object);
	            this.octree.objectToNode.set(object, this);
	        }
	        else {
	            this.objects.add(object);
	            this.octree.objectToNode.set(object, this);
	            this.split(); // Try splitting this node
	        }
	    }
	    split() {
	        if (this.objects.size <= 8 || this.depth === MAX_DEPTH)
	            return;
	        this.createOctants();
	        // Put the objects into the correct octants. Note that all objects that couldn't fit into any octant will remain in the set.
	        for (let object of this.objects) {
	            if (this.octants[0].largerThan(object)) {
	                for (let j = 0; j < 8; j++) {
	                    let octant = this.octants[j];
	                    if (octant.containsCenter(object)) {
	                        octant.insert(object);
	                        this.objects.delete(object);
	                    }
	                }
	            }
	        }
	        // Try recursively splitting each octant
	        for (let i = 0; i < 8; i++) {
	            this.octants[i].split();
	        }
	    }
	    createOctants() {
	        this.octants = [];
	        for (let i = 0; i < 8; i++) {
	            let newNode = new OctreeNode(this.octree, this.depth + 1);
	            newNode.parent = this;
	            newNode.size = this.size / 2;
	            newNode.min.set(this.min.x + newNode.size * ((i & 0b001) >> 0), // The x coordinate changes every index
	            this.min.y + newNode.size * ((i & 0b010) >> 1), // The y coordinate changes every 2 indices
	            this.min.z + newNode.size * ((i & 0b100) >> 2) // The z coordinate changes every 4 indices
	            );
	            this.octants.push(newNode);
	        }
	    }
	    // Note: The requirement for this method to be called is that `object` is contained directly in this node.
	    remove(object) {
	        this.objects.delete(object);
	        this.count--;
	        this.merge();
	        // Clean up all ancestors
	        let node = this.parent;
	        while (node) {
	            node.count--; // Reduce the count for all ancestor nodes up until the root
	            node.merge();
	            node = node.parent;
	        }
	    }
	    // Basically first performs a remove, then walks up the tree to find the closest ancestor that can fit the object, then inserts it.
	    update(object) {
	        this.objects.delete(object);
	        let node = this;
	        while (node) {
	            node.count--;
	            node.merge();
	            if (node.largerThan(object) && node.containsCenter(object)) {
	                node.insert(object);
	                return true;
	            }
	            node = node.parent;
	        }
	        return false; // Nothing worked, we need to properly grow the tree
	    }
	    merge() {
	        if (this.count > 8 || !this.octants)
	            return;
	        // Add all objects in the octants back to this node
	        for (let i = 0; i < 8; i++) {
	            let octant = this.octants[i];
	            for (let object of octant.objects) {
	                this.objects.add(object);
	                this.octree.objectToNode.set(object, this);
	            }
	        }
	        this.octants = null; // ...then delete the octants
	    }
	    largerThan(object) {
	        let box = object.boundingBox;
	        return this.size > (box.max.x - box.min.x) &&
	            this.size > (box.max.y - box.min.y) &&
	            this.size > (box.max.z - box.min.z);
	    }
	    containsCenter(object) {
	        let box = object.boundingBox;
	        let x = box.min.x + (box.max.x - box.min.x) / 2;
	        let y = box.min.y + (box.max.y - box.min.y) / 2;
	        let z = box.min.z + (box.max.z - box.min.z) / 2;
	        return this.min.x <= x && x < (this.min.x + this.size) &&
	            this.min.y <= y && y < (this.min.y + this.size) &&
	            this.min.z <= z && z < (this.min.z + this.size);
	    }
	    containsPoint(point) {
	        let { x, y, z } = point;
	        return this.min.x <= x && x < (this.min.x + this.size) &&
	            this.min.y <= y && y < (this.min.y + this.size) &&
	            this.min.z <= z && z < (this.min.z + this.size);
	    }
	    intersectAabb(aabb, intersections) {
	        let looseBoundingBox = b1;
	        looseBoundingBox.min.copy(this.min).addScalar(-this.size / 2);
	        looseBoundingBox.max.copy(this.min).addScalar(this.size * 3 / 2);
	        if (!aabb.intersectsBox(looseBoundingBox))
	            return;
	        // Test all objects for intersection
	        if (this.objects.size > 0)
	            for (let object of this.objects) {
	                if (aabb.intersectsBox(object.boundingBox))
	                    intersections.push(object);
	            }
	        // Recurse into the octants
	        if (this.octants)
	            for (let i = 0; i < 8; i++) {
	                let octant = this.octants[i];
	                if (octant.count === 0)
	                    continue;
	                octant.intersectAabb(aabb, intersections);
	            }
	    }
	}

	let v1$4 = new Vector3();
	let q1$2 = new Quaternion();
	/** Represents a collision between two shapes. */
	class Collision {
	    constructor(s1, s2) {
	        /** The time of impact assuming linear translation of both shapes. */
	        this.timeOfImpact = 1;
	        this.s1MaterialOverride = null;
	        this.s2MaterialOverride = null;
	        this.s1 = s1;
	        this.s2 = s2;
	        this.friction = s1.friction * s2.friction;
	        this.restitution = s1.restitution * s2.restitution;
	        this.s1Friction = s1.friction;
	        this.s1Restitution = s1.restitution;
	        this.s2Friction = s2.friction;
	        this.s2Restitution = s2.restitution;
	    }
	    supplyCollisionPlane(plane) {
	        this.normal = plane.normal.clone(); // Make sure to clone it here so no funky stuff happens
	        this.depth = plane.constant;
	        this.point1 = this.s1.support(new Vector3(), v1$4.copy(this.normal).negate()); // Horribly wrong in the general case, but gives the correct result if s1 is a ball
	        this.point2 = this.point1.clone().addScaledVector(this.normal, this.depth);
	        this.point = this.point1.clone().add(this.point2).multiplyScalar(0.5);
	    }
	    /** Updates the collision's friction and restitution if necessary. */
	    updateMaterialProperties() {
	        if (!this.normal)
	            return;
	        // Check for material overrides (check CollisionShape for more explanation on why)
	        if (this.s1.materialOverrides.size > 0 || this.s2.materialOverrides.size > 0) {
	            let s1Friction = this.s1.friction;
	            let s2Friction = this.s2.friction;
	            let s1Restitution = this.s1.restitution;
	            let s2Restitution = this.s2.restitution;
	            let max = -Infinity;
	            let min = Infinity;
	            let transformedNormal = v1$4;
	            q1$2.copy(this.s1.body.orientation).conjugate();
	            transformedNormal.copy(this.normal).applyQuaternion(q1$2);
	            // Find the override for s1
	            for (let [vec, material] of this.s1.materialOverrides) {
	                let dot = vec.dot(transformedNormal);
	                if (dot < min) {
	                    min = dot;
	                    s1Friction = material.friction;
	                    s1Restitution = material.restitution;
	                    this.s1MaterialOverride = vec;
	                }
	            }
	            q1$2.copy(this.s2.body.orientation).conjugate();
	            transformedNormal.copy(this.normal).applyQuaternion(q1$2);
	            // Find the override for s2
	            for (let [vec, material] of this.s2.materialOverrides) {
	                let dot = vec.dot(transformedNormal);
	                if (dot > max) {
	                    max = dot;
	                    s2Friction = material.friction;
	                    s2Restitution = material.restitution;
	                    this.s2MaterialOverride = vec;
	                }
	            }
	            // Compute the final friction and restitution
	            this.friction = s1Friction * s2Friction;
	            this.restitution = s1Restitution * s2Restitution;
	            this.s1Friction = s1Friction;
	            this.s1Restitution = s1Restitution;
	            this.s2Friction = s2Friction;
	            this.s2Restitution = s2Restitution;
	        }
	    }
	}

	const maxIterations = 64;
	const maxEpaFaces = 64;
	const epaTolerance = 10 * Number.EPSILON;
	const maxEpaLooseEdges = 64;
	const maxEpaIterations = 64;
	// Global algorithm state
	/** The points of the current simplex. Only points with index < numPoints are valid. */
	let points = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
	/** The amount of points in the current simplex. */
	let numPoints = 0;
	let support = new Vector3();
	let direction = new Vector3();
	let ao = new Vector3();
	let bo = new Vector3();
	let co = new Vector3();
	let ab = new Vector3();
	let ac = new Vector3();
	let ad = new Vector3();
	let bc = new Vector3();
	let bd = new Vector3();
	let abc = new Vector3();
	let acd = new Vector3();
	let adb = new Vector3();
	let bdc = new Vector3();
	let v1$5 = new Vector3();
	let v2$2 = new Vector3();
	let translation = new Vector3();
	let actualPosition1 = new Vector3();
	let actualPosition2 = new Vector3();
	let x = new Vector3();
	let n = new Vector3();
	let w = new Vector3();
	/** Indicates if the current triangle (3-point simplex) needs to have its winding order reversed. */
	let requireFlip = 0;
	let lastS1 = null;
	let lastS2 = null;
	let o = new Vector3(0, 0, 0);
	let singletonShape = new SingletonCollisionShape();
	let singletonBody = new RigidBody();
	singletonBody.addCollisionShape(singletonShape);
	// EPA state
	let faces = [];
	let looseEdges = [];
	for (let i = 0; i < maxEpaIterations; i++) {
	    faces.push([new Vector3(), new Vector3(), new Vector3(), new Vector3()]);
	}
	for (let i = 0; i < maxEpaLooseEdges; i++) {
	    looseEdges.push([new Vector3(), new Vector3()]);
	}
	/** Provides methods for testing for intersection of convex shapes. */
	class CollisionDetection {
	    /** Joined support function; returns the support function of the Minkowski difference of shape 1 and 2. */
	    static support(dst, s1, s2, direction) {
	        return s1.support(dst, direction).sub(s2.support(v1$5, v2$2.copy(direction).negate()));
	    }
	    /** Returns true iff `s1` and `s2` intersect. */
	    static checkIntersection(s1, s2) {
	        // Remember the shapes for later
	        lastS1 = s1;
	        lastS2 = s2;
	        if (s1 instanceof BallCollisionShape && s2 instanceof BallCollisionShape) {
	            // Since this case is trivial, we have a special method for it to process it quickly
	            return this.checkBallBallIntersection(s1, s2);
	        }
	        else if (s1 instanceof BallCollisionShape) {
	            // This case is less trivial and does require GJK but does *not* require EPA later on, so use a special method for this also
	            return this.checkBallConvexIntersection(s1, s2);
	        }
	        else {
	            // Otherwise, do general GJK
	            return this.checkConvexConvexIntersection(s1, s2);
	        }
	    }
	    static checkBallBallIntersection(s1, s2) {
	        // Simply compare distance and radius sum
	        return s1.body.position.distanceTo(s2.body.position) <= s1.radius + s2.radius;
	    }
	    static checkBallConvexIntersection(s1, s2) {
	        singletonBody.position.copy(s1.body.position);
	        // All we need to do is compute the closest point on s2 to s1's center. After that, a simple comparison with the radius will suffice.
	        let closestPoint = this.determineClosestPoint(new Vector3(), s2, singletonShape);
	        let distanceSq = closestPoint.lengthSq();
	        return distanceSq <= s1.radius ** 2;
	    }
	    /** Check for intersection of two shapes using the boolean Gilbert-Johnson-Keerthi (GJK) algorithm. */
	    static checkConvexConvexIntersection(s1, s2) {
	        direction.copy(s2.body.position).sub(s1.body.position).normalize(); // Can really be anything but this is a good start
	        this.support(support, s1, s2, direction);
	        numPoints = 1;
	        points[0].copy(support);
	        direction.copy(support).negate(); // ao
	        for (let i = 0; i < maxIterations; i++) {
	            this.support(support, s1, s2, direction);
	            if (support.dot(direction) <= 0) {
	                // No collision
	                return false;
	            }
	            // Update the simplex
	            this.addPointToSimplex(support);
	            this.updateSimplexFast();
	            if (numPoints === 4) {
	                // We managed to enclose the origin in a tetrahedron, meaning we're intersecting
	                return true;
	            }
	        }
	        return false;
	    }
	    /** Computes the closest point to the origin in the Minkowski difference of s1 and s2. */
	    static determineClosestPoint(dst, s1, s2) {
	        direction.copy(s2.body.position).sub(s1.body.position);
	        numPoints = 0;
	        for (let i = 0; i < maxIterations; i++) {
	            if (numPoints === 4)
	                break;
	            this.support(support, s1, s2, direction);
	            if (direction.lengthSq() + direction.dot(support) <= 10 * Number.EPSILON)
	                break;
	            this.addPointToSimplex(support);
	            this.updateSimplexAndClosestPoint(direction);
	            direction.negate();
	        }
	        return dst.copy(direction).negate();
	    }
	    /** Determines the time of impact of two moving shapes by simply linearly translating the shapes between their last and current position. */
	    static determineTimeOfImpact(s1, s2, eps = 0.03) {
	        s1.body.getRelativeMotionVector(translation, s2.body); // We assume s2 is stationary and s1's movement is now relative to s2's frame
	        let translationLength = translation.length();
	        // Remember the positions and revert the shapes back one position
	        actualPosition1.copy(s1.body.position);
	        actualPosition2.copy(s2.body.position);
	        s1.body.position.copy(s1.body.prevPosition);
	        s2.body.position.copy(s2.body.prevPosition);
	        // A simple ray cast on the Minkowski difference will return the time of impact
	        let res = this.castRay(s2, s1, o, translation, 1);
	        // Reset the position
	        s1.body.position.copy(actualPosition1);
	        s2.body.position.copy(actualPosition2);
	        if (!res)
	            return null;
	        // To ensure that collision is actually detected, nudge the point of impact a little bit forward so the shapes definitely intersect.
	        let toAdd = Math.min(eps * translationLength, eps / translationLength); // Don't ask, there's no clean derivation for this
	        res.lambda += toAdd;
	        res.lambda = Util.clamp(res.lambda, 0, 1);
	        return res.lambda;
	    }
	    /** Performs a GJK ray cast on the Minkowski difference of two shapes. Uses the method described by Gino van den Bergen in http://dtecta.com/papers/jgt04raycast.pdf. */
	    static castRay(s1, s2, rayOrigin, rayDirection, lambdaMax) {
	        direction.copy(s2.body.position).sub(s1.body.position).normalize();
	        this.support(support, s1, s2, direction);
	        numPoints = 0;
	        x.copy(rayOrigin); // x will be the point of impact
	        n.setScalar(0); // n will be the surface normal at the point of impact
	        let lambda = 0; // lambda will be the number such that origin + lambda * direction = x
	        direction.copy(x).sub(support);
	        for (let i = 0; i < maxIterations; i++) {
	            this.support(support, s1, s2, direction);
	            w.copy(x).sub(support);
	            if (direction.dot(w) > 0) {
	                if (direction.dot(rayDirection) >= 0)
	                    return null;
	                // Nudge forward
	                let delta = direction.dot(w) / direction.dot(rayDirection);
	                lambda -= delta;
	                if (lambda > lambdaMax)
	                    return null;
	                x.copy(rayOrigin).addScaledVector(rayDirection, lambda);
	                n.copy(direction);
	            }
	            this.addPointToSimplex(support);
	            // Offset the entire simplex temporarily
	            for (let i = 0; i < numPoints; i++)
	                points[i].sub(x);
	            // This now finds the feature of the simplex closest to x, not the origin anymore, because we offset the simplex.
	            this.updateSimplexAndClosestPoint(direction);
	            direction.negate();
	            // Offset the simplex back
	            for (let i = 0; i < numPoints; i++)
	                points[i].add(x);
	            let maxDist2 = 0;
	            for (let i = 0; i < numPoints; i++) {
	                maxDist2 = Math.max(maxDist2, points[i].distanceToSquared(x));
	            }
	            if (direction.lengthSq() < 10 * Number.EPSILON * maxDist2) {
	                return { point: x.clone(), lambda, normal: n.clone().normalize() };
	            }
	        }
	        return null;
	    }
	    /** Expands the current simplex by one point. */
	    static addPointToSimplex(p) {
	        // Check if the point is already contained in the simplex, and if so, don't add it
	        for (let i = 0; i < numPoints; i++) {
	            if (p.distanceToSquared(points[i]) < 10 * Number.EPSILON)
	                return;
	        }
	        // Shift all points one to the right
	        for (let i = numPoints; i > 0; i--) {
	            points[i].copy(points[i - 1]);
	        }
	        // Add the point at the front
	        points[0].copy(p);
	        numPoints++;
	    }
	    /** Updates the simplex and search direction quickly, meaning it doesn't perform a thourough search for the precise closest feature but just gets the general direction right. Uses the approach from https://blog.winter.dev/2020/gjk-algorithm/. */
	    static updateSimplexFast() {
	        switch (numPoints) {
	            case 2: return this.updateLine();
	            case 3: return this.updateTriangle();
	            case 4: return this.updateTetrahedron();
	            default: throw new Error("Shouldn't happen: " + numPoints);
	        }
	    }
	    static updateLine() {
	        let a = points[0];
	        let b = points[1];
	        ab.copy(b).sub(a);
	        ao.copy(a).negate();
	        if (ab.dot(ao) > 0) {
	            // Keep searching perpendicular to the line
	            direction.copy(ab).cross(ao).cross(ab);
	        }
	        else {
	            // Discard point B
	            numPoints--;
	            direction.copy(ao);
	        }
	    }
	    static updateTriangle() {
	        let a = points[0];
	        let b = points[1];
	        let c = points[2];
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ao.copy(a).negate();
	        abc.copy(ab).cross(ac);
	        if (v1$5.copy(abc).cross(ac).dot(ao) > 0) {
	            if (ac.dot(ao) > 0) {
	                // We're on the AC side
	                b.copy(c);
	                numPoints--;
	                direction.copy(ac).cross(ao).cross(ac);
	            }
	            else {
	                // We're on the AB side
	                numPoints--;
	                return this.updateLine();
	            }
	        }
	        else {
	            if (v1$5.copy(ab).cross(abc).dot(ao) > 0) {
	                // We're on the AB side
	                numPoints--;
	                return this.updateLine();
	            }
	            else {
	                // Origin must be above or below the triangle, figure out the direction
	                if (abc.dot(ao) > 0) {
	                    direction.copy(abc);
	                }
	                else {
	                    v1$5.copy(c);
	                    c.copy(b);
	                    b.copy(v1$5);
	                    direction.copy(abc).negate();
	                }
	            }
	        }
	    }
	    static updateTetrahedron() {
	        let a = points[0];
	        let b = points[1];
	        let c = points[2];
	        let d = points[3];
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ad.copy(d).sub(a);
	        ao.copy(a).negate();
	        abc.copy(ab).cross(ac);
	        acd.copy(ac).cross(ad);
	        adb.copy(ad).cross(ab);
	        // Simply do a triangle case with the face that's pointing towards the origin
	        if (abc.dot(ao) > 0) {
	            numPoints--;
	            return this.updateTriangle();
	        }
	        else if (acd.dot(ao) > 0) {
	            b.copy(c);
	            c.copy(d);
	            numPoints--;
	            return this.updateTriangle();
	        }
	        else if (adb.dot(ao) > 0) {
	            c.copy(b);
	            b.copy(d);
	            numPoints--;
	            return this.updateTriangle();
	        }
	        // If we're here, the origin is enclosed!
	    }
	    /** Computes the closest point to the origin on the current simplex and reduces the simplex to the smallest feature that contains that point. Method somewhat inspired by BulletPhysics. */
	    static updateSimplexAndClosestPoint(dst) {
	        let used; // A 4-bit number where the i'th bit represents if the i'th point (order: A, B, C, D) is present in the reduced feature.
	        requireFlip = 0;
	        switch (numPoints) {
	            case 1:
	                used = this.closestPointPoint(dst, points[0]);
	                break;
	            case 2:
	                used = this.closestPointLineSegment(dst, points[0], points[1]);
	                break;
	            case 3:
	                used = this.closestPointTriangle(dst, points[0], points[1], points[2]);
	                break;
	            case 4:
	                used = this.closestPointTetrahedron(dst, points[0], points[1], points[2], points[3]);
	                break;
	            default: throw new Error("Shouldn't get here! " + numPoints);
	        }
	        // Do the whole point assignerino based on whatever points make up the closest feature
	        let i = 0;
	        for (let j = 0; j < 4; j++) {
	            if (used & (1 << j)) {
	                points[i].copy(points[j]);
	                i++;
	            }
	        }
	        numPoints = i;
	        // Flip winding order of triangle if needed
	        if (requireFlip) {
	            v1$5.copy(points[1]);
	            points[1].copy(points[2]);
	            points[2].copy(v1$5);
	        }
	    }
	    static closestPointPoint(dst, a) {
	        dst.copy(a);
	        return 0b0001;
	    }
	    static closestPointLineSegment(dst, a, b) {
	        ab.copy(b).sub(a);
	        ao.copy(a).negate();
	        let t = Util.clamp(ab.dot(ao) / ab.dot(ab), 0, 1); // Clamp to the line segment
	        if (t === 0) {
	            dst.copy(a);
	            return 0b0001;
	        }
	        else if (t === 1) {
	            dst.copy(b);
	            return 0b0010;
	        }
	        else {
	            dst.copy(a).addScaledVector(ab, t);
	            return 0b0011;
	        }
	    }
	    static closestPointTriangle(dst, a, b, c) {
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ao.copy(a).negate();
	        let d1 = ab.dot(ao);
	        let d2 = ac.dot(ao);
	        if (d1 <= 0 && d2 <= 0) {
	            dst.copy(a);
	            return 0b0001;
	        }
	        bo.copy(b).negate();
	        let d3 = ab.dot(bo);
	        let d4 = ac.dot(bo);
	        if (d3 >= 0 && d4 <= d3) {
	            dst.copy(b);
	            return 0b0010;
	        }
	        let vc = d1 * d4 - d3 * d2;
	        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
	            let v = d1 / (d1 - d3);
	            dst.copy(a).addScaledVector(ab, v);
	            return 0b0011;
	        }
	        co.copy(c).negate();
	        let d5 = ab.dot(co);
	        let d6 = ac.dot(co);
	        if (d6 >= 0 && d5 <= d6) {
	            dst.copy(c);
	            return 0b0100;
	        }
	        let vb = d5 * d2 - d1 * d6;
	        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
	            let w = d2 / (d2 - d6);
	            dst.copy(a).addScaledVector(ac, w);
	            return 0b0101;
	        }
	        let va = d3 * d6 - d5 * d4;
	        if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
	            bc.copy(c).sub(b);
	            let w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
	            dst.copy(b).addScaledVector(bc, w);
	            return 0b0110;
	        }
	        let denom = 1 / (va + vb + vc);
	        let v = vb * denom;
	        let w = vc * denom;
	        dst.copy(a).addScaledVector(ab, v).addScaledVector(ac, w);
	        abc.copy(ab).cross(ac);
	        if (abc.dot(dst) > 0) {
	            requireFlip ^= 1;
	        }
	        return 0b0111;
	    }
	    static closestPointTetrahedron(dst, a, b, c, d) {
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ad.copy(d).sub(a);
	        bc.copy(c).sub(b);
	        bd.copy(d).sub(b);
	        ao.copy(a).negate();
	        bo.copy(b).negate();
	        abc.copy(ab).cross(ac);
	        acd.copy(ac).cross(ad);
	        adb.copy(ad).cross(ab);
	        bdc.copy(bd).cross(bc);
	        // Figure out which faces we need to check
	        let outsideABC = abc.dot(ao) > 0;
	        let outsideACD = acd.dot(ao) > 0;
	        let outsideADB = adb.dot(ao) > 0;
	        let outsideBDC = bdc.dot(bo) > 0;
	        let degenerate = Math.abs(abc.dot(ad)) < 10 * Number.EPSILON; // i.e. it has no volume
	        let minDist = Infinity;
	        let used;
	        let flip; // The face winding flip of the face with the min dist
	        // We simply do 4 triangle cases, one for each face of the tetrahedron, and the min wins.
	        if (outsideABC || degenerate) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$5, a, b, c);
	            let len = v1$5.lengthSq();
	            dst.copy(v1$5);
	            minDist = len;
	            used = res;
	            flip = requireFlip;
	        }
	        if (outsideACD || degenerate) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$5, a, c, d);
	            let len = v1$5.lengthSq();
	            if (len < minDist) {
	                dst.copy(v1$5);
	                minDist = len;
	                used = (res & 0b1) | ((res & 0b10) << 1) | ((res & 0b100) << 1); // Shift the bits around so they match the passed points
	                flip = requireFlip;
	            }
	        }
	        if (outsideADB || degenerate) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$5, a, d, b);
	            let len = v1$5.lengthSq();
	            if (len < minDist) {
	                dst.copy(v1$5);
	                minDist = len;
	                used = (res & 0b1) | ((res & 0b10) << 2) | ((res & 0b100) >> 1);
	                flip = requireFlip ^ 1; // Requires one additional flip
	            }
	        }
	        if (outsideBDC || degenerate) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$5, b, d, c);
	            let len = v1$5.lengthSq();
	            if (len < minDist) {
	                dst.copy(v1$5);
	                minDist = len;
	                used = ((res & 0b1) << 1) | ((res & 0b10) << 2) | ((res & 0b100));
	                flip = requireFlip ^ 1; // Also requires one additional flip
	            }
	        }
	        if (minDist === Infinity) {
	            // The origin is inside the tetrahedron!
	            dst.setScalar(0);
	            used = 0b1111;
	            flip = 0;
	        }
	        requireFlip = flip;
	        return used;
	    }
	    /** Given the last two intersecting shapes s1 and s2, returns the plane whose normal is the collision normal and whose offset represents the smallest amount s1 has to be moved along the collision normal such that s1 and s2 no longer intersect. Note that this method has to be called right after calling `checkIntersection`! */
	    static determineCollisionPlane(dst) {
	        if (lastS1 instanceof BallCollisionShape && lastS2 instanceof BallCollisionShape) {
	            return this.determineBallBallCollisionPlane(dst);
	        }
	        else if (lastS1 instanceof BallCollisionShape) {
	            return this.determineBallConvexCollisionPlane(dst);
	        }
	        else {
	            return this.determineConvexConvexCollisionPlane(dst);
	        }
	    }
	    static determineBallBallCollisionPlane(dst) {
	        let len = lastS1.radius + lastS2.radius - lastS1.body.position.distanceTo(lastS2.body.position);
	        dst.normal.copy(lastS1.body.position).sub(lastS2.body.position).normalize();
	        dst.constant = len;
	        return dst;
	    }
	    static determineBallConvexCollisionPlane(dst) {
	        let len = direction.length();
	        if (len === 0)
	            return this.determineConvexConvexCollisionPlane(dst); // The ball's center is contained inside the convex hull; we'll need to do EPA
	        // The collision normal is simply given by the vector from the closest point in the CSO (configuration space obstacle) to the origin
	        dst.normal.copy(direction).normalize();
	        dst.constant = lastS1.radius - len;
	        return dst;
	    }
	    static determineConvexConvexCollisionPlane(dst) {
	        // EPA code taken from https://github.com/kevinmoran/GJK/blob/master/GJK.h
	        let a = points[0];
	        let b = points[1];
	        let c = points[2];
	        let d = points[3];
	        faces[0][0].copy(a);
	        faces[0][1].copy(b);
	        faces[0][2].copy(c);
	        faces[0][3].copy(b).sub(a).cross(v1$5.copy(c).sub(a)).normalize();
	        faces[1][0].copy(a);
	        faces[1][1].copy(c);
	        faces[1][2].copy(d);
	        faces[1][3].copy(c).sub(a).cross(v1$5.copy(d).sub(a)).normalize();
	        faces[2][0].copy(a);
	        faces[2][1].copy(d);
	        faces[2][2].copy(b);
	        faces[2][3].copy(d).sub(a).cross(v1$5.copy(b).sub(a)).normalize();
	        faces[3][0].copy(b);
	        faces[3][1].copy(d);
	        faces[3][2].copy(c);
	        faces[3][3].copy(d).sub(b).cross(v1$5.copy(c).sub(b)).normalize();
	        let numFaces = 4;
	        let closestFace = 0;
	        for (let iteration = 0; iteration < maxEpaIterations; iteration++) {
	            // Find face that's closest to origin
	            let minDist = faces[0][0].dot(faces[0][3]);
	            closestFace = 0;
	            for (let i = 1; i < numFaces; i++) {
	                let dist = faces[i][0].dot(faces[i][3]);
	                if (dist < minDist) {
	                    minDist = dist;
	                    closestFace = i;
	                }
	            }
	            // search normal to face that's closest to origin
	            direction.copy(faces[closestFace][3]);
	            this.support(support, lastS1, lastS2, direction);
	            let dot = support.dot(direction);
	            dst.constant = Math.abs(dot);
	            if (faces[closestFace][3].lengthSq() > 0) {
	                dst.normal.copy(faces[closestFace][3]).multiplyScalar(Math.sign(dot) || 1).negate();
	            }
	            if (dot - minDist < epaTolerance) {
	                // Convergence (new point is not significantly further from origin)
	                return dst;
	            }
	            let numLooseEdges = 0;
	            // Find all triangles that are facing p
	            let i = 0;
	            while (i < numFaces) {
	                if (faces[i][3].dot(v1$5.copy(support).sub(faces[i][0])) > 0) { // triangle i faces p, remove it
	                    // Add removed triangle's edges to loose edge list.
	                    // If it's already there, remove it (both triangles it belonged to are gone)
	                    for (let j = 0; j < 3; j++) { // Three edges per face
	                        let currentEdge = [faces[i][j], faces[i][(j + 1) % 3]];
	                        let foundEdge = false;
	                        for (let k = 0; k < numLooseEdges; k++) { // Check if current edge is already in list
	                            if (looseEdges[k][1].equals(currentEdge[0]) && looseEdges[k][0].equals(currentEdge[1])) {
	                                // Edge is already in the list, remove it
	                                // THIS ASSUMES EDGE CAN ONLY BE SHARED BY 2 TRIANGLES (which should be true)
	                                // THIS ALSO ASSUMES SHARED EDGE WILL BE REVERSED IN THE TRIANGLES (which
	                                // should be true provided every triangle is wound CCW)
	                                looseEdges[k][0].copy(looseEdges[numLooseEdges - 1][0]); // Overwrite current edge
	                                looseEdges[k][1].copy(looseEdges[numLooseEdges - 1][1]); // with last edge in list
	                                numLooseEdges--;
	                                foundEdge = true;
	                                break;
	                                // exit loop because edge can only be shared once
	                            }
	                        } // endfor loose_edges
	                        if (!foundEdge) { // add current edge to list
	                            if (numLooseEdges >= maxEpaLooseEdges)
	                                break;
	                            looseEdges[numLooseEdges][0].copy(currentEdge[0]);
	                            looseEdges[numLooseEdges][1].copy(currentEdge[1]);
	                            numLooseEdges++;
	                        }
	                    }
	                    // Remove triangle i from list
	                    faces[i][0].copy(faces[numFaces - 1][0]);
	                    faces[i][1].copy(faces[numFaces - 1][1]);
	                    faces[i][2].copy(faces[numFaces - 1][2]);
	                    faces[i][3].copy(faces[numFaces - 1][3]);
	                    numFaces--;
	                    i--;
	                } // endif p can see triangle i
	                i++;
	            } // endfor num_faces
	            // Reconstruct polytope with p added
	            for (let i = 0; i < numLooseEdges; i++) {
	                if (numFaces >= maxEpaFaces)
	                    break;
	                faces[numFaces][0].copy(looseEdges[i][0]);
	                faces[numFaces][1].copy(looseEdges[i][1]);
	                faces[numFaces][2].copy(support);
	                faces[numFaces][3].copy(looseEdges[i][0]).sub(looseEdges[i][1]).cross(v1$5.copy(looseEdges[i][0]).sub(support)).normalize();
	                // Check for wrong normal to maintain CCW winding
	                let bias = 0.000001; // in case dot result is only slightly < 0 (because origin is on face)
	                if (faces[numFaces][0].dot(faces[numFaces][3]) + bias < 0) {
	                    let temp = faces[numFaces][0];
	                    faces[numFaces][0].copy(faces[numFaces][1]);
	                    faces[numFaces][1].copy(temp);
	                    faces[numFaces][3].negate();
	                }
	                numFaces++;
	            }
	        }
	        let dot = faces[closestFace][0].dot(faces[closestFace][3]);
	        dst.constant = Math.abs(dot);
	        dst.normal.copy(faces[closestFace][3]).multiplyScalar(Math.sign(dot) || 1).negate();
	        return dst;
	    }
	    static clearReferences() {
	        // To allow GC
	        lastS1 = null;
	        lastS2 = null;
	    }
	}

	let c_1 = new Vector3();
	let c_2 = new Vector3();
	let r_1 = new Vector3();
	let r_2 = new Vector3();
	let x$1 = new Vector3();
	let y = new Vector3();
	let z = new Vector3();
	let B = new Matrix3();
	let BInv = new Matrix3();
	let M_1 = new Matrix3();
	let M_2 = new Matrix3();
	let R_1 = new Matrix3();
	let R_2 = new Matrix3();
	let K_world = new Matrix3();
	let K_contact = new Matrix3();
	let K_contactInv = new Matrix3();
	let theta_1 = new Vector3();
	let theta_2 = new Vector3();
	let deltaDeltaTheta_12 = new Vector3();
	let deltaJ = new Vector3();
	let deltaI = new Vector3();
	let m1$3 = new Matrix3();
	/** Provides methods for performing an impulse-based collision response. Approach taken from https://www10.cs.fau.de/publications/theses/2010/Schornbaum_DA_2010.pdf. */
	class CollisionResponse {
	    /** Fixes interpenetration of two shapes. */
	    static solvePosition(collision) {
	        let threshold = 0.002; // This seems to be the lowest we can go?
	        let remainingPenetration = 0.5;
	        if (collision.depth < threshold)
	            return;
	        let distance = collision.depth - remainingPenetration * threshold;
	        collision.s1.body.position.addScaledVector(collision.normal, distance); // Always move the first body
	    }
	    /** Adjusts linear and angular velocities of the collision shapes. */
	    static solveVelocity(collision) {
	        collision.s1.getCenter(c_1);
	        collision.s2.getCenter(c_2);
	        r_1.copy(collision.point).sub(c_1);
	        r_2.copy(collision.point).sub(c_2);
	        x$1.copy(collision.normal);
	        if (x$1.z === 0)
	            y.set(x$1.y, -x$1.x, 0);
	        else
	            y.set(0, x$1.z, -x$1.y);
	        y.normalize();
	        z.copy(x$1).cross(y);
	        // This here forms the contact basis, where the first column represents the direction along the normal
	        B.set(x$1.x, y.x, z.x, x$1.y, y.y, z.y, x$1.z, y.z, z.z);
	        BInv.copy(B).transpose(); // B is orthonormal - BInv converts from contact space back into world space
	        M_1.identity().multiplyScalar(1 / collision.s1.mass);
	        M_2.identity().multiplyScalar(1 / collision.s2.mass);
	        R_1.set(0, -r_1.z, r_1.y, r_1.z, 0, -r_1.x, -r_1.y, r_1.x, 0);
	        R_2.set(0, -r_2.z, r_2.y, r_2.z, 0, -r_2.x, -r_2.y, r_2.x, 0);
	        K_world.copy(M_1).sub(m1$3.copy(R_1).multiply(collision.s1.invInertia).multiply(R_1)).add(M_2).sub(m1$3.copy(R_2).multiply(collision.s2.invInertia).multiply(R_2));
	        K_contact.copy(BInv).multiply(K_world).multiply(B); // Change of basis thang
	        K_contactInv.copy(K_contact).invert();
	        let b1 = collision.s1.body;
	        let b2 = collision.s2.body;
	        theta_1.copy(b1.angularVelocity).cross(r_1).add(b1.linearVelocity).applyMatrix3(BInv);
	        theta_2.copy(b2.angularVelocity).cross(r_2).add(b2.linearVelocity).applyMatrix3(BInv);
	        // Relative velocity along the normal
	        let deltaTheta = theta_1.x - theta_2.x;
	        if (deltaTheta > -0.0001)
	            return; // Not a "closing contact"
	        let res = collision.restitution;
	        if (deltaTheta > -0.5)
	            res = 0; // Set the restitution to 0 for low-impact collisions, allowing for objects to rest on the floor.
	        deltaDeltaTheta_12.set(-(1 + res) * (theta_1.x - theta_2.x), -(theta_1.y - theta_2.y), -(theta_1.z - theta_2.z));
	        deltaJ.copy(deltaDeltaTheta_12).applyMatrix3(K_contactInv);
	        let alpha = deltaJ.y ** 2 + deltaJ.z ** 2;
	        // Handle friction
	        let staticFriction = collision.friction;
	        if (alpha > staticFriction ** 2 * deltaJ.x ** 2) {
	            let beta = collision.friction / Math.sqrt(alpha);
	            deltaJ.x = deltaDeltaTheta_12.x / (K_contact.elements[0] + beta * (K_contact.elements[3] * deltaJ.y + K_contact.elements[6] * deltaJ.z));
	            let lambda = beta * deltaJ.x;
	            deltaJ.y *= lambda;
	            deltaJ.z *= lambda;
	        }
	        deltaI.copy(deltaJ).applyMatrix3(B);
	        // Finally, adjust the velocities
	        b1.linearVelocity.addScaledVector(deltaI, 1 / collision.s1.mass);
	        b1.angularVelocity.add(r_1.cross(deltaI).applyMatrix3(collision.s1.invInertia));
	        b2.linearVelocity.addScaledVector(deltaI, -1 / collision.s2.mass);
	        b2.angularVelocity.sub(r_2.cross(deltaI).applyMatrix3(collision.s2.invInertia));
	    }
	}

	const MAX_SUBSTEPS = 10;
	let v1$6 = new Vector3();
	let v2$3 = new Vector3();
	let v3$1 = new Vector3();
	let p1 = new Plane();
	let rayCastAabb = new Box3();
	let singletonShape$1 = new SingletonCollisionShape();
	let combinedCollisionShape = new CombinedCollisionShape(null, null);
	let utilBody = new RigidBody();
	utilBody.addCollisionShape(singletonShape$1);
	utilBody.addCollisionShape(combinedCollisionShape);
	/** Represents a physics simulation world. */
	class World {
	    constructor() {
	        this.bodies = [];
	        this.gravity = new Vector3();
	        this.octree = new Octree();
	        /** List of shapes that are currently in contact according to the CCD (Continuous Collision Detection) pass. */
	        this.inContactCcd = new Set();
	        this.newInContactCcd = new Set();
	        /** List of shapes that are currently in contact. */
	        this.inContact = new Set();
	        this.newInContact = new Set();
	        /** This cache can speed up broadphase lookups by reusing results. */
	        this.cachedBroadphaseResults = new Map();
	    }
	    add(body) {
	        if (body.world) {
	            throw new Error("RigidBody already belongs to a world.");
	        }
	        this.bodies.push(body);
	        body.world = this;
	        body.syncShapes();
	    }
	    /** Steps the physics world by `dt` seconds. */
	    step(dt) {
	        this.substep(dt, 0, 0);
	    }
	    substep(dt, startT, depth) {
	        // Roughly follows Algorithm 4 from https://www10.cs.fau.de/publications/theses/2010/Schornbaum_DA_2010.pdf.
	        if (dt < 0.00001 || depth >= MAX_SUBSTEPS)
	            return;
	        let dynamicShapes = [];
	        // Integrate all the bodies
	        for (let i = 0; i < this.bodies.length; i++) {
	            let body = this.bodies[i];
	            if (!body.enabled)
	                continue;
	            body.storePrevious();
	            body.onBeforeIntegrate(dt);
	            body.integrate(dt);
	            body.onAfterIntegrate(dt);
	            body.collisions.length = 0;
	            if (body.type === RigidBodyType.Dynamic) {
	                dynamicShapes.push(...body.shapes);
	            }
	        }
	        this.cachedBroadphaseResults.clear();
	        // Check for CCD collisions
	        let ccdCollisions = this.computeCollisions(dynamicShapes, true);
	        let t = 1;
	        // Find the first collision with a **new** shape
	        for (let i = 0; i < ccdCollisions.length; i++) {
	            let collision = ccdCollisions[i];
	            if (!this.inContactCcd.has(collision.s2)) {
	                t = Math.min(collision.timeOfImpact, t);
	            }
	        }
	        let cumT = startT + t * (1 - startT); // coom (it means cumulative incase you don't know)
	        // Now, revert all the bodies back according to the CCD result
	        for (let i = 0; i < this.bodies.length; i++) {
	            let body = this.bodies[i];
	            if (!body.enabled)
	                continue;
	            body.revert(t);
	            body.collisions.length = 0;
	            if (body.type !== RigidBodyType.Dynamic)
	                continue;
	            // Add external forces
	            let externalForce = v1$6.set(0, 0, 0);
	            externalForce.add(this.gravity);
	            body.linearVelocity.addScaledVector(externalForce, dt * t);
	        }
	        // Now, compute the regular collisions
	        let collisions = this.computeCollisions(dynamicShapes, false);
	        let collidingBodies = [];
	        // Get a list of all bodies that are encountering a collision
	        for (let i = 0; i < collisions.length; i++) {
	            let collision = collisions[i];
	            if (!collidingBodies.includes(collision.s1.body))
	                collidingBodies.push(collision.s1.body);
	            if (!collidingBodies.includes(collision.s2.body))
	                collidingBodies.push(collision.s2.body);
	        }
	        collidingBodies.sort((a, b) => a.evaluationOrder - b.evaluationOrder);
	        for (let i = 0; i < collidingBodies.length; i++)
	            collidingBodies[i].onBeforeCollisionResponse(cumT, dt * t);
	        // Now, solve all the collisions
	        for (let i = 0; i < collisions.length; i++) {
	            let collision = collisions[i];
	            if ((collision.s1.collisionResponseMask & collision.s2.collisionResponseMask) === 0)
	                continue; // The masks don't match, don't do collision response
	            CollisionResponse.solvePosition(collision);
	            CollisionResponse.solveVelocity(collision);
	        }
	        for (let i = 0; i < collidingBodies.length; i++)
	            collidingBodies[i].onAfterCollisionResponse(cumT, dt * t);
	        this.inContactCcd = this.newInContactCcd;
	        this.newInContactCcd = new Set();
	        this.inContact = this.newInContact;
	        this.newInContact = new Set();
	        this.substep(dt * (1 - t), cumT, depth + 1);
	    }
	    /** Computes all collision for a set of dynamic shapes. */
	    computeCollisions(dynamicShapes, isCcdPass) {
	        let collisions = [];
	        for (let i = 0; i < dynamicShapes.length; i++) {
	            let shape = dynamicShapes[i];
	            if (!shape.body.enabled)
	                continue;
	            // Figure out which shape to use for the broadphase
	            let broadphaseShape = shape.broadphaseShape || shape;
	            let collisionCandidates = this.cachedBroadphaseResults.get(broadphaseShape);
	            let shapeCollisions = [];
	            if (!collisionCandidates) {
	                // Query the octree for AABB intersections
	                collisionCandidates = this.octree.intersectAabb(broadphaseShape.boundingBox);
	                this.cachedBroadphaseResults.set(broadphaseShape, collisionCandidates);
	            }
	            // Now, loop over all possible candidates
	            outer: for (let j = 0; j < collisionCandidates.length; j++) {
	                let candidate = collisionCandidates[j];
	                if (shape === candidate)
	                    continue;
	                if ((shape.collisionDetectionMask & candidate.collisionDetectionMask) === 0)
	                    continue;
	                if (!candidate.body.enabled)
	                    continue;
	                // Check if this pair of shapes is already colliding
	                for (let k = 0; k < collisions.length; k++) {
	                    let c = collisions[k];
	                    if (c.s1 === candidate && c.s2 === shape)
	                        continue outer; // No double collisions
	                }
	                if (isCcdPass) {
	                    // Compute the time of impact of the two shapes
	                    let timeOfImpact = CollisionDetection.determineTimeOfImpact(shape, candidate);
	                    if (timeOfImpact === null)
	                        continue;
	                    let collision = new Collision(shape, candidate);
	                    collision.timeOfImpact = timeOfImpact;
	                    this.newInContactCcd.add(candidate);
	                    collisions.push(collision);
	                }
	                else {
	                    // First, let's check if the two shapes actually intersect
	                    let collides = CollisionDetection.checkIntersection(shape, candidate);
	                    if (!collides)
	                        continue;
	                    let collision = new Collision(shape, candidate);
	                    let isMainCollisionShape = !!(shape.collisionDetectionMask & 1); // Meaning, no aux stuff, no triggers, whatever
	                    if (isMainCollisionShape) {
	                        // Compute the plane of collision
	                        let collisionPlane = CollisionDetection.determineCollisionPlane(p1);
	                        collision.supplyCollisionPlane(collisionPlane);
	                    }
	                    // Perform a collision correction step: Sometimes, shapes can collide with internal edges, i.e. edges that aren't visible to the outside, leading to incorrect results. We try to catch and correct these cases here.
	                    if (isMainCollisionShape)
	                        for (let k = 0; k < shapeCollisions.length; k++) {
	                            let c2 = shapeCollisions[k];
	                            let distSq = collision.point2.distanceToSquared(c2.point2);
	                            if (distSq >= 0.1 ** 2)
	                                continue; // Heuristic: If the two collision points are really close, the two shapes themselves are touching and we've hit at least one internal edge
	                            // Create a new collision shape that's the convex hull of the two individual shapes
	                            combinedCollisionShape.s1 = c2.s2;
	                            combinedCollisionShape.s2 = candidate;
	                            // Perform an intersection test on this combined shape. Our hope is that this gives us a good idea of what the actual collision normal should be.
	                            CollisionDetection.checkIntersection(shape, combinedCollisionShape);
	                            CollisionDetection.determineCollisionPlane(p1);
	                            let combinedNormal = v3$1.copy(p1.normal);
	                            // Exit if the combined normal has a greater angle to either collision normal than they have to each other (meaning it's probably out of wack)
	                            let dotBetween = collision.normal.dot(c2.normal);
	                            if (collision.normal.dot(combinedNormal) < dotBetween - 1e-10 || c2.normal.dot(combinedNormal) < dotBetween - 1e-10) {
	                                continue;
	                            }
	                            let size;
	                            // Now, along the combined collision normal from above, perform a ray cast onto both shapes to figure out the "correct" normal of the face that's actually visible and part of the collision (as opposed to the internal edge we can't see). Note that sometimes this method fails and doesn't hit the right face, but that's usually caught later.
	                            size = candidate.boundingBox.min.distanceTo(candidate.boundingBox.max);
	                            let hit1 = CollisionDetection.castRay(candidate, singletonShape$1, candidate.getCenter(v1$6).addScaledVector(combinedNormal, size), v2$3.copy(combinedNormal).negate(), size);
	                            size = c2.s2.boundingBox.min.distanceTo(c2.s2.boundingBox.max);
	                            let hit2 = CollisionDetection.castRay(c2.s2, singletonShape$1, c2.s2.getCenter(v1$6).addScaledVector(combinedNormal, size), v2$3.copy(combinedNormal).negate(), size);
	                            // If we've hit the shapes, see if we should replace the collision normals of the collisions
	                            if (hit1 && hit1.normal.dot(combinedNormal) >= collision.normal.dot(combinedNormal)) { // Only replace if the hit normal is an improvement over the old normal
	                                collision.supplyCollisionPlane(p1.set(hit1.normal, collision.depth));
	                            }
	                            if (hit2 && hit2.normal.dot(combinedNormal) >= c2.normal.dot(combinedNormal)) {
	                                c2.supplyCollisionPlane(p1.set(hit2.normal, c2.depth));
	                            }
	                            break;
	                        }
	                    collisions.push(collision);
	                    shapeCollisions.push(collision);
	                    shape.body.collisions.push(collision);
	                    collision.s2.body.collisions.push(collision);
	                    this.newInContact.add(candidate);
	                }
	            }
	        }
	        // We need to update the material properties at the end because here, all the normals are computed
	        for (let i = 0; i < collisions.length; i++)
	            collisions[i].updateMaterialProperties();
	        return collisions;
	    }
	    /** Casts a ray into the world and returns all intersections. */
	    castRay(rayOrigin, rayDirection, lambdaMax, collisionDetectionMask = 0b1) {
	        // Build the AABB of the ray
	        rayCastAabb.makeEmpty();
	        rayCastAabb.expandByPoint(rayOrigin);
	        rayCastAabb.expandByPoint(v1$6.copy(rayOrigin).addScaledVector(rayDirection, lambdaMax));
	        // Query the octree for possible candidates
	        let candidates = this.octree.intersectAabb(rayCastAabb);
	        let hits = [];
	        for (let candidate of candidates) {
	            if ((candidate.collisionDetectionMask & collisionDetectionMask) === 0)
	                continue;
	            // Perform a GJK ray cast
	            let hit = CollisionDetection.castRay(candidate, singletonShape$1, rayOrigin, rayDirection, lambdaMax);
	            if (hit)
	                hits.push({ ...hit, shape: candidate });
	        }
	        return hits.sort((a, b) => a.lambda - b.lambda);
	    }
	    /** Performs convex casting of a given shape: Translates a shape from its current position linearly along a direction (swept volume) and returns all intersections with other shapes.  */
	    castShape(shape, direction, lambdaMax) {
	        // Build the AABB of the swept volume
	        rayCastAabb.makeEmpty();
	        rayCastAabb.expandByPoint(shape.boundingBox.min);
	        rayCastAabb.expandByPoint(shape.boundingBox.max);
	        rayCastAabb.expandByPoint(v1$6.copy(shape.boundingBox.min).addScaledVector(direction, lambdaMax));
	        rayCastAabb.expandByPoint(v1$6.copy(shape.boundingBox.max).addScaledVector(direction, lambdaMax));
	        // Query the octree for possible candidates
	        let candidates = this.octree.intersectAabb(rayCastAabb);
	        let hits = [];
	        let negDirection = v2$3.copy(direction).negate();
	        for (let candidate of candidates) {
	            if (shape === candidate)
	                continue;
	            if ((shape.collisionDetectionMask & candidate.collisionDetectionMask) === 0)
	                continue;
	            if (!candidate.body.enabled)
	                continue;
	            if (candidate.body.linearVelocity.lengthSq() > 0)
	                continue;
	            // Perform a GJK ray cast on the Minkowski difference
	            let hit = CollisionDetection.castRay(shape, candidate, v1$6.setScalar(0), negDirection, lambdaMax);
	            if (hit)
	                hits.push({ ...hit, shape: candidate });
	        }
	        return hits.sort((a, b) => a.lambda - b.lambda);
	    }
	}

	/** How often the physics will be updated, per second. */
	const PHYSICS_TICK_RATE = 120;
	const PLAYBACK_SPEED = 1; // Major attack surface for cheaters here 😟
	/** The vertical offsets of overlay shapes to get them all visually centered. */
	const SHAPE_OVERLAY_OFFSETS = {
	    "shapes/images/helicopter.dts": -67,
	    "shapes/items/superjump.dts": -70,
	    "shapes/items/superbounce.dts": -55,
	    "shapes/items/superspeed.dts": -53,
	    "shapes/items/shockabsorber.dts": -53,
	    "shapes/items/megamarble.dts": -70
	};
	const SHAPE_OVERLAY_SCALES = {
	    "shapes/items/megamarble.dts": 60
	};
	/** The time in milliseconds when the marble is released from the start pad. */
	const GO_TIME = 3500;
	/** Default camera pitch */
	const DEFAULT_PITCH = 0.45;
	const BLAST_CHARGE_TIME = 25000;
	const MAX_TIME = 999 * 60 * 1000 + 59 * 1000 + 999; // 999:59.99, should be large enough
	const MBP_SONGS = ['astrolabe.ogg', 'endurance.ogg', 'flanked.ogg', 'grudge.ogg', 'mbp old shell.ogg', 'quiet lab.ogg', 'rising temper.ogg', 'seaside revisited.ogg', 'the race.ogg'];
	// Used for frame rate limiting working correctly
	const decoyCanvas = document.querySelector('#decoy-canvas');
	const decoyCtx = decoyCanvas.getContext('2d');
	/** The map used to get particle emitter options for a ParticleEmitterNode. */
	const particleEmitterMap = {
	    MarbleBounceEmitter: bounceParticleOptions,
	    MarbleTrailEmitter: particleNodeEmittersEmitterOptions.MarbleTrailEmitter,
	    MarbleSuperJumpEmitter: Object.assign(ParticleEmitter.cloneOptions(superJumpParticleOptions), {
	        emitterLifetime: 5000,
	        ambientVelocity: new Vector3(-0.3, 0, -0.5)
	    }),
	    MarbleSuperSpeedEmitter: Object.assign(ParticleEmitter.cloneOptions(superSpeedParticleOptions), {
	        emitterLifetime: 5000,
	        ambientVelocity: new Vector3(-0.5, 0, -0.5)
	    }),
	    LandMineEmitter: particleNodeEmittersEmitterOptions.LandMineEmitter,
	    LandMineSmokeEmitter: landMineSmokeParticle,
	    LandMineSparkEmitter: landMineSparksParticle,
	    NukeEmitter: particleNodeEmittersEmitterOptions.LandMineEmitter,
	    NukeSmokeEmitter: nukeSmokeParticle,
	    NukeSparkEmitter: nukeSparksParticle,
	    FireWorkSmokeEmitter: fireworkSmoke,
	    RedFireWorkSparkEmitter: redSpark,
	    RedFireWorkTrailEmitter: redTrail,
	    BlueFireWorkSparkEmitter: blueSpark,
	    BlueFireWorkTrailEmitter: blueTrail
	};
	/** The central control unit of gameplay. Handles loading, simulation and rendering. */
	class Level extends Scheduler {
	    constructor(mission, offline = null) {
	        super();
	        this.interiors = [];
	        this.sharedInteriorData = new Map();
	        this.triggers = [];
	        this.shapes = [];
	        /** Holds data shared between multiple shapes with the same constructor and .dts path. */
	        this.sharedShapeData = new Map();
	        /** The shapes used for drawing HUD overlay (powerups in the corner) */
	        this.overlayShapes = [];
	        /** The last performance.now() time the physics were ticked. */
	        this.lastPhysicsTick = null;
	        this.lastFrameTime = null;
	        /** Offline levels are meant for video rendering, not real-time play. */
	        this.offline = false;
	        this.offlineSettings = null;
	        this.started = false;
	        this.paused = true;
	        this.pausedAt = null;
	        /** If the level is stopped, it shouldn't be used anymore. */
	        this.stopped = false;
	        /** The timestate at the moment of finishing. */
	        this.finishTime = null;
	        /** The maximum time that has been displayed in the current attempt. */
	        this.maxDisplayedTime = 0;
	        this.pitch = 0;
	        this.yaw = 0;
	        this.lastVerticalTranslation = new Vector3();
	        this.currentUp = new Vector3(0, 0, 1);
	        /** The last time the orientation was changed (by a gravity modifier) */
	        this.orientationChangeTime = -Infinity;
	        /** The old camera orientation quat */
	        this.oldOrientationQuat = new Quaternion();
	        /** The new target camera orientation quat  */
	        this.newOrientationQuat = new Quaternion();
	        /** See usage. */
	        this.previousMouseMovementDistance = 0;
	        this.defaultGravity = 20;
	        this.currentTimeTravelBonus = 0;
	        this.heldPowerUp = null;
	        this.totalGems = 0;
	        this.gemCount = 0;
	        this.blastAmount = 0;
	        this.outOfBounds = false;
	        /** When the jump button was pressed, remember that it was pressed until the next tick to execute the jump. */
	        this.jumpQueued = false;
	        this.useQueued = false;
	        this.blastQueued = false;
	        /** Whether or not the player is currently pressing the restart button. */
	        this.pressingRestart = false;
	        this.restartPressTime = null;
	        /** Stores the shape that is the destination of the current checkpoint. */
	        this.currentCheckpoint = null;
	        /** If the checkpoint was triggered by a trigger, this field stores that trigger. */
	        this.currentCheckpointTrigger = null;
	        this.checkpointCollectedGems = new Set();
	        this.checkpointHeldPowerUp = null;
	        /** Up vector at the point of checkpointing */
	        this.checkpointUp = null;
	        this.checkpointBlast = null;
	        this.analytics = {
	            missionPath: null,
	            startTime: Date.now(),
	            tries: 0,
	            finishes: 0,
	            outOfBoundsCount: 0,
	            timePaused: 0,
	            endTime: null,
	            userRandomId: StorageManager.data.randomId
	        };
	        this.mission = mission;
	        this.loadingState = { loaded: 0, total: 0 };
	        this.offline = !!offline;
	        this.offlineSettings = offline;
	        this.analytics.missionPath = mission.path;
	    }
	    /** Loads all necessary resources and builds the mission. */
	    async init() {
	        var _a;
	        // Scan the mission for elements to determine required loading effort
	        for (let element of this.mission.allElements) {
	            if ([MissionElementType.InteriorInstance, MissionElementType.Item, MissionElementType.PathedInterior, MissionElementType.StaticShape, MissionElementType.TSStatic].includes(element._type)) {
	                this.loadingState.total++;
	                // Override the end pad element. We do this because only the last finish pad element will actually do anything.
	                if (element._type === MissionElementType.StaticShape &&
	                    ['endpad', 'endpad_mbg', 'endpad_mbp'].includes((_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase())) {
	                    this.endPadElement = element;
	                }
	            }
	        }
	        this.loadingState.total += 6 + 1 + 3 + 6 + 1; // For the scene, marble, UI, sounds (includes music!), and scene compile
	        this.timeState = {
	            timeSinceLoad: -1000 / PHYSICS_TICK_RATE,
	            currentAttemptTime: 0,
	            gameplayClock: 0,
	            physicsTickCompletion: 0,
	            tickIndex: 0
	        };
	        // Apply overridden gravity
	        if (this.mission.misFile.marbleAttributes["gravity"] !== undefined) {
	            this.defaultGravity = MisParser.parseNumber(this.mission.misFile.marbleAttributes["gravity"]);
	        }
	        if (!this.offline) {
	            this.audio = mainAudioManager;
	        }
	        else {
	            this.audio = new AudioManager();
	            this.audio.init({ duration: this.offlineSettings.duration });
	            this.audio.setAssetPath(mainAudioManager.assetPath);
	            this.audio.soundGain.gain.value = this.offlineSettings.soundVolume ** 2;
	            this.audio.musicGain.gain.value = this.offlineSettings.musicVolume ** 2;
	            this.audio.currentTimeOverride = 0;
	        }
	        this.world = new World();
	        await this.initScene();
	        await this.initMarble();
	        this.loadingState.loaded += 1;
	        this.particles = new ParticleManager(this);
	        await this.particles.init(mainRenderer);
	        this.scene.particleManager = this.particles;
	        let soundPromise = this.initSounds();
	        await this.addSimGroup(this.mission.root);
	        await this.initUi();
	        this.loadingState.loaded += 3;
	        await soundPromise;
	        this.loadingState.loaded += 6;
	        this.scene.compile();
	        this.loadingState.loaded += 1;
	        this.replay = new Replay(this);
	    }
	    async start() {
	        if (this.stopped)
	            return;
	        this.started = true;
	        this.paused = false;
	        this.restart(true);
	        for (let interior of this.interiors)
	            await interior.onLevelStart();
	        for (let shape of this.shapes)
	            await shape.onLevelStart();
	        this.audio.normalizePositionalAudioVolume();
	        this.music.play();
	        resize(false); // To update renderer
	        this.updateCamera(this.timeState); // Ensure that the camera is positioned correctly before the first tick for correct positional audio playback
	        if (!this.offline) {
	            this.tryRender();
	            this.tickInterval = setInterval(this.tick.bind(this));
	            this.lastPhysicsTick = performance.now(); // First render usually takes longer (JIT moment), so reset the last physics tick back to now
	            mainCanvas.classList.remove('hidden');
	        }
	    }
	    async initScene() {
	        this.scene = new Scene(mainRenderer);
	        let addedShadow = false;
	        // There could be multiple suns, so do it for all of them
	        for (let element of this.mission.allElements) {
	            if (element._type !== MissionElementType.Sun)
	                continue;
	            let directionalColor = MisParser.parseVector4(element.color);
	            let ambientColor = MisParser.parseVector4(element.ambient);
	            let sunDirection = MisParser.parseVector3(element.direction);
	            // Create the ambient light
	            this.scene.addAmbientLight(new AmbientLight(new Vector3(ambientColor.x, ambientColor.y, ambientColor.z)));
	            // Create the sunlight
	            let directionalLight = new DirectionalLight(mainRenderer, new Vector3(directionalColor.x, directionalColor.y, directionalColor.z), sunDirection.clone());
	            this.scene.addDirectionalLight(directionalLight);
	            if (!addedShadow) {
	                addedShadow = true;
	                let shadowCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 10);
	                directionalLight.enableShadowCasting(256, shadowCamera);
	            }
	        }
	        let skyElement = this.mission.allElements.find((element) => element._type === MissionElementType.Sky);
	        let fogColor = MisParser.parseVector4(skyElement.fogcolor);
	        let skySolidColor = MisParser.parseVector4(skyElement.skysolidcolor);
	        // This is kind of a weird situation here. It seems as if when the skysolidcolor isn't the default value, it's used as the skycolor; otherwise, fog color is used. Strange.
	        if (skySolidColor.x !== 0.6 || skySolidColor.y !== 0.6 || skySolidColor.z !== 0.6)
	            fogColor = skySolidColor;
	        // Uber strange way Torque maps these values:
	        if (fogColor.x > 1)
	            fogColor.x = 1 - (fogColor.x - 1) % 256 / 256;
	        if (fogColor.y > 1)
	            fogColor.y = 1 - (fogColor.y - 1) % 256 / 256;
	        if (fogColor.z > 1)
	            fogColor.z = 1 - (fogColor.z - 1) % 256 / 256;
	        mainRenderer.setClearColor(fogColor.x, fogColor.y, fogColor.z, 1);
	        this.camera = new PerspectiveCamera(StorageManager.data.settings.fov, window.innerWidth / window.innerHeight, 0.01, MisParser.parseNumber(skyElement.visibledistance));
	        if (skyElement.useskytextures === "1") {
	            // Create the skybox
	            let skyboxCubeTexture = await this.createSkyboxCubeTexture(skyElement.materiallist.slice(skyElement.materiallist.indexOf('data/') + 'data/'.length), true);
	            if (skyboxCubeTexture) {
	                let material = new Material();
	                material.isSky = true;
	                material.envMap = skyboxCubeTexture;
	                material.depthWrite = false;
	                material.renderOrder = -1000; // Render before everything else
	                let geometry = new Geometry();
	                geometry.positions.push(-1, -1, 0);
	                geometry.positions.push(3, -1, 0);
	                geometry.positions.push(-1, 3, 0);
	                geometry.materials.push(0, 0, 0);
	                geometry.indices.push(0, 1, 2);
	                geometry.fillRest();
	                let mesh = new Mesh(geometry, [material]);
	                this.scene.add(mesh);
	            }
	        }
	        let envmapCubeTexture = await this.createSkyboxCubeTexture('skies/sky_day.dml', false, 128); // Always the default MBG skybox
	        // Use the skybox as the environment map. Don't use the actual envmap image file because its projection requires like three PhDs in mathematics.
	        this.envMap = envmapCubeTexture;
	    }
	    async createSkyboxCubeTexture(dmlPath, increaseLoading, resampleTo) {
	        let dmlDirectoryPath = dmlPath.slice(0, dmlPath.lastIndexOf('/'));
	        let dmlFile = await this.mission.getResource(dmlPath);
	        if (dmlFile) {
	            // Get all skybox images
	            let lines = (await ResourceManager.readBlobAsText(dmlFile)).split('\n').map(x => x.trim().toLowerCase());
	            let promises = lines.slice(0, 6).map(async (line) => {
	                let filename = this.mission.getFullNamesOf(dmlDirectoryPath + '/' + line)[0];
	                let result;
	                if (!filename) {
	                    result = new Image();
	                }
	                else {
	                    try {
	                        result = await this.mission.getImage(dmlDirectoryPath + '/' + filename);
	                    }
	                    catch (e) {
	                        console.error("Error loading skybox image:", e, "Defaulting to empty image.");
	                        result = new Image();
	                    }
	                }
	                if (increaseLoading)
	                    this.loadingState.loaded++;
	                return result;
	            });
	            let skyboxImages = await Promise.all(promises);
	            // Reorder them to the proper order
	            skyboxImages = Util.remapIndices(skyboxImages, [1, 3, 4, 5, 0, 2]);
	            if (resampleTo !== undefined) {
	                skyboxImages = await Promise.all(skyboxImages.map(x => Util.resampleImage(x, resampleTo, resampleTo)));
	            }
	            let sizes = skyboxImages.flatMap(x => [x.width, x.height]);
	            if (new Set(sizes).size > 1) {
	                // Skybox images have different sizes: Let's bring them in line.
	                let maxSize = Math.max(...sizes);
	                skyboxImages = await Promise.all(skyboxImages.map(x => Util.resampleImage(x, maxSize, maxSize)));
	            }
	            let skyboxTexture = new CubeTexture(mainRenderer, skyboxImages);
	            return skyboxTexture;
	        }
	        else {
	            if (increaseLoading)
	                this.loadingState.loaded += 6;
	            return null;
	        }
	    }
	    async initMarble() {
	        this.marble = new Marble(this);
	        await this.marble.init();
	        this.scene.add(this.marble.group);
	        this.world.add(this.marble.body);
	    }
	    async initUi() {
	        // Load all necessary UI image elements
	        await state.menu.hud.load();
	        // Set up the HUD overlay
	        let hudOverlayShapePaths = new Set();
	        for (let shape of this.shapes) {
	            if (shape instanceof PowerUp || shape instanceof Gem) {
	                if (shape instanceof PowerUp && shape.autoUse)
	                    continue; // Can't collect these aye
	                // We need to display the gem and powerup shapes in the HUD
	                if (shape instanceof RandomPowerUp) {
	                    for (let path of shape.getAllDtsPaths())
	                        hudOverlayShapePaths.add(path);
	                }
	                else {
	                    hudOverlayShapePaths.add(shape.dtsPath);
	                }
	            }
	        }
	        this.overlayScene = new Scene(mainRenderer);
	        let overlayLight = new AmbientLight(new Vector3().setScalar(1));
	        this.overlayScene.addAmbientLight(overlayLight);
	        this.overlayCamera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, -window.innerHeight / 2, window.innerHeight / 2, 1, 1000);
	        this.overlayCamera.up.set(0, 0, -1);
	        this.overlayCamera.lookAt(new Vector3(1, 0, 0));
	        for (let path of hudOverlayShapePaths) {
	            let shape = new Shape();
	            shape.dtsPath = path;
	            shape.ambientRotate = true;
	            shape.showSequences = false;
	            // MBP's UI gem color is randomized
	            if (path.includes("gem") && state.menu.hud instanceof MbpHud)
	                shape.matNamesOverride['base.gem'] = Gem.pickRandomColor() + '.gem';
	            await shape.init();
	            this.overlayShapes.push(shape);
	            this.overlayScene.add(shape.group);
	            if (path.includes("gem")) {
	                shape.ambientSpinFactor /= -2; // Gems spin the other way apparently
	            }
	            else {
	                shape.ambientSpinFactor /= 2;
	                shape.setOpacity(0);
	            }
	        }
	        this.overlayScene.compile();
	        if (state.menu.pauseScreen instanceof MbpPauseScreen)
	            state.menu.pauseScreen.jukebox.reset();
	    }
	    async initSounds() {
	        let musicFileName;
	        if (this.mission.modification === 'ultra') {
	            musicFileName = 'tim trance.ogg'; // ALWAYS play this banger
	            this.originalMusicName = musicFileName;
	        }
	        else if (state.modification !== 'gold' && this.mission.missionInfo.music && this.mission.missionInfo.music.toLowerCase() !== 'pianoforte.ogg') {
	            musicFileName = this.mission.missionInfo.music.toLowerCase();
	            this.originalMusicName = musicFileName;
	        }
	        else {
	            if (this.mission.modification === 'gold') {
	                // Play the song based on the level index
	                let missionArray = MissionLibrary.allCategories.find(x => x.includes(this.mission));
	                let levelIndex = missionArray.indexOf(this.mission);
	                musicFileName = ['groovepolice.ogg', 'classic vibe.ogg', 'beach party.ogg'][(levelIndex + 1) % 3]; // The default music choice is based off of level index
	                // Yes, the extra space is intentional
	                this.originalMusicName = ['groove police.ogg', 'classic vibe.ogg', 'beach party.ogg'][(levelIndex + 1) % 3];
	            }
	            else {
	                // Play a random *MBP* song
	                musicFileName = Util.randomFromArray(MBP_SONGS);
	                this.originalMusicName = musicFileName;
	            }
	        }
	        if (state.modification === 'platinum')
	            musicFileName = 'music/' + musicFileName;
	        let toLoad = ["spawn.wav", "ready.wav", "set.wav", "go.wav", "whoosh.wav", musicFileName];
	        if (isFinite(this.mission.qualifyTime) && state.modification === 'platinum')
	            toLoad.push("alarm.wav", "alarm_timeout.wav", "infotutorial.wav");
	        try {
	            await this.audio.loadBuffers(toLoad);
	        }
	        catch (e) {
	            // Something died, maybe it was the music, try replacing it with a song we know exists
	            let newMusic = Util.randomFromArray(MBP_SONGS);
	            this.originalMusicName = newMusic;
	            toLoad[toLoad.indexOf(musicFileName)] = 'music/' + newMusic;
	            musicFileName = 'music/' + newMusic;
	            await this.audio.loadBuffers(toLoad);
	        }
	        this.music = this.audio.createAudioSource(musicFileName, this.audio.musicGain);
	        this.music.setLoop(true);
	        await this.music.promise;
	    }
	    /** Adds all elements within a sim group. */
	    async addSimGroup(simGroup) {
	        // Check if it's a pathed interior group
	        if (simGroup.elements.find((element) => element._type === MissionElementType.PathedInterior)) {
	            // Create the pathed interior
	            let pathedInterior = await PathedInterior.createFromSimGroup(simGroup, this);
	            if (!pathedInterior)
	                return;
	            this.scene.add(pathedInterior.mesh);
	            if (pathedInterior.hasCollision)
	                this.world.add(pathedInterior.body);
	            for (let trigger of pathedInterior.triggers) {
	                this.world.add(trigger.body);
	                this.triggers.push(trigger);
	            }
	            return;
	        }
	        let promises = [];
	        for (let element of simGroup.elements) {
	            switch (element._type) {
	                case MissionElementType.SimGroup:
	                    promises.push(this.addSimGroup(element));
	                    break;
	                case MissionElementType.InteriorInstance:
	                    promises.push(this.addInterior(element));
	                    break;
	                case MissionElementType.StaticShape:
	                case MissionElementType.Item:
	                    promises.push(this.addShape(element));
	                    break;
	                case MissionElementType.Trigger:
	                    promises.push(this.addTrigger(element));
	                    break;
	                case MissionElementType.TSStatic:
	                    promises.push(this.addTSStatic(element));
	                    break;
	                case MissionElementType.ParticleEmitterNode:
	                    this.addParticleEmitterNode(element);
	                    break;
	            }
	        }
	        await Promise.all(promises);
	    }
	    async addInterior(element) {
	        let { dif: difFile, path } = await this.mission.getDif(element.interiorfile);
	        if (!difFile)
	            return;
	        let interior = new Interior(difFile, path, this);
	        this.interiors.push(interior);
	        await Util.wait(10); // See shapes for the meaning of this hack
	        await interior.init(element._id);
	        this.scene.add(interior.mesh);
	        let interiorPosition = MisParser.parseVector3(element.position);
	        let interiorRotation = MisParser.parseRotation(element.rotation);
	        let interiorScale = MisParser.parseVector3(element.scale);
	        let hasCollision = interiorScale.x !== 0 && interiorScale.y !== 0 && interiorScale.z !== 0; // Don't want to add buggy geometry
	        // Fix zero-volume interiors so they receive correct lighting
	        if (interiorScale.x === 0)
	            interiorScale.x = 0.0001;
	        if (interiorScale.y === 0)
	            interiorScale.y = 0.0001;
	        if (interiorScale.z === 0)
	            interiorScale.z = 0.0001;
	        interior.setTransform(interiorPosition, interiorRotation, interiorScale);
	        if (hasCollision)
	            this.world.add(interior.body);
	    }
	    async addShape(element) {
	        var _a;
	        let shape;
	        // Add the correct shape based on type
	        let dataBlockLowerCase = (_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	        if (!dataBlockLowerCase) ;
	        else if (["startpad", "startpad_mbg", "startpad_mbp"].includes(dataBlockLowerCase))
	            shape = new StartPad();
	        else if (["endpad", "endpad_mbg", "endpad_mbp"].includes(dataBlockLowerCase))
	            shape = new EndPad(element === this.endPadElement);
	        else if (dataBlockLowerCase === "signfinish")
	            shape = new SignFinish();
	        else if (dataBlockLowerCase.startsWith("signplain"))
	            shape = new SignPlain(element);
	        else if (dataBlockLowerCase.startsWith("gemitem"))
	            shape = new Gem(element), this.totalGems++;
	        else if (dataBlockLowerCase === "superjumpitem")
	            shape = new SuperJump(element);
	        else if (dataBlockLowerCase.startsWith("signcaution"))
	            shape = new SignCaution(element);
	        else if (dataBlockLowerCase === "superbounceitem")
	            shape = new SuperBounce(element);
	        else if (dataBlockLowerCase === "roundbumper")
	            shape = new RoundBumper();
	        else if (dataBlockLowerCase === "trianglebumper")
	            shape = new TriangleBumper();
	        else if (dataBlockLowerCase === "helicopteritem")
	            shape = new Helicopter(element);
	        else if (dataBlockLowerCase === "ductfan")
	            shape = new DuctFan();
	        else if (dataBlockLowerCase === "smallductfan")
	            shape = new SmallDuctFan();
	        else if (dataBlockLowerCase === "antigravityitem")
	            shape = new AntiGravity(element);
	        else if (dataBlockLowerCase === "norespawnantigravityitem")
	            shape = new AntiGravity(element, true);
	        else if (dataBlockLowerCase === "landmine")
	            shape = new LandMine();
	        else if (dataBlockLowerCase === "shockabsorberitem")
	            shape = new ShockAbsorber(element);
	        else if (dataBlockLowerCase === "superspeeditem")
	            shape = new SuperSpeed(element);
	        else if (["timetravelitem", "timepenaltyitem"].includes(dataBlockLowerCase))
	            shape = new TimeTravel(element);
	        else if (dataBlockLowerCase === "tornado")
	            shape = new Tornado();
	        else if (dataBlockLowerCase === "trapdoor")
	            shape = new TrapDoor(element);
	        else if (dataBlockLowerCase === "oilslick")
	            shape = new Oilslick();
	        else if (dataBlockLowerCase === "pushbutton")
	            shape = new PushButton();
	        else if (dataBlockLowerCase.startsWith("sign") || dataBlockLowerCase === "arrow")
	            shape = new Sign(element);
	        else if (dataBlockLowerCase === "magnet")
	            shape = new Magnet();
	        else if (dataBlockLowerCase === "nuke")
	            shape = new Nuke();
	        else if (dataBlockLowerCase === "checkpoint")
	            shape = new Checkpoint();
	        else if (dataBlockLowerCase === "easteregg")
	            shape = new EasterEgg(element);
	        else if (dataBlockLowerCase === "randompowerupitem")
	            shape = new RandomPowerUp(element);
	        else if (["clear", "cloudy", "dusk", "wintry"].includes(dataBlockLowerCase))
	            shape = new Sky(dataBlockLowerCase);
	        else if (/glass_\d+shape/.test(dataBlockLowerCase))
	            shape = new Glass(dataBlockLowerCase);
	        else if (dataBlockLowerCase === "blastitem")
	            shape = new Blast(element);
	        else if (dataBlockLowerCase === "megamarbleitem")
	            shape = new MegaMarble(element);
	        if (!shape)
	            return;
	        this.shapes.push(shape);
	        // This is a bit hacky, but wait a short amount so that all shapes will have been created by the time this codepath continues. This is necessary for correct sharing of data between shapes.
	        await Util.wait(10);
	        await shape.init(this, element);
	        // Set the shape's transform
	        let shapePosition = MisParser.parseVector3(element.position);
	        let shapeRotation = MisParser.parseRotation(element.rotation);
	        let shapeScale = MisParser.parseVector3(element.scale);
	        // Apparently we still do collide with zero-volume shapes
	        if (shapeScale.x === 0)
	            shapeScale.x = 0.0001;
	        if (shapeScale.y === 0)
	            shapeScale.y = 0.0001;
	        if (shapeScale.z === 0)
	            shapeScale.z = 0.0001;
	        shape.setTransform(shapePosition, shapeRotation, shapeScale);
	        this.scene.add(shape.group);
	        for (let body of shape.bodies)
	            this.world.add(body);
	        for (let collider of shape.colliders)
	            this.world.add(collider.body);
	    }
	    async addTrigger(element) {
	        var _a;
	        let trigger;
	        // Create a trigger based on type
	        let dataBlockLowerCase = (_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	        if (dataBlockLowerCase === "outofboundstrigger") {
	            trigger = new OutOfBoundsTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "inboundstrigger") {
	            trigger = new InBoundsTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "helptrigger") {
	            trigger = new HelpTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "teleporttrigger") {
	            trigger = new TeleportTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "destinationtrigger") {
	            trigger = new DestinationTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "checkpointtrigger") {
	            trigger = new CheckpointTrigger(element, this);
	        }
	        if (!trigger)
	            return;
	        this.triggers.push(trigger);
	        this.world.add(trigger.body);
	        await trigger.init();
	    }
	    /** Adds a TSStatic (totally static shape) to the world. */
	    async addTSStatic(element) {
	        let shape = new Shape();
	        let shapeName = element.shapename.toLowerCase();
	        let index = shapeName.indexOf('data/');
	        if (index === -1)
	            return;
	        shape.dtsPath = shapeName.slice(index + 'data/'.length);
	        shape.isTSStatic = true;
	        shape.shareId = 1;
	        if (shapeName.includes('colmesh'))
	            shape.receiveShadows = false; // Special case for colmesh
	        this.shapes.push(shape);
	        await Util.wait(10); // Same hack as for regular shapes
	        try {
	            await shape.init(this, element);
	        }
	        catch (e) {
	            console.error("Error in creating TSStatic, skipping it for now.", e);
	            Util.removeFromArray(this.shapes, shape);
	            return;
	        }
	        shape.setTransform(MisParser.parseVector3(element.position), MisParser.parseRotation(element.rotation), MisParser.parseVector3(element.scale));
	        this.scene.add(shape.group);
	        if (shape.worldScale.x !== 0 && shape.worldScale.y !== 0 && shape.worldScale.z !== 0) {
	            // Only add the shape if it actually has any volume
	            for (let body of shape.bodies)
	                this.world.add(body);
	            for (let collider of shape.colliders)
	                this.world.add(collider.body);
	        }
	    }
	    /** Adds a ParticleEmitterNode to the world. */
	    addParticleEmitterNode(element) {
	        let emitterOptions = particleEmitterMap[element.emitter];
	        if (!emitterOptions)
	            return;
	        this.particles.createEmitter(emitterOptions, MisParser.parseVector3(element.position));
	    }
	    /** Restarts and resets the level. */
	    restart(forceHardRestart) {
	        var _a, _b;
	        if (!forceHardRestart && this.currentCheckpoint && this.replay.mode !== 'playback') {
	            // There's a checkpoint, so load its state instead of restarting the whole level
	            this.loadCheckpointState();
	            return;
	        }
	        let hud = state.menu.hud;
	        hud.setPowerupButtonState(false, true);
	        this.timeState.gameplayClock = 0;
	        if (this.replay && this.replay.version <= 4) {
	            // In older versions, the first tick would immediately advance the entire simulation to a non-zero time instead of correctly keeping it at 0 for a while.
	            this.timeState.currentAttemptTime = 0;
	            this.timeState.tickIndex = 0;
	        }
	        else {
	            // Both of these will become zero after the first tick:
	            this.timeState.currentAttemptTime = -1000 / PHYSICS_TICK_RATE;
	            this.timeState.tickIndex = -1;
	        }
	        this.currentTimeTravelBonus = 0;
	        this.outOfBounds = false;
	        this.lastPhysicsTick = null;
	        this.maxDisplayedTime = 0;
	        this.blastAmount = 0;
	        this.gemCount = 0;
	        this.currentCheckpoint = null;
	        this.currentCheckpointTrigger = null;
	        this.checkpointCollectedGems.clear();
	        this.checkpointHeldPowerUp = null;
	        this.checkpointUp = null;
	        this.checkpointBlast = null;
	        this.restartPressTime = null;
	        this.finishTime = null;
	        let { position: startPosition, euler } = this.getStartPositionAndOrientation();
	        // Place the marble a bit above the start pad position
	        this.marble.body.position.set(startPosition.x, startPosition.y, startPosition.z + 3);
	        this.marble.body.syncShapes();
	        this.marble.group.position.copy(this.marble.body.position);
	        this.marble.group.recomputeTransform();
	        this.marble.reset();
	        this.marble.calculatePredictiveTransforms();
	        // Determine starting camera orientation based on the start pad
	        this.yaw = euler.z + Math.PI / 2;
	        this.pitch = DEFAULT_PITCH;
	        let missionInfo = this.mission.missionInfo;
	        if (missionInfo.starthelptext)
	            state.menu.hud.displayHelp(missionInfo.starthelptext); // Show the start help text
	        for (let shape of this.shapes)
	            shape.reset();
	        for (let interior of this.interiors)
	            interior.reset();
	        for (let trigger of this.triggers)
	            trigger.reset();
	        // Reset the physics
	        this.currentUp.set(0, 0, 1);
	        this.orientationChangeTime = -Infinity;
	        this.oldOrientationQuat = new Quaternion();
	        this.newOrientationQuat = new Quaternion();
	        this.setGravityIntensity(this.defaultGravity);
	        this.deselectPowerUp();
	        hud.setCenterText('none');
	        maybeShowTouchControls();
	        setTouchControlMode((this.replay.mode === 'playback') ? 'replay' : 'normal');
	        (_a = this.timeTravelSound) === null || _a === void 0 ? void 0 : _a.stop();
	        this.timeTravelSound = null;
	        (_b = this.alarmSound) === null || _b === void 0 ? void 0 : _b.stop();
	        this.alarmSound = null;
	        this.replay.init();
	        this.analytics.tries++;
	        // Queue the ready-set-go events
	        this.audio.play('spawn.wav');
	        this.clearSchedule();
	        this.schedule(500, () => {
	            hud.setCenterText('ready');
	            this.audio.play('ready.wav');
	        });
	        this.schedule(2000, () => {
	            hud.setCenterText('set');
	            this.audio.play('set.wav');
	        });
	        this.schedule(GO_TIME, () => {
	            hud.setCenterText('go');
	            this.audio.play('go.wav');
	        });
	        this.schedule(5500, () => {
	            if (!this.outOfBounds)
	                hud.setCenterText('none');
	        });
	    }
	    tryRender() {
	        if (this.stopped)
	            return;
	        requestAnimationFrame(this.tryRender.bind(this));
	        let time = performance.now();
	        if (this.lastFrameTime === null) {
	            this.lastFrameTime = time;
	        }
	        else {
	            let cap = FRAME_RATE_OPTIONS[StorageManager.data.settings.frameRateCap];
	            // When FPS is unlocked in the browser but limited in-game, for some browser frames, the game won't draw anything. This makes the browser think it's okay to slow down the rate of requestAnimationFrame, which is not desirable in this case. Therefore we trick the browser into thinking the GPU is doing something by continuously clearing a 1x1 canvas each frame.
	            if (isFinite(cap))
	                decoyCtx.clearRect(0, 0, 1, 1);
	            // Take care of frame rate limiting:
	            let elapsed = time - this.lastFrameTime;
	            let required = 1000 / cap;
	            if (elapsed < required)
	                return;
	            this.lastFrameTime += required;
	            this.lastFrameTime = Math.max(this.lastFrameTime, time - 2 * required); // To avoid the last frame time from lagging behind
	        }
	        this.render(time);
	    }
	    render(time) {
	        var _a, _b;
	        if (this.stopped)
	            return;
	        this.tick(time);
	        if (this.stopped)
	            return; // Check it again here 'cuz the tick might've changed it
	        let physicsTickLength = 1000 / PHYSICS_TICK_RATE;
	        let completion = Util.clamp((time - this.lastPhysicsTick) / physicsTickLength * PLAYBACK_SPEED, 0, 1);
	        // Set up an intermediate time state for smoother rendering
	        let tempTimeState = {
	            timeSinceLoad: this.timeState.timeSinceLoad + completion * physicsTickLength,
	            currentAttemptTime: this.timeState.currentAttemptTime + completion * physicsTickLength,
	            gameplayClock: (this.currentTimeTravelBonus || this.timeState.currentAttemptTime < GO_TIME) ? this.timeState.gameplayClock : this.timeState.gameplayClock + completion * physicsTickLength,
	            physicsTickCompletion: completion,
	            tickIndex: this.timeState.tickIndex + completion
	        };
	        this.marble.render(tempTimeState);
	        for (let interior of this.interiors)
	            interior.render(tempTimeState);
	        for (let shape of this.shapes)
	            shape.render(tempTimeState);
	        this.particles.render(tempTimeState.timeSinceLoad);
	        this.updateCamera(tempTimeState);
	        this.camera.updateMatrixWorld();
	        // Update the shadow camera
	        (_a = this.scene.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.updateCamera(this.marble.group.position.clone(), -1);
	        // Render the scene
	        this.scene.prepareForRender(this.camera);
	        this.marble.renderReflection();
	        mainRenderer.render(this.scene, this.camera);
	        // Update the overlay
	        for (let overlayShape of this.overlayShapes) {
	            overlayShape.group.position.x = 500; // Make sure the shape is between the near and far planes of the camera
	            overlayShape.render(this.timeState);
	            if (overlayShape.dtsPath.includes("gem")) {
	                overlayShape.group.scale.setScalar(45 / SCALING_RATIO);
	                overlayShape.group.position.y = 25 / SCALING_RATIO;
	                overlayShape.group.position.z = -35 / SCALING_RATIO;
	            }
	            else {
	                overlayShape.group.scale.setScalar(((_b = SHAPE_OVERLAY_SCALES[overlayShape.dtsPath]) !== null && _b !== void 0 ? _b : 40) / SCALING_RATIO);
	                overlayShape.group.position.y = this.overlayCamera.right - 55 / SCALING_RATIO;
	                overlayShape.group.position.z = SHAPE_OVERLAY_OFFSETS[overlayShape.dtsPath] / SCALING_RATIO;
	            }
	            overlayShape.group.recomputeTransform();
	        }
	        // Render the overlay
	        this.overlayCamera.updateMatrixWorld();
	        this.overlayScene.prepareForRender(this.overlayCamera);
	        mainRenderer.render(this.overlayScene, this.overlayCamera, null, false);
	        let hud = state.menu.hud;
	        hud.renderHud(tempTimeState);
	        hud.displayFps();
	    }
	    /** Updates the position of the camera based on marble position and orientation. */
	    updateCamera(timeState) {
	        let marblePosition = this.marble.group.position;
	        let orientationQuat = this.getOrientationQuat(timeState);
	        let up = new Vector3(0, 0, 1).applyQuaternion(orientationQuat);
	        let directionVector = new Vector3(1, 0, 0);
	        // The camera is translated up a bit so it looks "over" the marble
	        let cameraVerticalTranslation = new Vector3(0, 0, 0.3);
	        if (this.replay.mode === 'playback') {
	            let indexLow = Math.max(0, this.replay.currentTickIndex - 1);
	            let indexHigh = this.replay.currentTickIndex;
	            // Smoothly interpolate pitch and yaw between the last two keyframes
	            this.pitch = Util.lerp(this.replay.cameraOrientations[indexLow].pitch, this.replay.cameraOrientations[indexHigh].pitch, timeState.physicsTickCompletion);
	            this.pitch = Math.max(-Math.PI / 2 + Math.PI / 4, Math.min(Math.PI / 2 - 0.0001, this.pitch)); // This bounds thing might have gotten inaccurate in the conversion from float64 to float32, so do it here again
	            this.yaw = Util.lerp(this.replay.cameraOrientations[indexLow].yaw, this.replay.cameraOrientations[indexHigh].yaw, timeState.physicsTickCompletion);
	        }
	        if (this.finishTime) {
	            // Make the camera spin around slowly
	            this.pitch = Util.lerp(this.finishPitch, DEFAULT_PITCH, Util.clamp((timeState.currentAttemptTime - this.finishTime.currentAttemptTime) / 333, 0, 1));
	            this.yaw = this.finishYaw - (timeState.currentAttemptTime - this.finishTime.currentAttemptTime) / 1000 * 0.6;
	        }
	        if (!this.outOfBounds) {
	            directionVector.applyAxisAngle(new Vector3(0, 1, 0), this.pitch);
	            directionVector.applyAxisAngle(new Vector3(0, 0, 1), this.yaw);
	            directionVector.applyQuaternion(orientationQuat);
	            cameraVerticalTranslation.applyAxisAngle(new Vector3(0, 1, 0), this.pitch);
	            cameraVerticalTranslation.applyAxisAngle(new Vector3(0, 0, 1), this.yaw);
	            cameraVerticalTranslation.applyQuaternion(orientationQuat);
	            this.camera.up = up;
	            this.camera.position.copy(marblePosition).sub(directionVector.clone().multiplyScalar(2.5));
	            this.camera.lookAt(marblePosition);
	            this.camera.position.add(cameraVerticalTranslation);
	            // Handle wall intersections:
	            const closeness = 0.1;
	            let rayCastOrigin = marblePosition;
	            let processedShapes = new Set();
	            for (let i = 0; i < 3; i++) {
	                // Shoot rays from the marble to the postiion of the camera
	                let rayCastDirection = this.camera.position.clone().sub(rayCastOrigin);
	                rayCastDirection.addScaledVector(rayCastDirection.clone().normalize(), 2);
	                let length = rayCastDirection.length();
	                let hits = this.world.castRay(rayCastOrigin, rayCastDirection.normalize(), length);
	                let firstHit = hits.find(x => x.shape !== this.marble.shape && !processedShapes.has(x.shape));
	                if (firstHit) {
	                    processedShapes.add(firstHit.shape);
	                    // Construct a plane at the point of ray impact based on the normal
	                    let plane = new Plane();
	                    let normal = firstHit.normal;
	                    let position = firstHit.point;
	                    plane.setFromNormalAndCoplanarPoint(normal, position);
	                    // Project the camera position onto the plane
	                    let target = new Vector3();
	                    let projected = plane.projectPoint(this.camera.position, target);
	                    // If the camera is too far from the plane anyway, break
	                    let dist = plane.distanceToPoint(this.camera.position);
	                    if (dist >= closeness)
	                        break;
	                    // Go the projected point and look at the marble
	                    this.camera.position.copy(projected).addScaledVector(normal, closeness);
	                    Util.cameraLookAtDirect(this.camera, marblePosition);
	                    let rotationAxis = new Vector3(1, 0, 0);
	                    rotationAxis.applyQuaternion(this.camera.orientation);
	                    let theta = Math.atan(0.3 / 2.5); // 0.3 is the vertical translation, 2.5 the distance away from the marble.
	                    // Rotate the camera back upwards such that the marble is in the same visual location on screen as before
	                    let rot = new Quaternion().setFromAxisAngle(rotationAxis, theta);
	                    this.camera.orientation.premultiply(rot);
	                    continue;
	                }
	                break;
	            }
	            this.lastVerticalTranslation = cameraVerticalTranslation;
	        }
	        else {
	            // Simply look at the marble
	            this.camera.position.copy(this.oobCameraPosition);
	            this.camera.position.sub(this.lastVerticalTranslation);
	            this.camera.lookAt(marblePosition);
	            this.camera.position.add(this.lastVerticalTranslation);
	        }
	    }
	    tick(time) {
	        var _a, _b;
	        if (this.stopped)
	            return;
	        if (this.paused)
	            return;
	        if (time === undefined)
	            time = performance.now();
	        let playReplay = this.replay.mode === 'playback';
	        if (!playReplay && !state.menu.finishScreen.showing && (isPressed('use') || this.useQueued) && getPressedFlag('use')) {
	            if (this.outOfBounds && !this.finishTime) {
	                // Skip the out of bounds "animation" and restart immediately
	                this.restart(false);
	                return;
	            }
	        }
	        state.menu.finishScreen.handleGamepadInput();
	        // Handle pressing of the gamepad pause button
	        if (isPressed('pause') && getPressedFlag('pause')) {
	            resetPressedFlag('pause');
	            resetPressedFlag('jump');
	            resetPressedFlag('use');
	            resetPressedFlag('restart');
	            this.pause();
	        }
	        let forcePhysicsTick = false;
	        if (this.lastPhysicsTick === null) {
	            // If there hasn't been a physics tick yet, ensure there is one now
	            this.lastPhysicsTick = time - 1000 / PHYSICS_TICK_RATE / PLAYBACK_SPEED;
	            forcePhysicsTick = true;
	        }
	        /** Time since the last physics tick */
	        let elapsed = time - this.lastPhysicsTick;
	        elapsed *= PLAYBACK_SPEED;
	        if (elapsed >= 1000) {
	            elapsed = 1000;
	            this.lastPhysicsTick = time - 1000;
	        }
	        let tickDone = false;
	        // Make sure to execute the correct amount of ticks
	        while (elapsed >= 1000 / PHYSICS_TICK_RATE || forcePhysicsTick) {
	            let prevGameplayClock = this.timeState.gameplayClock;
	            // Update gameplay clock, taking into account the Time Travel state
	            if (this.timeState.currentAttemptTime >= GO_TIME) {
	                if (this.currentTimeTravelBonus > 0) {
	                    // Subtract remaining time travel time
	                    this.currentTimeTravelBonus -= 1000 / PHYSICS_TICK_RATE;
	                    if (!this.timeTravelSound) {
	                        this.timeTravelSound = this.audio.createAudioSource('timetravelactive.wav');
	                        this.timeTravelSound.setLoop(true);
	                        this.timeTravelSound.play();
	                    }
	                }
	                else {
	                    // Increase the gameplay time
	                    this.timeState.gameplayClock += 1000 / PHYSICS_TICK_RATE;
	                    (_a = this.timeTravelSound) === null || _a === void 0 ? void 0 : _a.stop();
	                    this.timeTravelSound = null;
	                }
	                if (this.currentTimeTravelBonus < 0) {
	                    // If we slightly undershot the zero mark of the remaining time travel bonus, add the "lost time" back onto the gameplay clock:
	                    this.timeState.gameplayClock += -this.currentTimeTravelBonus;
	                    this.currentTimeTravelBonus = 0;
	                }
	            }
	            this.timeState.timeSinceLoad += 1000 / PHYSICS_TICK_RATE;
	            this.timeState.currentAttemptTime += 1000 / PHYSICS_TICK_RATE;
	            this.timeState.tickIndex++;
	            this.lastPhysicsTick += 1000 / PHYSICS_TICK_RATE / PLAYBACK_SPEED;
	            elapsed -= 1000 / PHYSICS_TICK_RATE;
	            forcePhysicsTick = false;
	            this.tickSchedule(this.timeState.currentAttemptTime);
	            if (this.offline)
	                this.audio.currentTimeOverride = this.timeState.currentAttemptTime / 1000;
	            if (this.mission.hasBlast && this.blastAmount < 1)
	                this.blastAmount = Util.clamp(this.blastAmount + 1000 / BLAST_CHARGE_TIME / PHYSICS_TICK_RATE, 0, 1);
	            for (let interior of this.interiors)
	                interior.tick(this.timeState);
	            for (let trigger of this.triggers)
	                trigger.tick(this.timeState);
	            for (let shape of this.shapes)
	                if (!shape.isTSStatic)
	                    shape.tick(this.timeState);
	            this.marble.tick(this.timeState);
	            if (!playReplay) {
	                let gravityBefore = this.world.gravity.clone();
	                if (this.finishTime)
	                    this.world.gravity.setScalar(0);
	                this.world.step(1 / PHYSICS_TICK_RATE);
	                this.world.gravity.copy(gravityBefore);
	            }
	            this.jumpQueued = false;
	            this.useQueued = false;
	            this.blastQueued = false;
	            let yawChange = 0.0;
	            let pitchChange = 0.0;
	            let freeLook = StorageManager.data.settings.alwaysFreeLook || isPressed('freeLook');
	            let amount = Util.lerp(1, 6, StorageManager.data.settings.keyboardSensitivity);
	            if (isPressed('cameraLeft'))
	                yawChange += amount;
	            if (isPressed('cameraRight'))
	                yawChange -= amount;
	            if (isPressed('cameraUp'))
	                pitchChange -= amount;
	            if (isPressed('cameraDown'))
	                pitchChange += amount;
	            yawChange -= gamepadAxes.cameraX * Util.lerp(0.5, 10, StorageManager.data.settings.mouseSensitivity);
	            if (freeLook)
	                pitchChange += gamepadAxes.cameraY * Util.lerp(0.5, 10, StorageManager.data.settings.mouseSensitivity);
	            this.yaw += yawChange / PHYSICS_TICK_RATE;
	            this.pitch += pitchChange / PHYSICS_TICK_RATE;
	            this.particles.tick();
	            tickDone = true;
	            // Handle alarm warnings (that the user is about to exceed the par time)
	            if (this.timeState.currentAttemptTime >= GO_TIME && isFinite(this.mission.qualifyTime) && state.modification === 'platinum' && !this.finishTime) {
	                let alarmStart = this.mission.computeAlarmStartTime();
	                if (prevGameplayClock <= alarmStart && this.timeState.gameplayClock >= alarmStart && !this.alarmSound) {
	                    // Start the alarm
	                    this.alarmSound = this.audio.createAudioSource('alarm.wav');
	                    this.alarmSound.setLoop(true);
	                    this.alarmSound.play();
	                    state.menu.hud.displayHelp(`You have ${(this.mission.qualifyTime - alarmStart) / 1000} seconds remaining.`, true);
	                }
	                if (prevGameplayClock < this.mission.qualifyTime && this.timeState.gameplayClock >= this.mission.qualifyTime) {
	                    // Stop the alarm
	                    (_b = this.alarmSound) === null || _b === void 0 ? void 0 : _b.stop();
	                    this.alarmSound = null;
	                    state.menu.hud.displayHelp("The clock has passed the Par Time.", true);
	                    this.audio.play('alarm_timeout.wav');
	                }
	            }
	            // Record or playback the replay
	            if (!playReplay) {
	                this.replay.record();
	            }
	            else {
	                this.replay.playBack();
	                if (this.replay.isPlaybackComplete()) {
	                    this.stopAndExit();
	                    return;
	                }
	            }
	        }
	        this.audio.updatePositionalAudio(this.timeState, this.camera.position, this.yaw);
	        this.pitch = Math.max(-Math.PI / 2 + Math.PI / 4, Math.min(Math.PI / 2 - 0.0001, this.pitch)); // The player can't look straight up
	        if (tickDone)
	            this.marble.calculatePredictiveTransforms();
	        // Handle pressing of the restart button
	        if (!this.finishTime && isPressed('restart') && !this.pressingRestart) {
	            this.restart(false);
	            if (this.currentCheckpoint)
	                this.restartPressTime = performance.now();
	            this.pressingRestart = true;
	        }
	        else if (!isPressed('restart')) {
	            this.pressingRestart = false;
	        }
	        // Holding down the restart button for 1 second will force a hard restart
	        if (!this.finishTime && isPressed('restart') && this.restartPressTime !== null) {
	            if (this.restartPressTime !== null && performance.now() - this.restartPressTime >= 1000)
	                this.restart(true);
	        }
	    }
	    /** Get the current interpolated orientation quaternion. */
	    getOrientationQuat(time) {
	        let completion = Util.clamp((time.currentAttemptTime - this.orientationChangeTime) / 300, 0, 1);
	        return this.oldOrientationQuat.clone().slerp(this.newOrientationQuat, completion).normalize();
	    }
	    /** Sets the current up vector and gravity with it. */
	    setUp(newUp, instant = false) {
	        let time = this.timeState;
	        newUp.normalize(); // We never know 👀
	        this.currentUp.copy(newUp);
	        let gravityStrength = this.world.gravity.length();
	        this.world.gravity.copy(newUp).multiplyScalar(-1 * gravityStrength);
	        let currentQuat = this.getOrientationQuat(time);
	        let oldUp = new Vector3(0, 0, 1);
	        oldUp.applyQuaternion(currentQuat).normalize();
	        let quatChange = new Quaternion();
	        let dot = newUp.dot(oldUp);
	        if (dot <= -(1 - 1e-15) && !(this.replay.version < 3)) { // If the old and new up are exact opposites, there are infinitely many possible rotations we could do. So choose the one that maintains the current look vector the best. Replay check so we don't break old stuff.
	            let lookVector = new Vector3(0, 0, 1).applyQuaternion(this.camera.orientation);
	            let intermediateVector = oldUp.clone().cross(lookVector).normalize();
	            // First rotation to the intermediate vector, then rotate from there to the new up
	            quatChange.setFromUnitVectors(oldUp, intermediateVector);
	            quatChange.premultiply(new Quaternion().setFromUnitVectors(intermediateVector, newUp));
	        }
	        else {
	            // Instead of calculating the new quat from nothing, calculate it from the last one to guarantee the shortest possible rotation.
	            quatChange.setFromUnitVectors(oldUp, newUp);
	        }
	        this.newOrientationQuat = quatChange.multiply(currentQuat).normalize();
	        this.oldOrientationQuat = currentQuat;
	        this.orientationChangeTime = instant ? -Infinity : time.currentAttemptTime;
	    }
	    /** Gets the position and orientation of the player spawn point. */
	    getStartPositionAndOrientation() {
	        // The player is spawned at the last start pad in the mission file.
	        let startPad = Util.findLast(this.shapes, (shape) => shape instanceof StartPad);
	        let position;
	        let euler = new Euler();
	        if (startPad) {
	            // If there's a start pad, start there
	            position = startPad.worldPosition;
	            euler.setFromQuaternion(startPad.worldOrientation, "ZXY");
	        }
	        else {
	            // Search for spawn points used for multiplayer
	            let spawnPoints = this.mission.allElements.find(x => x._name === "SpawnPoints");
	            if (spawnPoints) {
	                let first = spawnPoints.elements[0];
	                position = MisParser.parseVector3(first.position);
	            }
	            else {
	                // If there isn't anything, start at this weird point
	                position = new Vector3(0, 0, 300);
	            }
	        }
	        return { position, euler };
	    }
	    setGravityIntensity(intensity) {
	        let gravityVector = this.currentUp.clone().multiplyScalar(-1 * intensity);
	        this.world.gravity.copy(gravityVector);
	    }
	    onResize(width, height, hudPixelRatio) {
	        if (!this.camera || !this.overlayCamera)
	            return;
	        this.camera.aspect = width / height;
	        this.camera.updateProjectionMatrix();
	        this.overlayCamera.left = 0;
	        this.overlayCamera.right = width;
	        this.overlayCamera.top = 0;
	        this.overlayCamera.bottom = height;
	        this.overlayCamera.updateProjectionMatrix();
	        state.menu.hud.setSize(width, height, hudPixelRatio);
	    }
	    onMouseMove(e) {
	        if (!this.started || !document.pointerLockElement || this.finishTime || this.paused || this.replay.mode === 'playback')
	            return;
	        let totalDistance = Math.hypot(e.movementX, e.movementY);
	        // Strangely enough, Chrome really bugs out sometimes and flings the mouse into a random direction quickly. We try to catch that here and ignore the mouse movement if we detect it.
	        if (totalDistance > 350 && this.previousMouseMovementDistance * 4 < totalDistance) {
	            this.previousMouseMovementDistance *= 1.5; // Make the condition harder to hit the next time
	            return;
	        }
	        this.previousMouseMovementDistance = totalDistance;
	        let factor = Util.lerp(1 / 2500, 1 / 100, StorageManager.data.settings.mouseSensitivity);
	        let xFactor = (StorageManager.data.settings.invertMouse & 0b01) ? -1 : 1;
	        let yFactor = (StorageManager.data.settings.invertMouse & 0b10) ? -1 : 1;
	        let freeLook = StorageManager.data.settings.alwaysFreeLook || isPressed('freeLook');
	        if (freeLook)
	            this.pitch += e.movementY * factor * yFactor;
	        this.yaw -= e.movementX * factor * xFactor;
	    }
	    pickUpPowerUp(powerUp, playPickUpSound = true) {
	        if (!powerUp)
	            return false;
	        if (this.heldPowerUp && powerUp.constructor === this.heldPowerUp.constructor)
	            return false;
	        this.heldPowerUp = powerUp;
	        state.menu.hud.setPowerupButtonState(true);
	        for (let overlayShape of this.overlayShapes) {
	            if (overlayShape.dtsPath.includes("gem"))
	                continue;
	            // Show the corresponding icon in the HUD
	            overlayShape.setOpacity(Number(overlayShape.dtsPath === powerUp.dtsPath));
	        }
	        if (playPickUpSound)
	            this.audio.play(powerUp.sounds[0]);
	        return true;
	    }
	    deselectPowerUp() {
	        if (!this.heldPowerUp) {
	            state.menu.hud.setPowerupButtonState(false);
	            return;
	        }
	        this.heldPowerUp = null;
	        state.menu.hud.setPowerupButtonState(false);
	        for (let overlayShape of this.overlayShapes) {
	            if (overlayShape.dtsPath.includes("gem"))
	                continue;
	            overlayShape.setOpacity(0);
	        }
	    }
	    pickUpGem(t) {
	        this.gemCount++;
	        let string;
	        let gemWord = (state.modification === 'gold') ? 'gem' : 'diamond';
	        // Show a notification (and play a sound) based on the gems remaining
	        if (this.gemCount === this.totalGems) {
	            string = `You have all the ${gemWord}s, head for the finish!`;
	            this.audio.play('gotallgems.wav');
	            // Some levels with this package end immediately upon collection of all gems
	            if (this.mission.misFile.activatedPackages.includes('endWithTheGems')) {
	                this.touchFinish(t);
	            }
	        }
	        else {
	            string = `You picked up a ${gemWord}${state.modification === 'gold' ? '.' : '!'}  `;
	            let remaining = this.totalGems - this.gemCount;
	            if (remaining === 1) {
	                string += `Only one ${gemWord} to go!`;
	            }
	            else {
	                string += `${remaining} ${gemWord}s to go!`;
	            }
	            this.audio.play('gotgem.wav');
	        }
	        state.menu.hud.displayAlert(string);
	    }
	    addTimeTravelBonus(bonus, timeToRevert) {
	        if (this.currentTimeTravelBonus === 0) {
	            this.timeState.gameplayClock -= timeToRevert;
	            if (this.timeState.gameplayClock < 0)
	                this.timeState.gameplayClock = 0;
	            bonus -= timeToRevert;
	        }
	        this.currentTimeTravelBonus += bonus;
	    }
	    /** Triggers the out-of-bounds state. */
	    goOutOfBounds() {
	        if (this.outOfBounds || this.finishTime)
	            return;
	        state.menu.hud.setPowerupButtonState(true);
	        this.updateCamera(this.timeState); // Update the camera at the point of OOB-ing
	        this.outOfBounds = true;
	        this.outOfBoundsTime = Util.jsonClone(this.timeState);
	        this.oobCameraPosition = this.camera.position.clone();
	        state.menu.hud.setCenterText('outofbounds');
	        this.audio.play('whoosh.wav');
	        this.analytics.outOfBoundsCount++;
	        if (this.replay.mode !== 'playback')
	            this.schedule(this.timeState.currentAttemptTime + 2000, () => this.restart(false), 'oobRestart');
	    }
	    /** Sets a new active checkpoint. */
	    saveCheckpointState(shape, trigger) {
	        var _a, _b;
	        if (this.currentCheckpoint === shape)
	            return;
	        if ((_a = this.currentCheckpoint) === null || _a === void 0 ? void 0 : _a.worldPosition.equals(shape.worldPosition))
	            return; // Some levels have identical overlapping checkpoints, which can cause an infinite checkpointing loop.
	        let disableOob = ((_b = shape.srcElement) === null || _b === void 0 ? void 0 : _b.disableOob) || (trigger === null || trigger === void 0 ? void 0 : trigger.element.disableOob);
	        if (MisParser.parseBoolean(disableOob) && this.outOfBounds)
	            return; // The checkpoint is configured to not work when the player is already OOB
	        this.currentCheckpoint = shape;
	        this.currentCheckpointTrigger = trigger;
	        this.checkpointCollectedGems.clear();
	        this.checkpointUp = this.currentUp.clone();
	        this.checkpointBlast = this.blastAmount;
	        // Remember all gems that were collected up to this point
	        for (let shape of this.shapes) {
	            if (!(shape instanceof Gem))
	                continue;
	            if (shape.pickedUp)
	                this.checkpointCollectedGems.add(shape);
	        }
	        this.checkpointHeldPowerUp = this.heldPowerUp;
	        state.menu.hud.displayAlert("Checkpoint reached!");
	        this.audio.play('checkpoint.wav');
	    }
	    /** Resets to the last stored checkpoint state. */
	    loadCheckpointState() {
	        var _a, _b, _c, _d, _e, _f;
	        if (!this.currentCheckpoint)
	            return;
	        let marble = this.marble;
	        // Quite note: Checkpoints have slightly different behavior in Ultra, that's why there's some checks
	        let gravityField = ((_a = this.currentCheckpoint.srcElement) === null || _a === void 0 ? void 0 : _a.gravity) || ((_b = this.currentCheckpointTrigger) === null || _b === void 0 ? void 0 : _b.element.gravity);
	        if (MisParser.parseBoolean(gravityField) || this.mission.modification === 'ultra') {
	            // In this case, we set the gravity to the relative "up" vector of the checkpoint shape.
	            let up = new Vector3(0, 0, 1);
	            up.applyQuaternion(this.currentCheckpoint.worldOrientation);
	            this.setUp(up, true);
	        }
	        else {
	            // Otherwise, we restore gravity to what was stored.
	            this.setUp(this.checkpointUp, true);
	        }
	        // Determine where to spawn the marble
	        let offset = new Vector3();
	        let add = ((_c = this.currentCheckpoint.srcElement) === null || _c === void 0 ? void 0 : _c.add) || ((_d = this.currentCheckpointTrigger) === null || _d === void 0 ? void 0 : _d.element.add);
	        if (add)
	            offset.add(MisParser.parseVector3(add));
	        let sub = ((_e = this.currentCheckpoint.srcElement) === null || _e === void 0 ? void 0 : _e.sub) || ((_f = this.currentCheckpointTrigger) === null || _f === void 0 ? void 0 : _f.element.sub);
	        if (sub)
	            offset.sub(MisParser.parseVector3(sub));
	        if (!add && !sub) {
	            offset.z = 3; // Defaults to (0, 0, 3)
	            if (this.mission.modification === 'ultra')
	                offset.applyQuaternion(this.currentCheckpoint.worldOrientation); // weird <3
	        }
	        marble.body.position.copy(this.currentCheckpoint.worldPosition).add(offset);
	        marble.body.linearVelocity.setScalar(0);
	        marble.body.angularVelocity.setScalar(0);
	        marble.calculatePredictiveTransforms();
	        // Set camera orienation
	        let euler = new Euler();
	        euler.setFromQuaternion(this.currentCheckpoint.worldOrientation, "ZXY");
	        this.yaw = euler.z + Math.PI / 2;
	        this.pitch = DEFAULT_PITCH;
	        // Restore gem states
	        for (let shape of this.shapes) {
	            if (!(shape instanceof Gem))
	                continue;
	            if (shape.pickedUp && !this.checkpointCollectedGems.has(shape)) {
	                shape.reset();
	                this.gemCount--;
	            }
	        }
	        state.menu.hud.setCenterText('none');
	        // Turn all of these off
	        marble.superBounceEnableTime = -Infinity;
	        marble.shockAbsorberEnableTime = -Infinity;
	        marble.helicopterEnableTime = -Infinity;
	        marble.megaMarbleEnableTime = -Infinity;
	        this.clearSchedule();
	        this.outOfBounds = false;
	        this.blastAmount = this.checkpointBlast;
	        this.finishTime = null; // For those very, very rare cases where the player touched the finish while OOB, but not fast enough, so they get respawned at the checkpoint and we need to remove the "finish lock".
	        this.deselectPowerUp(); // Always deselect first
	        // Wait a bit to select the powerup to prevent immediately using it incase the user skipped the OOB screen by clicking
	        if (this.checkpointHeldPowerUp)
	            this.schedule(this.timeState.currentAttemptTime + 500, () => this.pickUpPowerUp(this.checkpointHeldPowerUp, false));
	        this.audio.play('spawn.wav');
	        this.replay.recordCheckpointRespawn();
	    }
	    touchFinish(completionOfImpact) {
	        var _a;
	        if (this.finishTime !== null)
	            return;
	        this.replay.recordTouchFinish();
	        if (this.gemCount < this.totalGems) {
	            this.audio.play('missinggems.wav');
	            state.menu.hud.displayAlert((state.modification === 'gold') ? "You can't finish without all the gems!!" : "You may not finish without all the diamonds!");
	        }
	        else {
	            if (completionOfImpact === undefined)
	                completionOfImpact = 1;
	            let toSubtract = (1 - completionOfImpact) * 1000 / PHYSICS_TICK_RATE;
	            this.finishTime = Util.jsonClone(this.timeState);
	            // Compute the precise finish time here
	            this.finishTime.timeSinceLoad -= toSubtract;
	            this.finishTime.currentAttemptTime -= toSubtract;
	            if (this.currentTimeTravelBonus === 0)
	                this.finishTime.gameplayClock -= toSubtract;
	            this.finishTime.gameplayClock = Util.clamp(this.finishTime.gameplayClock, 0, MAX_TIME); // Apply the time cap
	            this.finishTime.physicsTickCompletion = completionOfImpact;
	            this.currentTimeTravelBonus = 0;
	            (_a = this.alarmSound) === null || _a === void 0 ? void 0 : _a.stop();
	            if (this.replay.mode === 'playback')
	                this.finishTime = this.replay.finishTime;
	            this.finishYaw = this.yaw;
	            this.finishPitch = this.pitch;
	            let endPad = Util.findLast(this.shapes, (shape) => shape instanceof EndPad);
	            endPad === null || endPad === void 0 ? void 0 : endPad.spawnFirework(this.timeState); // EndPad *might* not exist, in that case no fireworks lol
	            state.menu.hud.displayAlert("Congratulations! You've finished!");
	            // Check if the player is OOB, but still allow finishing with less than half a second of having been OOB
	            if (this.outOfBounds && this.timeState.currentAttemptTime - this.outOfBoundsTime.currentAttemptTime >= 500)
	                return;
	            // When we reach this point, the player has actually successfully completed the level.
	            this.clearScheduleId('oobRestart'); // Make sure we don't restart the level now
	            // Schedule the finish screen to be shown
	            if (this.replay.mode !== 'playback')
	                this.schedule(this.timeState.currentAttemptTime + 2000, () => {
	                    var _a;
	                    // Show the finish screen
	                    (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	                    state.menu.finishScreen.show();
	                    hideTouchControls();
	                    resetPressedFlag('use');
	                    resetPressedFlag('jump');
	                    resetPressedFlag('restart');
	                });
	            this.analytics.finishes++;
	        }
	    }
	    /** Pauses the level. */
	    pause() {
	        var _a;
	        if (this.paused || (state.level.finishTime && state.level.replay.mode === 'record'))
	            return;
	        this.paused = true;
	        this.pausedAt = Date.now();
	        (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	        releaseAllButtons(); // Safety measure to prevent keys from getting stuck
	        state.menu.pauseScreen.show();
	        hideTouchControls();
	    }
	    /** Unpauses the level. */
	    unpause() {
	        this.paused = false;
	        if (!Util.isTouchDevice)
	            Util.requestPointerLock();
	        state.menu.pauseScreen.hide();
	        this.lastPhysicsTick = performance.now();
	        maybeShowTouchControls();
	        if (this.pausedAt !== null) {
	            this.analytics.timePaused += Date.now() - this.pausedAt;
	            this.pausedAt = null;
	        }
	    }
	    /** Ends the level irreversibly. */
	    stop() {
	        var _a, _b, _c, _d, _e, _f, _g;
	        this.stopped = true;
	        clearInterval(this.tickInterval);
	        this.dispose();
	        CollisionDetection.clearReferences();
	        this.music.stop();
	        for (let interior of this.interiors) {
	            if (interior instanceof PathedInterior)
	                (_a = interior.soundSource) === null || _a === void 0 ? void 0 : _a.stop();
	        }
	        for (let shape of this.shapes) {
	            if (shape instanceof Tornado || shape instanceof DuctFan)
	                (_b = shape.soundSource) === null || _b === void 0 ? void 0 : _b.stop();
	        }
	        (_c = this.marble.rollingSound) === null || _c === void 0 ? void 0 : _c.stop();
	        (_d = this.marble.slidingSound) === null || _d === void 0 ? void 0 : _d.stop();
	        (_e = this.marble.helicopterSound) === null || _e === void 0 ? void 0 : _e.stop();
	        (_f = this.marble.shockAbsorberSound) === null || _f === void 0 ? void 0 : _f.stop();
	        (_g = this.marble.superBounceSound) === null || _g === void 0 ? void 0 : _g.stop();
	        this.audio.stopAllAudio();
	    }
	    /** Stops and destroys the current level and returns back to the menu. */
	    stopAndExit() {
	        var _a;
	        this.stop();
	        state.level = null;
	        mainCanvas.classList.add('hidden');
	        state.menu.pauseScreen.hide();
	        state.menu.levelSelect.show();
	        state.menu.levelSelect.displayBestTimes(); // Potentially update best times having changed
	        state.menu.finishScreen.hide();
	        state.menu.hideGameUi();
	        state.menu.show();
	        (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	        if (this.replay.mode !== 'playback') {
	            // Send some analytics to the server
	            if (this.pausedAt !== null)
	                this.analytics.timePaused += Date.now() - this.pausedAt;
	            this.analytics.endTime = Date.now();
	            ResourceManager.retryFetch('/api/statistics', {
	                method: 'POST',
	                headers: {
	                    'Content-Type': 'text/plain'
	                },
	                body: btoa(JSON.stringify(this.analytics))
	            });
	        }
	    }
	    /** Returns how much percent the level has finished loading. */
	    getLoadingCompletion() {
	        return this.loadingState.total ? this.loadingState.loaded / this.loadingState.total : 0;
	    }
	    /** Disposes the GPU assets used by the level. */
	    dispose() {
	        this.scene.dispose();
	        this.marble.dispose();
	        mainRenderer.cleanUp();
	    }
	}

	/** Stores everything necessary for a correct replay of a playthrough. Instead of relying on replaying player inputs, the replay simply stores all necessary state. */
	class Replay {
	    constructor(level) {
	        this.version = 5;
	        this.mode = 'record';
	        /** If writing to the replay is still permitted. */
	        this.canStore = true;
	        /** Replays get invalidated if they don't end in a successful finish. */
	        this.isInvalid = false;
	        /** The position of the marble at each physics tick. */
	        this.marblePositions = [];
	        /** The orientation of the marble at each physics tick. */
	        this.marbleOrientations = [];
	        /** The linear velocity of the marble at each physics tick. */
	        this.marbleLinearVelocities = [];
	        /** The angular velocity of the marble at each physics tick. */
	        this.marbleAngularVelocities = [];
	        /** Stores the times the marble was inside a shape/trigger. */
	        this.marbleInside = [];
	        /** Stores the times the marble entered a shape/trigger. */
	        this.marbleEnter = [];
	        /** Stores the times the marble left a shape/trigger. */
	        this.marbleLeave = [];
	        /** Stores the times the marble collided with a shape. */
	        this.marbleContact = [];
	        /** Stores power-up usage. */
	        this.uses = [];
	        /** Stores blast usage. */
	        this.blasts = [];
	        /** Camera orientation for each physics tick. */
	        this.cameraOrientations = [];
	        /** How much to revert time for each time travel. */
	        this.timeTravelTimeToRevert = new Map();
	        /** When the finish area was hit. */
	        this.touchFinishTickIndices = [];
	        this.finishTime = null;
	        /** In order to replay trapdoors correctly, their completion state upon attempt start must be reconstructed properly. */
	        this.trapdoorStartValues = [];
	        /** In order to replay mines correctly, their visibility state upon attempt start must be reconstructed properly. */
	        this.landmineStartValues = [];
	        /** In order to replay push buttons correctly, their completion state upon attempt start must be reconstructed properly. */
	        this.pushButtonStartValues = [];
	        /** In order to replay nukes correctly, their visibility state upon attempt start must be reconstructed properly. */
	        this.nukeStartValues = [];
	        /** The gain of the rolling sound for each physics tick. */
	        this.rollingSoundGain = [];
	        /** The playback rate of the rolling sound for each physics tick. */
	        this.rollingSoundPlaybackRate = [];
	        /** The gain of the sliding sound for each physics tick. */
	        this.slidingSoundGain = [];
	        /** When the jump sound played. */
	        this.jumpSoundTimes = [];
	        /** When bounces happened. */
	        this.bounceTimes = [];
	        /** Which powerups were selected at random. */
	        this.randomPowerUpChoices = new Map();
	        this.checkpointRespawns = [];
	        this.currentJumpSoundTime = 0;
	        this.currentBounceTime = 0;
	        if (level) {
	            this.level = level;
	            this.missionPath = level.mission.path;
	        }
	    }
	    /** The current tick index to write to / read from. */
	    get currentTickIndex() {
	        return Math.max(this.level.timeState.tickIndex, 0);
	    }
	    /** Inits the replay's values. */
	    init() {
	        if (this.mode === 'record') {
	            // Reset all values
	            this.canStore = true;
	            this.isInvalid = false;
	            this.marblePositions.length = 0;
	            this.marbleOrientations.length = 0;
	            this.marbleLinearVelocities.length = 0;
	            this.marbleAngularVelocities.length = 0;
	            this.marbleInside.length = 0;
	            this.marbleEnter.length = 0;
	            this.marbleLeave.length = 0;
	            this.marbleContact.length = 0;
	            this.uses.length = 0;
	            this.blasts.length = 0;
	            this.cameraOrientations.length = 0;
	            this.timeTravelTimeToRevert.clear();
	            this.touchFinishTickIndices.length = 0;
	            this.finishTime = null;
	            this.trapdoorStartValues.length = 0;
	            this.landmineStartValues.length = 0;
	            this.pushButtonStartValues.length = 0;
	            this.nukeStartValues.length = 0;
	            this.rollingSoundGain.length = 0;
	            this.rollingSoundPlaybackRate.length = 0;
	            this.slidingSoundGain.length = 0;
	            this.jumpSoundTimes.length = 0;
	            this.bounceTimes.length = 0;
	            this.randomPowerUpChoices.clear();
	            this.checkpointRespawns.length = 0;
	            // Remember trapdoor, mine and push button states
	            for (let shape of this.level.shapes) {
	                if (shape instanceof TrapDoor) {
	                    this.trapdoorStartValues.push({
	                        id: shape.id,
	                        lastContactTime: shape.lastContactTime,
	                        lastDirection: shape.lastDirection,
	                        lastCompletion: shape.lastCompletion
	                    });
	                }
	                else if (shape instanceof LandMine) {
	                    this.landmineStartValues.push({
	                        id: shape.id,
	                        disappearTime: shape.disappearTime
	                    });
	                }
	                else if (shape instanceof PushButton) {
	                    this.pushButtonStartValues.push({
	                        id: shape.id,
	                        lastContactTime: shape.lastContactTime
	                    });
	                }
	                else if (shape instanceof Nuke) {
	                    this.nukeStartValues.push({
	                        id: shape.id,
	                        disappearTime: shape.disappearTime
	                    });
	                }
	            }
	            this.timeSinceLoad = this.level.timeState.timeSinceLoad;
	        }
	        else {
	            // Reconstruct trapdoor, mine and push button states
	            for (let shape of this.level.shapes) {
	                if (shape instanceof TrapDoor) {
	                    let startValues = this.trapdoorStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    // This is quite stupid. lastContactTime, of course, is never null, but it might be -Infinity, in which case JSON.stringify turns it to null. We're catching that here.
	                    if (startValues.lastContactTime === null)
	                        startValues.lastContactTime = -Infinity;
	                    shape.lastContactTime = startValues.lastContactTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                    shape.lastDirection = startValues.lastDirection;
	                    shape.lastCompletion = startValues.lastCompletion;
	                }
	                else if (shape instanceof LandMine) {
	                    let startValues = this.landmineStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    if (startValues.disappearTime === null)
	                        startValues.disappearTime = -Infinity;
	                    shape.disappearTime = startValues.disappearTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                }
	                else if (shape instanceof PushButton) {
	                    let startValues = this.pushButtonStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    if (startValues.lastContactTime === null)
	                        startValues.lastContactTime = -Infinity;
	                    shape.lastContactTime = startValues.lastContactTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                }
	                else if (shape instanceof Nuke) {
	                    let startValues = this.nukeStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    if (startValues.disappearTime === null)
	                        startValues.disappearTime = -Infinity;
	                    shape.disappearTime = startValues.disappearTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                }
	            }
	        }
	    }
	    /** Writes current data to the replay. */
	    record() {
	        var _a;
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        let marble = this.level.marble;
	        this.marblePositions.push(marble.body.position.clone());
	        this.marbleOrientations.push(marble.body.orientation.clone());
	        this.marbleLinearVelocities.push(marble.body.linearVelocity.clone());
	        this.marbleAngularVelocities.push(marble.body.angularVelocity.clone());
	        this.cameraOrientations.push({ yaw: this.level.yaw, pitch: this.level.pitch });
	        // Store sound state in the replay too
	        let rollingSound = (((_a = marble.rollingMegaMarbleSound) === null || _a === void 0 ? void 0 : _a.playing) ? marble.rollingMegaMarbleSound : marble.rollingSound);
	        this.rollingSoundGain.push(rollingSound.gain.gain.value);
	        this.rollingSoundPlaybackRate.push(rollingSound.node.playbackRate.value);
	        this.slidingSoundGain.push(marble.slidingSound.gain.gain.value);
	        if (this.level.finishTime && this.finishTime === null)
	            this.finishTime = Util.jsonClone(this.level.finishTime);
	        // Check if the replay is excessively long. If it is, stop it to prevent a memory error.
	        if (this.marblePositions.length >= PHYSICS_TICK_RATE * 60 * 60) {
	            this.canStore = false;
	            this.isInvalid = this.level.finishTime === null; // If the playthrough was finished, we don't consider the replay invalid.
	        }
	    }
	    recordMarbleInside(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleInside.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordMarbleEnter(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleEnter.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordMarbleLeave(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleLeave.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordMarbleContact(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleContact.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordUsePowerUp(powerUp) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.uses.push({
	            tickIndex: this.currentTickIndex,
	            id: powerUp.id
	        });
	    }
	    recordUseBlast() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.blasts.push({
	            tickIndex: this.currentTickIndex
	        });
	    }
	    recordTouchFinish() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.touchFinishTickIndices.push(this.currentTickIndex);
	    }
	    recordCheckpointRespawn() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.checkpointRespawns.push(this.currentTickIndex);
	    }
	    /** Apply the replay's stored state to the world. */
	    playBack() {
	        var _a, _b, _c, _d, _e, _f;
	        let i = this.currentTickIndex;
	        if (i >= this.marblePositions.length)
	            return; // Safety measure
	        for (let obj of this.marbleInside) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_a = this.level.shapes.find(x => x.id === obj.id)) !== null && _a !== void 0 ? _a : this.level.triggers.find(x => x.id === obj.id);
	            object.onMarbleInside(1);
	        }
	        for (let obj of this.marbleEnter) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_b = this.level.shapes.find(x => x.id === obj.id)) !== null && _b !== void 0 ? _b : this.level.triggers.find(x => x.id === obj.id);
	            object.onMarbleEnter(1);
	        }
	        for (let obj of this.marbleLeave) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_c = this.level.shapes.find(x => x.id === obj.id)) !== null && _c !== void 0 ? _c : this.level.triggers.find(x => x.id === obj.id);
	            object.onMarbleLeave();
	        }
	        for (let obj of this.marbleContact) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_d = this.level.shapes.find(x => x.id === obj.id)) !== null && _d !== void 0 ? _d : this.level.interiors.find(x => x.id === obj.id);
	            object.onMarbleContact(null, 1000 / PHYSICS_TICK_RATE);
	        }
	        for (let use of this.uses) {
	            if (use.tickIndex !== i)
	                continue;
	            let powerUp = this.level.shapes.find(x => x.id === use.id);
	            powerUp.use(0);
	        }
	        for (let blast of this.blasts) {
	            if (blast.tickIndex !== i)
	                continue;
	            this.level.marble.useBlast();
	        }
	        for (let tickIndex of this.touchFinishTickIndices)
	            if (tickIndex === i)
	                this.level.touchFinish();
	        for (let tickIndex of this.checkpointRespawns)
	            if (tickIndex === i)
	                this.level.loadCheckpointState();
	        this.level.marble.body.position.copy(this.marblePositions[i]);
	        this.level.marble.body.orientation.copy(this.marbleOrientations[i]);
	        this.level.marble.body.linearVelocity.copy(this.marbleLinearVelocities[i]);
	        this.level.marble.body.angularVelocity.copy(this.marbleAngularVelocities[i]);
	        this.level.yaw = this.cameraOrientations[i].yaw;
	        this.level.pitch = this.cameraOrientations[i].pitch;
	        for (let j = this.currentJumpSoundTime; j < this.jumpSoundTimes.length; j++) {
	            if (this.jumpSoundTimes[j] > i)
	                break;
	            if (this.jumpSoundTimes[j] === i)
	                this.level.marble.playJumpSound();
	        }
	        for (let j = this.currentBounceTime; j < this.bounceTimes.length; j++) {
	            if (this.bounceTimes[j].tickIndex > i)
	                break;
	            if (this.bounceTimes[j].tickIndex === i) {
	                this.level.marble.playBounceSound(this.bounceTimes[j].volume);
	                if (this.bounceTimes[j].showParticles)
	                    this.level.marble.showBounceParticles();
	            }
	        }
	        this.level.marble.rollingSound.gain.gain.setValueAtTime(this.rollingSoundGain[i], this.level.audio.currentTime);
	        (_e = this.level.marble.rollingMegaMarbleSound) === null || _e === void 0 ? void 0 : _e.gain.gain.setValueAtTime(this.rollingSoundGain[i], this.level.audio.currentTime);
	        this.level.marble.rollingSound.setPlaybackRate(this.rollingSoundPlaybackRate[i]);
	        (_f = this.level.marble.rollingMegaMarbleSound) === null || _f === void 0 ? void 0 : _f.setPlaybackRate(this.rollingSoundPlaybackRate[i]);
	        this.level.marble.slidingSound.gain.gain.setValueAtTime(this.slidingSoundGain[i], this.level.audio.currentTime);
	    }
	    isPlaybackComplete() {
	        return this.currentTickIndex === this.marblePositions.length - 1;
	    }
	    /** Converts the replay's data into a compressed array buffer. */
	    async serialize() {
	        let cameraOrientations = new Float32Array(this.cameraOrientations.length * 2);
	        for (let i = 0; i < this.cameraOrientations.length; i++) {
	            cameraOrientations[i * 2 + 0] = this.cameraOrientations[i].yaw;
	            cameraOrientations[i * 2 + 1] = this.cameraOrientations[i].pitch;
	        }
	        // First, create a more compact object by utilizing typed arrays.
	        let serialized = {
	            version: this.version,
	            timestamp: Date.now(),
	            missionPath: this.missionPath,
	            marblePositions: Util.arrayBufferToString(Replay.vec3sToBuffer(this.marblePositions).buffer),
	            marbleOrientations: Util.arrayBufferToString(Replay.quatsToBuffer(this.marbleOrientations).buffer),
	            marbleLinearVelocities: Util.arrayBufferToString(Replay.vec3sToBuffer(this.marbleLinearVelocities).buffer),
	            marbleAngularVelocities: Util.arrayBufferToString(Replay.vec3sToBuffer(this.marbleAngularVelocities).buffer),
	            marbleInside: this.marbleInside,
	            marbleEnter: this.marbleEnter,
	            marbleLeave: this.marbleLeave,
	            marbleContact: this.marbleContact,
	            uses: this.uses,
	            blasts: this.blasts,
	            cameraOrientations: Util.arrayBufferToString(cameraOrientations.buffer),
	            timeTravelTimeToRevert: [...this.timeTravelTimeToRevert.entries()],
	            touchFinishTickIndices: this.touchFinishTickIndices,
	            finishTime: this.finishTime,
	            trapdoorStartValues: this.trapdoorStartValues,
	            landmineStartValues: this.landmineStartValues,
	            pushButtonStartValues: this.pushButtonStartValues,
	            nukeStartValues: this.nukeStartValues,
	            timeSinceLoad: this.timeSinceLoad,
	            rollingSoundGain: Util.arrayBufferToString(new Float32Array(this.rollingSoundGain).buffer),
	            rollingSoundPlaybackRate: Util.arrayBufferToString(new Float32Array(this.rollingSoundPlaybackRate).buffer),
	            slidingSoundGain: Util.arrayBufferToString(new Float32Array(this.slidingSoundGain).buffer),
	            jumpSoundTimes: this.jumpSoundTimes,
	            bounceTimes: this.bounceTimes,
	            randomPowerUpChoices: [...this.randomPowerUpChoices.entries()],
	            checkpointRespawns: this.checkpointRespawns
	        };
	        // Then compress the whole th ing. As this step is the most expensive, run it in another thread.
	        let compressed = await executeOnWorker('compress', JSON.stringify(serialized));
	        return compressed;
	    }
	    /** Reconstructs a replay from its compressed array buffer representation. */
	    static fromSerialized(buf) {
	        var _a, _b, _c, _d, _e, _f, _g;
	        let replay = new Replay();
	        let string = pako.inflate(new Uint8Array(buf), { to: 'string' });
	        let serialized = JSON.parse(string);
	        let version = (_a = serialized.version) !== null && _a !== void 0 ? _a : 0;
	        replay.version = version;
	        replay.missionPath = (version >= 1) ? serialized.missionPath : null;
	        replay.timestamp = (version >= 1) ? serialized.timestamp : 0;
	        replay.marblePositions = Replay.bufferToVec3s(new Float32Array(Util.stringToArrayBuffer(serialized.marblePositions)));
	        replay.marbleOrientations = Replay.bufferToQuats(new Float32Array(Util.stringToArrayBuffer(serialized.marbleOrientations)));
	        replay.marbleLinearVelocities = Replay.bufferToVec3s(new Float32Array(Util.stringToArrayBuffer(serialized.marbleLinearVelocities)));
	        replay.marbleAngularVelocities = Replay.bufferToVec3s(new Float32Array(Util.stringToArrayBuffer(serialized.marbleAngularVelocities)));
	        replay.marbleInside = serialized.marbleInside;
	        replay.marbleEnter = serialized.marbleEnter;
	        replay.marbleLeave = (_b = serialized.marbleLeave) !== null && _b !== void 0 ? _b : []; // Might not be there in older versions
	        replay.marbleContact = serialized.marbleContact;
	        replay.uses = serialized.uses;
	        replay.blasts = (_c = serialized.blasts) !== null && _c !== void 0 ? _c : [];
	        let cameraOrientations = [];
	        let cameraOrientationsBuffer = new Float32Array(Util.stringToArrayBuffer(serialized.cameraOrientations));
	        for (let i = 0; i < cameraOrientationsBuffer.length / 2; i++) {
	            cameraOrientations.push({
	                yaw: cameraOrientationsBuffer[i * 2 + 0],
	                pitch: cameraOrientationsBuffer[i * 2 + 1]
	            });
	        }
	        replay.cameraOrientations = cameraOrientations;
	        replay.timeTravelTimeToRevert = serialized.timeTravelTimeToRevert.reduce((prev, next) => (prev.set(next[0], next[1]), prev), new Map());
	        replay.touchFinishTickIndices = serialized.touchFinishTickIndices;
	        replay.finishTime = serialized.finishTime;
	        replay.trapdoorStartValues = serialized.trapdoorStartValues;
	        replay.landmineStartValues = serialized.landmineStartValues;
	        replay.pushButtonStartValues = (_d = serialized.pushButtonStartValues) !== null && _d !== void 0 ? _d : []; // Might not be there in older versions
	        replay.nukeStartValues = (_e = serialized.nukeStartValues) !== null && _e !== void 0 ? _e : [];
	        replay.timeSinceLoad = serialized.timeSinceLoad;
	        replay.rollingSoundGain = [...new Float32Array(Util.stringToArrayBuffer(serialized.rollingSoundGain))];
	        replay.rollingSoundPlaybackRate = [...new Float32Array(Util.stringToArrayBuffer(serialized.rollingSoundPlaybackRate))];
	        replay.slidingSoundGain = [...new Float32Array(Util.stringToArrayBuffer(serialized.slidingSoundGain))];
	        replay.jumpSoundTimes = serialized.jumpSoundTimes;
	        replay.bounceTimes = serialized.bounceTimes;
	        replay.randomPowerUpChoices = ((_f = serialized.randomPowerUpChoices) !== null && _f !== void 0 ? _f : []).reduce((prev, next) => (prev.set(next[0], next[1]), prev), new Map());
	        replay.checkpointRespawns = (_g = serialized.checkpointRespawns) !== null && _g !== void 0 ? _g : [];
	        return replay;
	    }
	    static vec3sToBuffer(arr) {
	        let buffer = new Float32Array(arr.length * 3);
	        for (let i = 0; i < arr.length; i++) {
	            buffer[i * 3 + 0] = arr[i].x;
	            buffer[i * 3 + 1] = arr[i].y;
	            buffer[i * 3 + 2] = arr[i].z;
	        }
	        return buffer;
	    }
	    static quatsToBuffer(arr) {
	        let buffer = new Float32Array(arr.length * 4);
	        for (let i = 0; i < arr.length; i++) {
	            buffer[i * 4 + 0] = arr[i].x;
	            buffer[i * 4 + 1] = arr[i].y;
	            buffer[i * 4 + 2] = arr[i].z;
	            buffer[i * 4 + 3] = arr[i].w;
	        }
	        return buffer;
	    }
	    static bufferToVec3s(buf) {
	        let vecs = [];
	        for (let i = 0; i < buf.length / 3; i++) {
	            let vec = new Vector3(buf[i * 3 + 0], buf[i * 3 + 1], buf[i * 3 + 2]);
	            vecs.push(vec);
	        }
	        return vecs;
	    }
	    static bufferToQuats(buf) {
	        let quats = [];
	        for (let i = 0; i < buf.length / 4; i++) {
	            let quat = new Quaternion(buf[i * 4 + 0], buf[i * 4 + 1], buf[i * 4 + 2], buf[i * 4 + 3]);
	            quats.push(quat);
	        }
	        return quats;
	    }
	    /** Downloads a replay as a .wrec file. */
	    static async download(replayData, mission, normalize = true, unfinished = false) {
	        if (normalize)
	            replayData = await this.maybeUpdateReplay(replayData, mission.path); // Normalize the replay first
	        // Create the blob and download it
	        let blob = new Blob([replayData], {
	            type: 'application/octet-stream'
	        });
	        let url = URL.createObjectURL(blob);
	        let filename = Util.removeSpecialChars(mission.title.toLowerCase().split(' ').map(x => Util.uppercaseFirstLetter(x)).join(''));
	        filename += '-';
	        for (let i = 0; i < 6; i++)
	            filename += '0123456789abcdef'[Math.floor(Math.random() * 16)]; // Add a random hex string to the end
	        if (unfinished)
	            filename += 'u'; // Clearly mark the replay as being unfinished
	        filename += '.wrec';
	        Util.download(url, filename);
	        URL.revokeObjectURL(url);
	    }
	    /** Makes sure a replay fits some requirements. */
	    static async maybeUpdateReplay(replayData, missionPath) {
	        let uncompressed = pako.inflate(new Uint8Array(replayData), { to: 'string' });
	        // This is a bit unfortunate, but we'd like to bundle the mission path with the replay, but the first replay version didn't include it. So we need to check if the replay actually includes the mission path, which we can check by checking if it includes the "version" field. We then upgrade the replay to verion 1.
	        if (!uncompressed.includes('"version"')) {
	            let json = JSON.parse(uncompressed);
	            // Upgrade to version 1
	            json.missionPath = missionPath;
	            json.timestamp = 0;
	            json.version = 1;
	            let compressed = await executeOnWorker('compress', JSON.stringify(json));
	            replayData = compressed;
	        }
	        return replayData;
	    }
	}

	var _a;
	/** Handles rendering replays into playable video files. */
	class VideoRenderer {
	    static get isCompilation() {
	        return !!this.directoryHandle;
	    }
	    static updateOverviewText() {
	        let playbackSpeed = Number(this.div.querySelectorAll('._config-row')[4].children[1].value) || 1;
	        let videoLength = this.tickLength / PHYSICS_TICK_RATE / playbackSpeed; // Somewhat approximate since it doesn't factor in FPS
	        let text = `Video duration: ${Util.secondsToTimeString(videoLength, 3)}\nDestination file: ${this.fileHandle ? this.fileHandle.name : '–'}`; // Yeah I know, VS Code
	        if (this.isCompilation) {
	            let levelCount = this.compilation.schedule.filter(x => x.type === 'replay').length;
	            text = `Levels: ${levelCount}\n` + text;
	        }
	        else {
	            let mission = this.compilation.schedule[0].mission;
	            text = `Level: ${mission.title}\n` + text;
	        }
	        this.overviewText.textContent = text;
	    }
	    static updateMusicToSoundRatioDisplay() {
	        let musicToSoundRatioSlider = this.div.querySelectorAll('._config-row')[9].children[1];
	        let musicToSoundRatioDisplay = this.div.querySelectorAll('._config-row')[9].children[2];
	        // Tan is a fit function for the job, as we want the first half to output values from 0 to 1, and the second value to output values from 1 to infinity. If you take the reciprocal of the second half, it looks like the mirror image of the first half - because tan trig stuff.
	        let ratio = Math.tan(Number(musicToSoundRatioSlider.value) * Math.PI / 2);
	        if (musicToSoundRatioSlider.value === '0.5')
	            ratio = 1;
	        if (musicToSoundRatioSlider.value === '1')
	            ratio = Infinity;
	        musicToSoundRatioDisplay.textContent = `${Math.min(Util.cursedRound(ratio, 10), 1)} : ${Math.min(Util.cursedRound(1 / ratio, 10), 1)}`;
	    }
	    static updateAudioSettingsEnabledness() {
	        let enabled = this.div.querySelectorAll('._config-row')[7].children[1].checked;
	        this.div.querySelectorAll('._config-row')[8].classList.toggle('disabled', !enabled);
	        this.div.querySelectorAll('._config-row')[9].classList.toggle('disabled', !enabled);
	    }
	    /** Creates a Worker that will be responsible for video encoding and writing to disk - it makes sense to perform these operations in a separate thread. */
	    static async createWorker() {
	        let entire = workerBody$1.toString();
	        let bodyString = entire.slice(entire.indexOf("{") + 1, entire.lastIndexOf("}"));
	        let blob = new Blob([bodyString]);
	        let worker = new Worker(URL.createObjectURL(blob));
	        worker.postMessage(window.location.href.slice(0, window.location.href.lastIndexOf('/') + 1));
	        await new Promise(resolve => worker.addEventListener('message', e => e.data === 'ready' && resolve()));
	        return worker;
	    }
	    static async render() {
	        this.process = new RenderingProcess();
	        await this.process.run();
	        this.hide();
	    }
	    static async stopRender(force) {
	        var _b;
	        if (!force && !(await state.menu.showConfirmPopup('Stop rendering', "Are you sure you want to cancel the ongoing rendering process?"))) {
	            return;
	        }
	        (_b = this.process) === null || _b === void 0 ? void 0 : _b.stop();
	        this.hide();
	    }
	    static show() {
	        this.div.classList.remove('hidden');
	        state.menu.levelSelect.hide();
	        if (!this.loaded)
	            this.initUiFromStoredConfig();
	    }
	    /** Opens the video renderer UI, ready to render the specified `replay`. */
	    static showForSingleReplay(mission, replay) {
	        if (!('showSaveFilePicker' in window) || !('VideoEncoder' in window)) {
	            this.showNotSupportedAlert();
	            return;
	        }
	        this.show();
	        // Create a simple "compilation" that will model recording a single replay with no extra text
	        this.compilation = {
	            schedule: [{
	                    type: 'replay',
	                    filename: null,
	                    replay,
	                    mission
	                }],
	            showInfo: false
	        };
	        this.computeLength();
	        this.updateOverviewText();
	        this.selectDestinationButton.style.display = '';
	    }
	    /** Opens the video renderer UI, ready to render the compilation specified in the given directory.. */
	    static async showForCompilation(directoryHandle) {
	        var _b, _c;
	        this.directoryHandle = directoryHandle;
	        let compilationManifestFile;
	        try {
	            compilationManifestFile = await directoryHandle.getFileHandle('manifest.json');
	        }
	        catch (e) {
	            state.menu.showAlertPopup('Missing compilation manifest file', "The selected directory does not contain a manifest.json file, which is required. For a tutorial on how to render compilations, click [here](https://github.com/Vanilagy/MarbleBlast/tree/master/docs/compilation_how_to.md).");
	            return;
	        }
	        this.show();
	        this.selectDestinationButton.style.display = 'none';
	        this.compilationLoadingElement.classList.remove('hidden');
	        try {
	            let fileText = await (await compilationManifestFile.getFile()).text();
	            this.compilation = JSON.parse(fileText);
	            let replayCount = this.compilation.schedule.filter(x => x.type === 'replay').length;
	            // Load and check all of the replays
	            let i = 0;
	            for (let entry of this.compilation.schedule) {
	                if (entry.type !== 'replay')
	                    continue;
	                let loaded = i++ / replayCount;
	                this.compilationLoadingElement.textContent = `Loading... (${Math.floor(loaded * 100)}%)`;
	                let arrayBuffer;
	                try {
	                    let replayFile = await directoryHandle.getFileHandle(entry.filename);
	                    arrayBuffer = await (await replayFile.getFile()).arrayBuffer();
	                }
	                catch {
	                    state.menu.showAlertPopup('Replay file does not exist', `The file "${entry.filename}", which the manifest references, was not found.`);
	                    this.hide();
	                    return;
	                }
	                let replay = Replay.fromSerialized(arrayBuffer);
	                let mission = MissionLibrary.allMissions.find(x => x.path === replay.missionPath);
	                if (!mission)
	                    throw new Error("Mission not found.");
	                entry.replay = replay;
	                entry.mission = mission;
	                if (typeof entry.runner === 'string') {
	                    let runnerId = entry.runner;
	                    let runnerDefinition = this.compilation.runners.find(x => x.id === runnerId);
	                    if (!runnerDefinition) {
	                        state.menu.showAlertPopup('Runner definition not found', `Runner with ID "${entry.runner}" referenced in the manifest but not defined.`);
	                        this.hide();
	                        return;
	                    }
	                    if (runnerDefinition.marbleTexture) {
	                        try {
	                            await (await VideoRenderer.directoryHandle.getFileHandle(runnerDefinition.marbleTexture)).getFile();
	                        }
	                        catch {
	                            state.menu.showAlertPopup('Marble texture file not found.', `Texture file "${runnerDefinition.marbleTexture}" was referenced in the manifest but not found.`);
	                            this.hide();
	                            return;
	                        }
	                    }
	                }
	            }
	            this.fileHandle = await directoryHandle.getFileHandle((_b = this.compilation.outputFilename) !== null && _b !== void 0 ? _b : 'output.webm', { create: true });
	            this.chapterFileHandle = await directoryHandle.getFileHandle((_c = this.compilation.chaptersFilename) !== null && _c !== void 0 ? _c : 'chapters.txt', { create: true });
	            this.compilationLoadingElement.classList.add('hidden');
	            this.renderButton.classList.remove('disabled');
	            this.computeLength();
	            this.updateOverviewText();
	        }
	        catch (e) {
	            console.error(e);
	            this.hide();
	            state.menu.showAlertPopup('Error', "An error occurred while loading the compilation. Your compilation manifest might be malformed - check the web console.");
	        }
	    }
	    static computeTickLengthForReplay(replay) {
	        // Compute how many simulation ticks the replay is long
	        var _b;
	        let tickLength = replay.marblePositions.length - 1; // The last tick always means the end of the replay, so don't include it
	        if (replay.finishTime) {
	            // Cap the replay to last only 2 more seconds after the finish has been reached (theoretically, players can idle in the finish animation by waiting to submit their score)
	            let tickIndex = (_b = replay.finishTime.tickIndex) !== null && _b !== void 0 ? _b : Math.floor(replay.finishTime.currentAttemptTime * PHYSICS_TICK_RATE / 1000);
	            tickLength = Math.min(tickLength, tickIndex + 2 * PHYSICS_TICK_RATE);
	        }
	        return tickLength;
	    }
	    static computeLength() {
	        this.tickLength = 0;
	        for (let entry of this.compilation.schedule) {
	            if (entry.type !== 'replay')
	                continue;
	            let replay = entry.replay;
	            this.tickLength += this.computeTickLengthForReplay(replay);
	        }
	    }
	    static initUiFromStoredConfig() {
	        this.loaded = true;
	        let playbackSpeedString = StorageManager.data.videoRecorderConfig.playbackSpeed.toString();
	        if (!playbackSpeedString.includes('.'))
	            playbackSpeedString += '.0';
	        // Set the initial values to the ones stored
	        this.div.querySelectorAll('._config-row')[0].children[1].value = StorageManager.data.videoRecorderConfig.width.toString();
	        this.div.querySelectorAll('._config-row')[1].children[1].value = StorageManager.data.videoRecorderConfig.height.toString();
	        this.div.querySelectorAll('._config-row')[2].children[1].value = StorageManager.data.videoRecorderConfig.kilobitRate.toString();
	        this.div.querySelectorAll('._config-row')[3].children[1].value = StorageManager.data.videoRecorderConfig.frameRate.toString();
	        this.div.querySelectorAll('._config-row')[4].children[1].value = playbackSpeedString;
	        this.div.querySelectorAll('._config-row')[5].children[1].checked = StorageManager.data.videoRecorderConfig.fastMode;
	        this.div.querySelectorAll('._config-row')[6].children[1].checked = StorageManager.data.videoRecorderConfig.bt709;
	        this.div.querySelectorAll('._config-row')[7].children[1].checked = StorageManager.data.videoRecorderConfig.includeAudio;
	        this.div.querySelectorAll('._config-row')[8].children[1].value = StorageManager.data.videoRecorderConfig.audioKilobitRate.toString();
	        this.div.querySelectorAll('._config-row')[9].children[1].value = (2 * Math.atan(StorageManager.data.videoRecorderConfig.musicToSoundRatio) / Math.PI).toString();
	        this.updateMusicToSoundRatioDisplay();
	        this.updateAudioSettingsEnabledness();
	    }
	    static hide() {
	        this.div.classList.add('hidden');
	        state.menu.levelSelect.show();
	        this.directoryHandle = null;
	        this.fileHandle = null;
	        this.chapterFileHandle = null;
	        this.process = null;
	        this.compilation = null;
	        this.renderButton.classList.add('disabled');
	        this.progressBar.style.display = 'none';
	        this.progressBar.value = 0;
	        this.statusText.textContent = '';
	        this.configContainer.classList.remove('disabled');
	        this.renderButton.textContent = 'Render';
	        this.closeButton.style.display = '';
	        this.compilationLoadingElement.classList.add('hidden');
	        document.title = 'Marble Blast Web';
	    }
	    static showNotSupportedAlert() {
	        state.menu.showAlertPopup("Not supported", "Unfortunately, your browser does not support the technology required by the video renderer. To access this feature, try using Chromium 94 or above (Chrome 94, Edge 94, Opera 80) on desktop.");
	    }
	}
	_a = VideoRenderer;
	VideoRenderer.loaded = false;
	VideoRenderer.compilation = null;
	VideoRenderer.process = null;
	(() => {
	    _a.div = document.querySelector('#video-renderer');
	    _a.configContainer = _a.div.querySelector('._config');
	    _a.selectDestinationButton = _a.div.querySelector('#video-renderer-select-destination');
	    _a.overviewText = _a.div.querySelector('#video-renderer-overview');
	    _a.renderButton = _a.div.querySelector('#video-renderer-render');
	    _a.closeButton = _a.div.querySelector('#video-renderer-close');
	    _a.progressBar = _a.div.querySelector('#video-renderer progress');
	    _a.statusText = _a.div.querySelector('#video-renderer-status');
	    _a.compilationLoadingElement = _a.div.querySelector('#video-renderer-compilation-loading');
	    _a.selectDestinationButton.addEventListener('click', async () => {
	        let mission = _a.compilation.schedule[0].mission;
	        let suggestedFilename = Util.removeSpecialChars(mission.title.toLowerCase().split(' ').map(x => Util.uppercaseFirstLetter(x)).join(''));
	        try {
	            _a.fileHandle = await window.showSaveFilePicker({
	                startIn: 'videos',
	                suggestedName: `${suggestedFilename}.webm`,
	                types: [{
	                        description: 'Video File',
	                        accept: { 'video/webm': ['.webm'] }
	                    }]
	            });
	        }
	        catch (e) {
	            return;
	        }
	        _a.updateOverviewText();
	        _a.renderButton.classList.remove('disabled');
	    });
	    _a.renderButton.addEventListener('click', () => {
	        if (_a.renderButton.textContent === 'Stop') {
	            _a.stopRender(false);
	        }
	        else {
	            _a.render();
	        }
	    });
	    _a.closeButton.addEventListener('click', () => {
	        _a.stopRender(true);
	    });
	    // Update the overview text when the playback speed is modified
	    _a.div.querySelectorAll('._config-row')[4].children[1].addEventListener('input', () => {
	        _a.updateOverviewText();
	    });
	    _a.div.querySelectorAll('._config-row')[7].children[1].addEventListener('input', () => {
	        _a.updateAudioSettingsEnabledness();
	    });
	    let musicToSoundRatioSlider = _a.div.querySelectorAll('._config-row')[9].children[1];
	    musicToSoundRatioSlider.addEventListener('input', () => {
	        _a.updateMusicToSoundRatioDisplay();
	    });
	})();
	class RenderingProcess {
	    constructor() {
	        this.renderedFrames = 0;
	        this.renderedLevels = 0;
	        this.stopped = false;
	        this.chaptersText = "";
	    }
	    async run() {
	        var _b, _c;
	        try {
	            this.readConfiguration();
	            let configValid = this.validateConfiguration();
	            if (!configValid)
	                return;
	            this.storeConfiguration();
	            this.prepareUi();
	            await this.createWorker();
	            this.setUpWorker();
	            await this.keepScreenAwake();
	            await this.renderLevels();
	            this.initFinalization();
	            if (this.stopped)
	                return;
	            await this.awaitEncoding();
	            await this.finalize();
	        }
	        catch (e) {
	            console.error(e);
	            (_b = this.level) === null || _b === void 0 ? void 0 : _b.stop();
	            clearInterval(this.intervalId);
	            this.exitWithError();
	        }
	        finally {
	            (_c = this.worker) === null || _c === void 0 ? void 0 : _c.terminate();
	            this.releaseWakeLock();
	        }
	    }
	    async renderLevels() {
	        for (let entry of VideoRenderer.compilation.schedule) {
	            if (entry.type !== 'replay')
	                continue;
	            if (this.stopped)
	                break;
	            this.currentEntry = entry;
	            let { mission, replay } = entry;
	            await this.loadLevel(mission, replay);
	            this.initRendering();
	            await this.renderFrames();
	            await this.renderAudio();
	            this.level.stop();
	            state.level = null;
	            replay.level = null; // GC
	            this.renderedLevels++;
	        }
	    }
	    readConfiguration() {
	        const div = VideoRenderer.div;
	        // Video config
	        this.width = Number(div.querySelectorAll('._config-row')[0].children[1].value);
	        this.height = Number(div.querySelectorAll('._config-row')[1].children[1].value);
	        this.kilobitRate = Number(div.querySelectorAll('._config-row')[2].children[1].value);
	        this.frameRate = Number(div.querySelectorAll('._config-row')[3].children[1].value);
	        this.playbackSpeed = Number(div.querySelectorAll('._config-row')[4].children[1].value);
	        this.fastMode = div.querySelectorAll('._config-row')[5].children[1].checked;
	        this.bt709 = div.querySelectorAll('._config-row')[6].children[1].checked;
	        // Audio config
	        this.includeAudio = div.querySelectorAll('._config-row')[7].children[1].checked;
	        this.audioKilobitRate = Number(div.querySelectorAll('._config-row')[8].children[1].value);
	        this.musicToSoundRatio = Math.tan(Number(div.querySelectorAll('._config-row')[9].children[1].value) * Math.PI / 2);
	    }
	    validateConfiguration() {
	        if (!Number.isInteger(this.width) || this.width < 1 || this.width % 2 !== 0) {
	            state.menu.showAlertPopup("Error", `"Width" has to be a positive even integer.`);
	            return false;
	        }
	        if (!Number.isInteger(this.height) || this.height < 1 || this.height % 2 !== 0) {
	            state.menu.showAlertPopup("Error", `"Height" has to be a positive even integer.`);
	            return false;
	        }
	        if (!isFinite(this.kilobitRate) || this.kilobitRate < 1) {
	            state.menu.showAlertPopup("Error", `"Bit rate" has an illegal value.`);
	            return false;
	        }
	        if (!isFinite(this.frameRate) || this.frameRate <= 0) {
	            state.menu.showAlertPopup("Error", `"Frame rate" has to be positive.`);
	            return false;
	        }
	        if (!isFinite(this.playbackSpeed) || this.playbackSpeed <= 0) {
	            state.menu.showAlertPopup("Error", `"Playback speed" has to be positive.`);
	            return false;
	        }
	        if (!isFinite(this.audioKilobitRate) || this.audioKilobitRate < 6) {
	            state.menu.showAlertPopup("Error", `"Audio bit rate" has to be at least 6 kbit/s.`);
	            return false;
	        }
	        return true;
	    }
	    storeConfiguration() {
	        StorageManager.data.videoRecorderConfig.width = this.width;
	        StorageManager.data.videoRecorderConfig.height = this.height;
	        StorageManager.data.videoRecorderConfig.kilobitRate = this.kilobitRate;
	        StorageManager.data.videoRecorderConfig.frameRate = this.frameRate;
	        StorageManager.data.videoRecorderConfig.playbackSpeed = this.playbackSpeed;
	        StorageManager.data.videoRecorderConfig.fastMode = this.fastMode;
	        StorageManager.data.videoRecorderConfig.bt709 = this.bt709;
	        StorageManager.data.videoRecorderConfig.includeAudio = this.includeAudio;
	        StorageManager.data.videoRecorderConfig.audioKilobitRate = this.audioKilobitRate;
	        StorageManager.data.videoRecorderConfig.musicToSoundRatio = this.musicToSoundRatio;
	        StorageManager.store();
	    }
	    computeFrameCountForReplay(replay) {
	        return Math.floor(VideoRenderer.computeTickLengthForReplay(replay) / PHYSICS_TICK_RATE * this.frameRate / this.playbackSpeed);
	    }
	    prepareUi() {
	        VideoRenderer.configContainer.classList.add('disabled');
	        VideoRenderer.progressBar.style.display = 'block';
	        VideoRenderer.renderButton.textContent = 'Stop';
	        VideoRenderer.closeButton.style.display = 'none';
	        let replayEntries = VideoRenderer.compilation.schedule.filter(x => x.type === 'replay');
	        this.totalFrameCount = replayEntries.reduce((acc, entry) => acc + this.computeFrameCountForReplay(entry.replay), 0);
	        this.totalTimeUs = 1e6 * this.totalFrameCount / this.frameRate;
	        this.levelCount = replayEntries.length;
	    }
	    async createWorker() {
	        let entire = workerBody$1.toString();
	        let bodyString = entire.slice(entire.indexOf("{") + 1, entire.lastIndexOf("}"));
	        let blob = new Blob([bodyString]);
	        let worker = new Worker(URL.createObjectURL(blob));
	        worker.postMessage(window.location.href.slice(0, window.location.href.lastIndexOf('/') + 1));
	        await new Promise(resolve => worker.addEventListener('message', e => e.data === 'ready' && resolve()));
	        this.worker = worker;
	    }
	    async loadLevel(mission, replay) {
	        this.beginUpdatingUiBasedOnLoadingProgress();
	        await mission.load();
	        this.level = new Level(mission, {
	            duration: this.computeFrameCountForReplay(replay) / this.frameRate * this.playbackSpeed,
	            musicVolume: Math.min(this.musicToSoundRatio, 1),
	            soundVolume: Math.min(1 / this.musicToSoundRatio, 1),
	            ...await this.getMarbleConfigForCurrentRunner()
	        });
	        state.level = this.level;
	        await this.level.init();
	        this.level.replay = replay;
	        replay.level = this.level;
	        replay.mode = 'playback';
	        await this.level.start();
	        clearInterval(this.intervalId);
	    }
	    async getMarbleConfigForCurrentRunner() {
	        let marbleTexture;
	        let reflectiveMarble;
	        if (typeof this.currentEntry.runner === 'string') {
	            let runner = VideoRenderer.compilation.runners.find(x => x.id === this.currentEntry.runner);
	            let marbleTextureFilename = runner.marbleTexture;
	            if (marbleTextureFilename) {
	                marbleTexture = await (await VideoRenderer.directoryHandle.getFileHandle(marbleTextureFilename)).getFile();
	            }
	            else if (marbleTextureFilename === null) {
	                marbleTexture = null;
	            }
	            reflectiveMarble = runner.reflectiveMarble;
	        }
	        return { marbleTexture, reflectiveMarble };
	    }
	    beginUpdatingUiBasedOnLoadingProgress() {
	        this.intervalId = setInterval(() => {
	            var _b, _c;
	            let completion = Math.min((_c = (_b = this.level) === null || _b === void 0 ? void 0 : _b.getLoadingCompletion()) !== null && _c !== void 0 ? _c : 0, 1);
	            VideoRenderer.progressBar.value = (this.renderedLevels + completion * 0.1) / this.levelCount;
	            VideoRenderer.progressBar.value *= 0.8;
	            VideoRenderer.statusText.textContent = `Loading (${Math.floor(completion * 100)}%)`;
	        }, 16);
	    }
	    setUpWorker() {
	        this.worker.postMessage({
	            command: 'setup',
	            width: this.width,
	            height: this.height,
	            kilobitRate: this.kilobitRate,
	            frameRate: this.frameRate,
	            includeAudio: this.includeAudio,
	            audioKilobitRate: this.audioKilobitRate,
	            fileHandle: VideoRenderer.fileHandle
	        });
	        // Bubble worker errors up to this context
	        this.worker.addEventListener('message', e => {
	            var _b;
	            if (e.data.command === 'error') {
	                console.error(e);
	                (_b = this.level) === null || _b === void 0 ? void 0 : _b.stop();
	                clearInterval(this.intervalId);
	                this.exitWithError();
	            }
	        });
	        // We use these variables to compute the completion of the encoding process
	        this.lastVideoChunkTimestamp = 0;
	        this.lastAudioChunkTimestamp = this.includeAudio ? 0 : Infinity;
	        this.worker.addEventListener('message', e => {
	            if (e.data.command === 'videoChunkEncoded')
	                this.lastVideoChunkTimestamp = e.data.timestamp;
	            else if (e.data.command === 'audioChunkEncoded')
	                this.lastAudioChunkTimestamp = e.data.timestamp;
	        });
	    }
	    initRendering() {
	        mainRenderer.setSize(this.width, this.height);
	        mainRenderer.setPixelRatio(1.0);
	        this.level.onResize(this.width, this.height, 1.0);
	        let compositeCanvas = document.createElement('canvas');
	        compositeCanvas.setAttribute('width', this.width.toString());
	        compositeCanvas.setAttribute('height', this.height.toString());
	        this.ctx = compositeCanvas.getContext('2d', { willReadFrequently: true });
	    }
	    async renderFrames() {
	        const frameCount = this.computeFrameCountForReplay(this.currentEntry.replay);
	        // Now, render all the frames we need
	        for (let frame = 0; frame < frameCount; frame++) {
	            if (this.stopped)
	                break; // Abort
	            let time = 1000 * frame * this.playbackSpeed / this.frameRate;
	            this.level.render(time);
	            if (this.level.stopped)
	                break;
	            this.composeFrame(time);
	            this.sendFrameToWorker();
	            if (frame === 0)
	                this.appendToChaptersText();
	            this.renderedFrames++;
	            document.title = `Rendering (${(100 * this.renderedFrames / this.totalFrameCount).toFixed(1)}%) - Marble Blast Web`;
	            VideoRenderer.statusText.textContent = `Rendering frame ${Math.min(this.renderedFrames, this.totalFrameCount)}/${this.totalFrameCount}`;
	            VideoRenderer.progressBar.value = (this.renderedLevels + 0.1 + 0.9 * Math.min(frame + 1, frameCount) / frameCount) / this.levelCount;
	            VideoRenderer.progressBar.value *= 0.8;
	            await this.waitBeforeRenderingNextFrame();
	            if (mainRenderer.gl.isContextLost())
	                throw new Error("Context lost");
	        }
	    }
	    composeFrame(time) {
	        this.ctx.globalAlpha = 1;
	        this.ctx.shadowColor = 'transparent';
	        this.ctx.shadowBlur = 0;
	        this.ctx.shadowOffsetX = 0;
	        this.ctx.shadowOffsetY = 0;
	        this.ctx.resetTransform();
	        // Compose together the main game canvas and the HUD canvas
	        this.ctx.drawImage(mainCanvas, 0, 0);
	        this.ctx.drawImage(state.menu.hud.hudCanvas, 0, 0);
	        this.maybeDrawRunInfo(time);
	        this.drawSectionText(time);
	    }
	    maybeDrawRunInfo(time) {
	        if (VideoRenderer.compilation.showInfo === false)
	            return;
	        let fadeDuration = 1000;
	        this.ctx.globalAlpha = 1 - Util.clamp((time - (GO_TIME - fadeDuration)) / fadeDuration, 0, 1);
	        if (this.ctx.globalAlpha === 0)
	            return;
	        let fontSizeScaling = this.width / 1920;
	        let scaleCompletion = 1 - (1 - Util.clamp(time / 500, 0, 1)) ** 2;
	        let scale = Util.lerp(1.05, 1, scaleCompletion);
	        this.ctx.translate(this.width / 2, this.height);
	        this.ctx.scale(scale, scale);
	        this.ctx.translate(-this.width / 2, -this.height);
	        // Draw the level name and time
	        this.ctx.fillStyle = 'white';
	        this.ctx.font = `${64 * fontSizeScaling}px Chakra Petch`;
	        this.ctx.textAlign = 'center';
	        this.ctx.textBaseline = 'top';
	        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.75)';
	        this.ctx.shadowBlur = 4 * fontSizeScaling;
	        this.ctx.shadowOffsetX = 1 * fontSizeScaling;
	        this.ctx.shadowOffsetY = 2 * fontSizeScaling;
	        let text = this.level.mission.title;
	        let { replay } = this.currentEntry;
	        if (replay.finishTime)
	            text += ' - ' + Util.secondsToTimeString(replay.finishTime.gameplayClock / 1000);
	        this.ctx.fillText(text, this.width / 2, this.height * 0.73);
	        // Maybe draw the runner
	        if (typeof this.currentEntry.runner === 'string') {
	            let runnerName = VideoRenderer.compilation.runners.find(x => x.id === this.currentEntry.runner).name;
	            this.ctx.font = `${48 * fontSizeScaling}px Chakra Petch`;
	            this.ctx.fillText(`Runner: ${runnerName}`, this.width / 2, this.height * 0.8);
	        }
	    }
	    /** Draws the text of all the sections that have ended with this level. */
	    drawSectionText(time) {
	        let replayDuration = 1000 * VideoRenderer.computeTickLengthForReplay(this.currentEntry.replay) / PHYSICS_TICK_RATE;
	        let animationTime = time - (replayDuration - 3000);
	        let animationCompletion = Util.clamp(animationTime / 500, 0, 1);
	        if (animationCompletion === 0)
	            return;
	        let schedule = VideoRenderer.compilation.schedule;
	        let index = schedule.findIndex(x => x === this.currentEntry) + 1;
	        let currentEnds = [];
	        while (schedule[index] && schedule[index].type === 'sectionEnd') {
	            currentEnds.push(schedule[index]);
	            index++;
	        }
	        for (let [i, end] of currentEnds.reverse().entries()) {
	            let startIndex = Util.findLastIndex(schedule, x => x.type === 'sectionStart' && x.name === end.name, index - 1);
	            if (startIndex === -1)
	                continue;
	            let totalTime = 0;
	            for (let j = startIndex + 1; j < index; j++) {
	                let entry = schedule[j];
	                if (entry.type !== 'replay' || !entry.replay.finishTime)
	                    continue;
	                totalTime += entry.replay.finishTime.gameplayClock;
	            }
	            let fontSizeScaling = this.width / 1920;
	            this.ctx.globalAlpha = animationCompletion;
	            this.ctx.fillStyle = 'white';
	            this.ctx.font = `${64 * fontSizeScaling}px Chakra Petch`;
	            this.ctx.textAlign = 'center';
	            this.ctx.textBaseline = 'top';
	            this.ctx.shadowColor = 'rgba(0, 0, 0, 0.75)';
	            this.ctx.shadowBlur = 4 * fontSizeScaling;
	            this.ctx.shadowOffsetX = 1 * fontSizeScaling;
	            this.ctx.shadowOffsetY = 2 * fontSizeScaling;
	            this.ctx.fillText(`${end.name}: ${Util.secondsToTimeString(totalTime / 1000)}`, this.width / 2, this.height * 0.73 - this.height * 0.07 * i);
	        }
	    }
	    sendFrameToWorker() {
	        if (this.bt709) {
	            let imageBuffer = this.ctx.getImageData(0, 0, this.width, this.height).data.buffer;
	            this.worker.postMessage({
	                command: 'imageBuffer',
	                imageBuffer: imageBuffer
	            }, [imageBuffer]);
	        }
	        else {
	            let frame = new VideoFrame(this.ctx.canvas, { timestamp: 1e6 * this.renderedFrames / this.frameRate });
	            this.worker.postMessage({
	                command: 'videoFrame',
	                videoFrame: frame
	            }, [frame]);
	        }
	    }
	    appendToChaptersText() {
	        let time = this.renderedFrames / this.frameRate;
	        this.chaptersText += `${Math.floor(time / 60)}:${Math.floor(time % 60).toString().padStart(2, '0')} - ${this.level.mission.title}`;
	        if (typeof this.currentEntry.runner === 'string')
	            this.chaptersText += ` | ${VideoRenderer.compilation.runners.find(x => x.id === this.currentEntry.runner).name}`;
	        this.chaptersText += '\n';
	    }
	    async waitBeforeRenderingNextFrame() {
	        if (!this.fastMode) {
	            // In slow mode, we wait for the frame to be encoded before we begin generating the next frame. This minimizes strain on the hardware and often prevents WebGL context loss.
	            await new Promise(resolve => this.worker.addEventListener('message', (ev) => {
	                if (ev.data.command === 'videoChunkEncoded')
	                    resolve();
	            }, { once: true }));
	        }
	        else {
	            // In fast mode, we wait a fixed 16 milliseconds between rendering frames. Rendering any faster has little benefit as we're limited by video encoding speed. Also, we might lose the WebGL context.
	            await new Promise(resolve => workerSetTimeout(resolve, 16));
	        }
	    }
	    async renderAudio() {
	        if (this.includeAudio) {
	            let audioContext = this.level.audio.context;
	            let audioBuffer = await audioContext.startRendering();
	            let audioData = this.createAudioData(audioBuffer, this.playbackSpeed);
	            this.worker.postMessage({
	                command: 'audioData',
	                audioData
	            }, [audioData]);
	        }
	    }
	    /** Creates an AudioData object from a given AudioBuffer. Also linearly resamples the audio signals if the playback speed isn't 1. */
	    createAudioData(audioBuffer, playbackSpeed) {
	        let frameCountPerChannel = Math.floor(audioBuffer.length / playbackSpeed);
	        let audioDataData = new Float32Array(frameCountPerChannel * 2);
	        if (playbackSpeed === 1) {
	            // Fast path
	            audioBuffer.copyFromChannel(audioDataData, 0);
	            audioBuffer.copyFromChannel(audioDataData.subarray(frameCountPerChannel), 1);
	        }
	        else {
	            // Linearly resample the audio
	            let channelData = [audioBuffer.getChannelData(0), audioBuffer.getChannelData(1)];
	            for (let i = 0; i < frameCountPerChannel; i++) {
	                let index = i * playbackSpeed;
	                for (let j = 0; j < 2; j++) {
	                    let data = channelData[j];
	                    let valueLow = data[Math.floor(index)];
	                    let valueHigh = data[Math.ceil(index)];
	                    let value = Util.lerp(valueLow, valueHigh, index % 1);
	                    audioDataData[j * frameCountPerChannel + i] = value;
	                }
	            }
	        }
	        let audioData = new AudioData({
	            format: 'f32-planar',
	            sampleRate: OFFLINE_CONTEXT_SAMPLE_RATE,
	            numberOfFrames: frameCountPerChannel,
	            numberOfChannels: 2,
	            timestamp: 0,
	            data: audioDataData
	        });
	        return audioData;
	    }
	    initFinalization() {
	        if (this.stopped)
	            return;
	        // Tell the worker that we're done sending frames
	        this.worker.postMessage({
	            command: 'finishUp'
	        });
	    }
	    async awaitEncoding() {
	        // This varibles lets us make it look like encoding started right when the last frame finished rendering, instead of earlier.
	        let getMinChunkTimestamp = () => Math.min(this.lastVideoChunkTimestamp, this.lastAudioChunkTimestamp);
	        let lastChunkTimestampAtRenderFinish = getMinChunkTimestamp();
	        // This interval updates the progress bar based on the encoding completion
	        this.intervalId = setInterval(() => {
	            let completion = (getMinChunkTimestamp() - lastChunkTimestampAtRenderFinish) / (this.totalTimeUs - lastChunkTimestampAtRenderFinish);
	            VideoRenderer.statusText.textContent = `Encoding (${(100 * completion).toFixed(1)}%)`;
	            VideoRenderer.progressBar.value = 0.8 + 0.2 * completion; // Last 20% of the progress bar
	        }, 16);
	        await new Promise(resolve => this.worker.addEventListener('message', e => e.data === 'closing' && resolve()));
	        clearInterval(this.intervalId);
	    }
	    async finalize() {
	        if (this.stopped)
	            return;
	        // https://twitter.com/sayhello/status/1256498167593361409
	        VideoRenderer.statusText.textContent = 'Writing and checking file... (might take a while)';
	        VideoRenderer.progressBar.value = 1;
	        await new Promise(resolve => this.worker.addEventListener('message', e => e.data === 'done' && resolve()));
	        VideoRenderer.statusText.textContent = `Finalizing...`;
	        VideoRenderer.progressBar.value = 1.0;
	        if (VideoRenderer.chapterFileHandle) {
	            let writable = await VideoRenderer.chapterFileHandle.createWritable();
	            await writable.write(this.chaptersText);
	            await writable.close();
	        }
	        await Util.wait(200); // Fake some work 😂😂😂😂
	        state.menu.showAlertPopup("Rendering complete", "The replay has been successfully rendered to the specified destination video file.");
	    }
	    exitWithError() {
	        let lostContext = mainRenderer.gl.isContextLost();
	        let message;
	        if (lostContext) {
	            // Show a more insightful error message when WebGL context loss was the culprit
	            message = `Your WebGL context has been lost during rendering, meaning that your browser thought the rendering task was too taxing on your hardware. Rendering using parallelized encoding might be the cause of this. Please reload the page to restore the context.`;
	        }
	        else {
	            message = "There has been an error during video rendering.";
	        }
	        state.menu.showAlertPopup("Rendering failed", message);
	        state.level = null;
	        this.stopped = true;
	    }
	    stop() {
	        this.stopped = true;
	        clearInterval(this.intervalId);
	    }
	    async keepScreenAwake() {
	        if (!('wakeLock' in navigator))
	            return;
	        try {
	            this.wakeLock = await navigator.wakeLock.request('screen');
	        }
	        catch (e) { }
	    }
	    releaseWakeLock() {
	        var _b;
	        (_b = this.wakeLock) === null || _b === void 0 ? void 0 : _b.release();
	    }
	}
	const workerBody$1 = () => {
	    let url;
	    let muxer;
	    let videoEncoder;
	    let audioEncoder;
	    let fileWritableStream;
	    let width;
	    let height;
	    let frameRate;
	    let lastVideoKeyFrame = -Infinity;
	    const onSetup = async (data) => {
	        // Set up the writable stream, the WebM writer and video encoder.
	        fileWritableStream = await data.fileHandle.createWritable();
	        width = data.width;
	        height = data.height;
	        frameRate = data.frameRate;
	        const audioSampleRate = 48000;
	        muxer = new WebMMuxer({
	            target: fileWritableStream,
	            video: {
	                codec: 'V_VP9',
	                width: data.width,
	                height: data.height,
	                frameRate: data.frameRate
	            },
	            audio: (data.includeAudio ? {
	                codec: 'A_OPUS',
	                numberOfChannels: 2,
	                sampleRate: audioSampleRate
	            } : undefined)
	        });
	        videoEncoder = new VideoEncoder({
	            output: (chunk, metadata) => {
	                muxer.addVideoChunk(chunk, metadata);
	                if (chunk.type === 'key') {
	                    lastVideoKeyFrame = Math.max(lastVideoKeyFrame, chunk.timestamp);
	                }
	                self.postMessage({
	                    command: 'videoChunkEncoded',
	                    timestamp: chunk.timestamp
	                });
	            },
	            error: e => console.error(e)
	        });
	        videoEncoder.configure({
	            codec: "vp09.00.10.08",
	            width: data.width,
	            height: data.height,
	            bitrate: 1000 * data.kilobitRate,
	            latencyMode: 'realtime'
	        });
	        if (data.includeAudio) {
	            audioEncoder = new AudioEncoder({
	                output: (chunk, metadata) => {
	                    muxer.addAudioChunk(chunk, metadata);
	                    self.postMessage({
	                        command: 'audioChunkEncoded',
	                        timestamp: chunk.timestamp
	                    });
	                },
	                error: e => console.error(e)
	            });
	            audioEncoder.configure({
	                codec: 'opus',
	                numberOfChannels: 2,
	                sampleRate: audioSampleRate,
	                bitrate: 1000 * data.audioKilobitRate
	            });
	        }
	    };
	    let nextTimestamp = 0;
	    const onImageBuffer = (data) => {
	        // Convert RGBA to YUV manually to avoid unwanted color space conversions by the user agent
	        let yuv = RGBAToYUV420({ width, height, data: new Uint8ClampedArray(data.imageBuffer) });
	        let videoFrame = new VideoFrame(yuv, {
	            format: 'I420',
	            codedWidth: width,
	            codedHeight: height,
	            timestamp: nextTimestamp,
	            colorSpace: {
	                matrix: 'bt709',
	                transfer: 'bt709',
	                primaries: 'bt709',
	                fullRange: false
	            }
	        });
	        nextTimestamp += 1e6 / frameRate;
	        encodeVideoFrame(videoFrame);
	    };
	    const encodeVideoFrame = (videoFrame) => {
	        // Force a video key frame every five seconds for better seeking
	        let needsKeyFrame = videoFrame.timestamp - lastVideoKeyFrame >= 5000000;
	        if (needsKeyFrame)
	            lastVideoKeyFrame = videoFrame.timestamp;
	        // Encode a new video frame
	        videoEncoder.encode(videoFrame, { keyFrame: needsKeyFrame });
	        videoFrame.close();
	    };
	    const onAudioData = (data) => {
	        audioEncoder.encode(data.audioData);
	        data.audioData.close();
	    };
	    const finishUp = async () => {
	        // Finishes the remaining work
	        await Promise.all([videoEncoder.flush(), audioEncoder === null || audioEncoder === void 0 ? void 0 : audioEncoder.flush()]);
	        videoEncoder.close();
	        audioEncoder === null || audioEncoder === void 0 ? void 0 : audioEncoder.close();
	        muxer.finalize();
	        self.postMessage('closing');
	        await fileWritableStream.close();
	        self.postMessage('done');
	    };
	    self.onmessage = async (e) => {
	        if (!url) {
	            // The first message received will be the url
	            url = e.data;
	            self.importScripts(url + 'lib/webm.js');
	            self.postMessage('ready');
	            return;
	        }
	        let data = e.data;
	        try {
	            if (data.command === 'setup')
	                await onSetup(data);
	            else if (data.command === 'imageBuffer')
	                onImageBuffer(data);
	            else if (data.command === 'videoFrame')
	                encodeVideoFrame(data.videoFrame);
	            else if (data.command === 'audioData')
	                onAudioData(data);
	            else if (data.command === 'finishUp')
	                await finishUp();
	        }
	        catch (e) {
	            // Bubble up the error
	            self.postMessage({
	                command: 'error',
	                error: e
	            });
	        }
	    };
	    /** Converts RGBA image data into Y'UV 4:2:0 using the BT.709 color space. Width and height have to be even. */
	    const RGBAToYUV420 = ({ width, height, data }) => {
	        let yuv = new Uint8Array(width * height * 1.5);
	        // Using loop tiling as a cache optimization
	        const tileSize = 64;
	        for (let y0 = 0; y0 < height; y0 += tileSize) {
	            for (let x0 = 0; x0 < width; x0 += tileSize) {
	                let limitX = Math.min(width, x0 + tileSize);
	                let limitY = Math.min(height, y0 + tileSize);
	                for (let y = y0; y < limitY; y++) {
	                    for (let x = x0; x < limitX; x++) {
	                        let R = data[4 * (y * width + x) + 0];
	                        let G = data[4 * (y * width + x) + 1];
	                        let B = data[4 * (y * width + x) + 2];
	                        // Uses the matrix given in https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.709_conversion, then adds 128 to the chroma channels, then remaps full range to the condensed, broadcast range (also explained in that article). This entire transformation is condensed into a single matrix, used here:
	                        let Y = 0.182586 * R + 0.614231 * G + 0.0620071 * B + 16;
	                        let U = -0.100668 * R - 0.338547 * G + 0.439216 * B + 128.439;
	                        let V = 0.439216 * R - 0.398984 * G - 0.0426039 * B + 128.439;
	                        yuv[y * width + x] = Y;
	                        if (x % 2 === 0 && y % 2 === 0) {
	                            yuv[1 * width * height + (y * width / 4 + x / 2)] = U;
	                            yuv[1.25 * width * height + (y * width / 4 + x / 2)] = V;
	                        }
	                    }
	                }
	            }
	        }
	        return yuv;
	    };
	};

	class LevelSelect {
	    constructor(menu) {
	        this.setImagesTimeout = null;
	        this.clearImageTimeout = null;
	        this.currentQuery = '';
	        /** The current words in the search query. Used for matching. */
	        this.currentQueryWords = [];
	        this.currentSort = 'chronological';
	        /** Stores data assigned to a replay button to control which replay is played. */
	        this.replayButtonData = new WeakMap();
	        this.fetchingRemoteReplay = false;
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.homeButton, this.homeButtonSrc, () => {
	            this.hide();
	            menu.home.show();
	        }, undefined, undefined, state.modification === 'gold');
	        menu.setupButton(this.prevButton, 'play/prev', (e) => this.cycleMission(-1 * this.computeSeekMultiplier(e)), true, true, state.modification === 'gold', true);
	        menu.setupButton(this.playButton, 'play/play', () => this.playCurrentMission(), true, undefined, state.modification === 'gold');
	        menu.setupButton(this.nextButton, 'play/next', (e) => this.cycleMission(1 * this.computeSeekMultiplier(e)), true, true, state.modification === 'gold', true);
	    }
	    get currentMission() { var _a; return (_a = this.sortedMissionArray) === null || _a === void 0 ? void 0 : _a[this.currentMissionIndex]; }
	    async init() {
	        // Create the elements for the local best times
	        for (let i = 0; i < this.localScoresCount; i++) {
	            let element = this.createScoreElement(async (replayButtonData) => {
	                return await StorageManager.databaseGet('replays', replayButtonData);
	            });
	            this.localBestTimesContainer.appendChild(element);
	        }
	        // Create the elements for the online leaderboard (will be reused)
	        for (let i = 0; i < 18; i++) {
	            let element = this.createScoreElement(async () => {
	                if (this.fetchingRemoteReplay)
	                    return; // Let's wait for the first fetch to finish shall we :)
	                try {
	                    this.fetchingRemoteReplay = true;
	                    let replayDataBlob = await ResourceManager.retryFetch(`./api/world_record_replay?missionPath=${encodeURIComponent(this.currentMission.path)}`);
	                    let buffer = await replayDataBlob.arrayBuffer();
	                    this.fetchingRemoteReplay = false;
	                    return buffer;
	                }
	                catch (e) {
	                    this.fetchingRemoteReplay = false;
	                    return null;
	                }
	            });
	            this.leaderboardScores.appendChild(element);
	        }
	        this.scrollWindow.addEventListener('scroll', () => this.updateOnlineLeaderboard());
	        window.addEventListener('keydown', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'ArrowLeft' && (!this.searchInput.value || document.activeElement === document.body)) {
	                this.cycleMission(-1 * this.computeSeekMultiplier(e));
	                if (!this.prevButton.style.pointerEvents)
	                    this.prevButton.src = this.menu.uiAssetPath + 'play/prev_d.png';
	            }
	            else if (e.code === 'ArrowRight' && (!this.searchInput.value || document.activeElement === document.body)) {
	                this.cycleMission(1 * this.computeSeekMultiplier(e));
	                if (!this.nextButton.style.pointerEvents)
	                    this.nextButton.src = this.menu.uiAssetPath + 'play/next_d.png';
	            }
	            else if (e.code === 'Escape') {
	                this.homeButton.src = this.menu.uiAssetPath + this.homeButtonSrc + '_d.png';
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'ArrowLeft') {
	                if (!this.prevButton.style.pointerEvents)
	                    this.prevButton.src = this.prevButton.hasAttribute('data-hovered') ? this.menu.uiAssetPath + 'play/prev_h.png' : this.menu.uiAssetPath + 'play/prev_n.png';
	            }
	            else if (e.code === 'ArrowRight') {
	                if (!this.nextButton.style.pointerEvents)
	                    this.nextButton.src = this.nextButton.hasAttribute('data-hovered') ? this.menu.uiAssetPath + 'play/next_h.png' : this.menu.uiAssetPath + 'play/next_n.png';
	            }
	            else if (e.code === 'Escape') {
	                this.homeButton.click();
	            }
	        });
	        this.searchInput.addEventListener('input', () => {
	            this.onSearchInputChange();
	        });
	        this.searchInput.addEventListener('focus', () => {
	            // Clear the search when focused
	            this.searchInput.value = '';
	            this.onSearchInputChange();
	        });
	        this.sortToggleButton.addEventListener('mouseenter', () => {
	            mainAudioManager.play('buttonover.wav');
	        });
	        this.sortToggleButton.addEventListener('mousedown', () => {
	            mainAudioManager.play('buttonpress.wav');
	            this.currentSort = this.currentSort === 'lexicographical' ? 'chronological' : 'lexicographical';
	            this.sortToggleButton.src = this.currentSort === 'lexicographical'
	                ? './assets/svg/sort_by_alpha_FILL0_wght400_GRAD0_opsz24.svg'
	                : './assets/svg/event_FILL0_wght400_GRAD0_opsz24.svg';
	            this.sortMissions();
	            this.selectBasedOnSearchQuery(false);
	            this.displayMission();
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        this.displayMission();
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    setMissionArray(arr, doImageTimeout = true) {
	        this.currentMissionArray = arr;
	        this.currentMissionIndex = this.getDefaultMissionIndex();
	        this.sortMissions();
	        this.selectBasedOnSearchQuery(false);
	        this.displayMission(doImageTimeout);
	    }
	    get currentSortFn() {
	        return this.currentSort === 'lexicographical' ? Mission.compareLexicographically : Mission.compareChronologically;
	    }
	    sortMissions() {
	        this.sortedMissionArray = [...this.currentMissionArray].sort(this.currentSortFn);
	    }
	    getDefaultMissionIndex() {
	        var _a;
	        if ([MissionLibrary.goldCustom, MissionLibrary.platinumCustom, MissionLibrary.ultraCustom].includes(this.currentMissionArray)) {
	            // Always select the last custom level by default
	            return this.currentMissionArray.length - 1;
	        }
	        // Select the first level such that it and no other levels after it have local scores, or the last level if that's not possible
	        let last = 0;
	        for (let i = 0; i < this.currentMissionArray.length; i++) {
	            let mission = this.currentMissionArray[i];
	            if ((_a = StorageManager.data.bestTimes[mission.path]) === null || _a === void 0 ? void 0 : _a.length)
	                last = i + 1;
	        }
	        return Math.min(last, this.currentMissionArray.length - 1);
	    }
	    displayMission(doImageTimeout = true) {
	        let mission = this.currentMission;
	        if (!mission) {
	            // There is no mission, so hide most information. In reality, this case should never ever happen.
	            this.levelImage.style.display = 'none';
	            this.playButton.src = this.menu.uiAssetPath + 'play/play_i.png';
	            this.playButton.style.pointerEvents = 'none';
	            this.displayEmptyMetadata();
	            this.displayBestTimes();
	        }
	        else {
	            // Reenable the play button if it was disabled
	            if (this.playButton.style.pointerEvents === 'none') {
	                this.playButton.src = this.menu.uiAssetPath + 'play/play_n.png';
	                this.playButton.style.pointerEvents = '';
	            }
	            this.levelImage.style.display = '';
	            this.displayMetadata();
	            this.displayBestTimes();
	            if (!this.clearImageTimeout)
	                this.clearImageTimeout = setTimeout(() => this.levelImage.src = '', 16); // Clear the image after a very short time (if no image is loaded 'til then)
	        }
	        this.setImages(false, doImageTimeout);
	        this.updateNextPrevButtons();
	        Leaderboard.loadLocal();
	    }
	    playCurrentMission(getReplayData) {
	        if (!this.currentMission)
	            return;
	        this.div.classList.add('hidden');
	        // Initiate level loading
	        this.menu.loadingScreen.loadLevel(this.currentMission, getReplayData ? async () => Replay.fromSerialized(await getReplayData) : undefined);
	    }
	    /** Advance the current mission index by the specified count while respecting the search query. That count can be negative. */
	    cycleMission(direction) {
	        let index = this.getCycleMissionIndex(direction);
	        if (index === null || index === this.currentMissionIndex)
	            return;
	        this.currentMissionIndex = index;
	        this.displayMission();
	    }
	    /** Gets the mission index you would get by skipping a certain amount forwards/backwards while respecting the search query. Returns null if the index would peek outside of the current mission array. */
	    getCycleMissionIndex(direction) {
	        if (direction === 0)
	            return this.currentMissionIndex;
	        let bestResult = null;
	        for (let i = this.currentMissionIndex + Math.sign(direction); i >= 0 && i < this.sortedMissionArray.length && direction !== 0; i += Math.sign(direction)) {
	            let outOfBounds = i < 0 || i >= this.sortedMissionArray.length;
	            i = Util.clamp(i, 0, this.sortedMissionArray.length - 1);
	            if (this.sortedMissionArray[i].matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                direction -= 1 * Math.sign(direction);
	                bestResult = i;
	            }
	            if (outOfBounds) {
	                break;
	            }
	        }
	        return bestResult;
	    }
	    /** Returns true if there is a next mission to go to. */
	    canGoNext() {
	        let canGoNext = false;
	        for (let i = this.currentMissionIndex + 1; i < this.sortedMissionArray.length; i++) {
	            if (this.sortedMissionArray[i].matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                canGoNext = true;
	                break;
	            }
	        }
	        return canGoNext;
	    }
	    /** Returns true if there is a previous mission to go back to. */
	    canGoPrev() {
	        let canGoPrev = false;
	        for (let i = this.currentMissionIndex - 1; i >= 0; i--) {
	            if (this.sortedMissionArray[i].matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                canGoPrev = true;
	                break;
	            }
	        }
	        return canGoPrev;
	    }
	    updateNextPrevButtons() {
	        // Enable or disable the next button based on if there are still missions to come
	        if (!this.canGoNext()) {
	            this.nextButton.src = this.menu.uiAssetPath + 'play/next_i.png';
	            this.nextButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.nextButton.src.endsWith('i.png'))
	                this.nextButton.src = this.menu.uiAssetPath + 'play/next_n.png';
	            this.nextButton.style.pointerEvents = '';
	        }
	        // Enable or disable the prev button based on if there are still missions to come
	        if (!this.canGoPrev()) {
	            this.prevButton.src = this.menu.uiAssetPath + 'play/prev_i.png';
	            this.prevButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.prevButton.src.endsWith('i.png'))
	                this.prevButton.src = this.menu.uiAssetPath + 'play/prev_n.png';
	            this.prevButton.style.pointerEvents = '';
	        }
	    }
	    /** Sets and preloads images around the current level. */
	    setImages(fromTimeout = false, doTimeout = true) {
	        if (fromTimeout) {
	            // We come from a timeout, so clear it
	            clearTimeout(this.setImagesTimeout);
	            this.setImagesTimeout = null;
	        }
	        if (this.setImagesTimeout !== null && doTimeout) {
	            // There is currently a timeout ongoing; reset the timer and return.
	            clearTimeout(this.setImagesTimeout);
	            this.setImagesTimeout = setTimeout(() => this.setImages(true), 75);
	            return;
	        }
	        // List of missions whose image should be loaded
	        let toLoad = new Set();
	        // Preload the neighboring-mission images for faster flicking between missions without having to wait for images to load.
	        for (let i = 0; i <= 10; i++) {
	            let index = this.getCycleMissionIndex(Math.ceil(i / 2) * ((i % 2) ? 1 : -1)); // Go in an outward spiral pattern, but only visit the missions that match the current search
	            let mission = this.sortedMissionArray[index];
	            if (!mission)
	                continue;
	            toLoad.add(mission);
	        }
	        // Preload the next shuffled missions
	        for (let mission of this.getNextShuffledMissions())
	            toLoad.add(mission);
	        for (let mission of toLoad) {
	            let imagePath = mission.getImagePath();
	            let start = performance.now();
	            ResourceManager.loadResource(imagePath).then(async (blob) => {
	                if (!blob)
	                    return;
	                if (mission === this.currentMission) {
	                    // Show the thumbnail if the mission is the same
	                    let dataUrl = await ResourceManager.readBlobAsDataUrl(blob);
	                    if (mission === this.currentMission) {
	                        clearTimeout(this.clearImageTimeout);
	                        this.clearImageTimeout = null;
	                        this.levelImage.src = dataUrl;
	                    }
	                }
	                let elapsed = performance.now() - start;
	                if (elapsed > 75 && !this.setImagesTimeout && doTimeout) {
	                    // If the image took too long to load, set a timeout to prevent spamming requests.
	                    this.setImagesTimeout = setTimeout(() => this.setImages(true), 75);
	                }
	            });
	        }
	    }
	    shuffle() {
	        if (this.sortedMissionArray.length <= 1)
	            return;
	        // Find a random mission that isn't the current one
	        let nextIndex = this.currentMissionIndex;
	        while (nextIndex === this.currentMissionIndex) {
	            nextIndex = Math.floor(Util.popRandomNumber() * this.sortedMissionArray.length);
	        }
	        this.currentMissionIndex = nextIndex;
	        this.displayMission();
	    }
	    /** Returns the next few missions that would be selected by repeating pressing of the shuffle button. */
	    getNextShuffledMissions() {
	        let missions = [];
	        if (this.sortedMissionArray.length > 1) {
	            let lastIndex = this.currentMissionIndex;
	            let i = 0;
	            let count = 0;
	            while (count < 5) {
	                let randomNumber = Util.peekRandomNumber(i++);
	                let nextIndex = Math.floor(randomNumber * this.sortedMissionArray.length);
	                if (lastIndex !== nextIndex) {
	                    let mission = this.sortedMissionArray[nextIndex];
	                    missions.push(mission);
	                    count++;
	                }
	                lastIndex = nextIndex;
	            }
	        }
	        return missions;
	    }
	    displayBestTimes() {
	        var _a;
	        let randomId = Util.getRandomId();
	        this.lastDisplayBestTimesId = randomId;
	        let bestTimes = StorageManager.getBestTimesForMission((_a = this.currentMission) === null || _a === void 0 ? void 0 : _a.path, this.localScoresCount, this.scorePlaceholderName);
	        for (let i = 0; i < this.localScoresCount; i++) {
	            let element = this.localBestTimesContainer.children[i];
	            this.updateScoreElement(this.localBestTimesContainer.children[i], bestTimes[i], i + 1);
	            this.updateReplayButton(this.getReplayButtonForScoreElement(element), bestTimes[i], i + 1, true, false);
	        }
	        if (!this.currentMission) {
	            this.leaderboardLoading.style.display = 'none';
	            this.leaderboardScores.style.paddingTop = '0px';
	            this.leaderboardScores.style.paddingBottom = '0px';
	            for (let element of this.leaderboardScores.children)
	                element.style.display = 'none';
	        }
	        else {
	            this.leaderboardLoading.style.display = Leaderboard.isLoading(this.currentMission.path) ? 'block' : 'none';
	            this.updateOnlineLeaderboard();
	            setTimeout(() => this.updateOnlineLeaderboard()); // Sometimes, scrollTop isn't set properly, so do it again after a very short time
	        }
	    }
	    /** Creates a replay button for use in score elements. */
	    createReplayButton(getReplayData) {
	        let icon = document.createElement('img');
	        icon.src = "./assets/img/round_videocam_black_18dp.png";
	        icon.title = "Alt-Click to download, Shift-Click to render to video";
	        const handler = async (action) => {
	            let mission = this.currentMission;
	            if (!mission)
	                return;
	            let replayDataPromise = getReplayData(this.replayButtonData.get(icon));
	            if (action === 'watch') {
	                this.playCurrentMission(replayDataPromise);
	            }
	            else if (action === 'download') {
	                let replayData = await replayDataPromise;
	                if (!replayData)
	                    return;
	                Replay.download(replayData, mission);
	                if (Util.isTouchDevice && Util.isInFullscreen())
	                    this.menu.showAlertPopup('Downloaded', 'The .wrec has been downloaded.');
	            }
	            else {
	                let replayData = await replayDataPromise;
	                if (!replayData)
	                    return;
	                let replay = Replay.fromSerialized(replayData);
	                VideoRenderer.showForSingleReplay(this.currentMission, replay);
	            }
	        };
	        icon.addEventListener('click', async (e) => {
	            if (e.button !== 0)
	                return;
	            if (e.shiftKey)
	                handler('render');
	            else if (e.altKey)
	                handler('download');
	            else
	                handler('watch');
	        });
	        Util.onLongTouch(icon, () => {
	            handler('download');
	        });
	        icon.addEventListener('mouseenter', () => {
	            mainAudioManager.play('buttonover.wav');
	        });
	        icon.addEventListener('mousedown', (e) => {
	            if (e.button === 0)
	                mainAudioManager.play('buttonpress.wav');
	        });
	        return icon;
	    }
	    async updateReplayButton(element, score, rank, isLocal, hasRemoteReplay) {
	        element.style.display = 'none';
	        this.replayButtonData.delete(element);
	        if (isLocal) {
	            if (!score[2])
	                return;
	            let randomId = this.lastDisplayBestTimesId;
	            let count = await StorageManager.databaseCount('replays', score[2]);
	            if (randomId !== this.lastDisplayBestTimesId || count === 0)
	                return;
	            this.replayButtonData.set(element, score[2]);
	        }
	        else {
	            if (!hasRemoteReplay || rank !== 1)
	                return; // Only show the replay button for the #1 score
	        }
	        element.style.display = 'block';
	    }
	    /** Updates the elements in the online leaderboard. Updates only the visible elements and adds padding to increase performance. */
	    updateOnlineLeaderboard() {
	        var _a;
	        let mission = this.currentMission;
	        if (!mission)
	            return;
	        let onlineScores = (_a = Leaderboard.scores.get(mission.path)) !== null && _a !== void 0 ? _a : [];
	        let elements = this.leaderboardScores.children;
	        let index = 0;
	        // Reset styling
	        this.leaderboardScores.style.paddingTop = '0px';
	        this.leaderboardScores.style.paddingBottom = '0px';
	        elements[index].style.display = 'block';
	        // Get the y of the top element
	        let currentY = elements[0].offsetTop - this.scrollWindow.scrollTop;
	        this.leaderboardScores.style.height = onlineScores.length * this.scoreElementHeight + 'px';
	        // As long as the top element is out of view, move to the next one. By doing this, we find the first element that's in view (from the top)
	        while (currentY < -this.scoreElementHeight && index < onlineScores.length) {
	            index++;
	            currentY += this.scoreElementHeight;
	        }
	        // Add padding to the top according to how many elements we've already passed at the top
	        this.leaderboardScores.style.paddingTop = index * this.scoreElementHeight + 'px';
	        for (let i = 0; i < elements.length; i++) {
	            let element = elements[i];
	            if (index < onlineScores.length) {
	                // If there's a score, apply it to the current element
	                let score = onlineScores[index];
	                element.style.display = 'block';
	                this.updateScoreElement(element, score, index + 1);
	                this.updateReplayButton(this.getReplayButtonForScoreElement(element), score, index + 1, false, score[2]);
	            }
	            else {
	                // Hide the element otherwise
	                element.style.display = 'none';
	            }
	            index++;
	        }
	        // Add padding to the bottom according to how many scores there are still left
	        this.leaderboardScores.style.paddingBottom = Math.max(onlineScores.length - index, 0) * this.scoreElementHeight + 'px';
	    }
	    onSearchInputChange() {
	        // Normalize the search string and split it into words
	        let str = Util.removeSpecialCharacters(Util.normalizeString(this.searchInput.value.trim())).toLowerCase();
	        this.currentQuery = str;
	        this.currentQueryWords = str.split(' ');
	        if (!str)
	            this.currentQueryWords.length = 0;
	        this.selectBasedOnSearchQuery();
	        this.updateNextPrevButtons();
	    }
	    /** Selects a valid mission based on the current search query. */
	    selectBasedOnSearchQuery(display = true) {
	        var _a;
	        // Check if the current mission already matches the search. In that case, don't do anything.
	        if ((_a = this.currentMission) === null || _a === void 0 ? void 0 : _a.matchesSearch(this.currentQueryWords, this.currentQuery))
	            return;
	        // Find the first matching mission
	        for (let i = 0; i < this.sortedMissionArray.length; i++) {
	            let mis = this.sortedMissionArray[i];
	            if (mis.matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                this.currentMissionIndex = i;
	                if (display)
	                    this.displayMission();
	                break;
	            }
	        }
	    }
	    showLoadReplayPrompt(event) {
	        if (event.shiftKey && event.altKey) {
	            this.showCompilationDirectoryPrompt();
	            return;
	        }
	        // Show a file picker
	        let fileInput = document.createElement('input');
	        fileInput.setAttribute('type', 'file');
	        fileInput.setAttribute('accept', ".wrec");
	        fileInput.onchange = async () => {
	            try {
	                let file = fileInput.files[0];
	                let arrayBuffer = await ResourceManager.readBlobAsArrayBuffer(file);
	                let replay = Replay.fromSerialized(arrayBuffer);
	                let mission = MissionLibrary.allMissions.find(x => x.path === replay.missionPath);
	                if (!mission)
	                    throw new Error("Mission not found.");
	                if (state.modification === 'gold' && (mission.path.startsWith('mbp') || mission.path.startsWith('mbu'))) {
	                    // We don't allow this
	                    state.menu.showAlertPopup('Warning', `You can't load replays of ${mission.path.startsWith('mbp') ? 'Platinum' : 'Ultra'} levels inside Marble Blast Gold.`);
	                    return;
	                }
	                if (event.shiftKey) {
	                    VideoRenderer.showForSingleReplay(mission, replay);
	                }
	                else {
	                    this.div.classList.add('hidden');
	                    this.menu.loadingScreen.loadLevel(mission, async () => replay);
	                }
	            }
	            catch (e) {
	                state.menu.showAlertPopup('Error', "There was an error loading the replay.");
	                console.error(e);
	            }
	        };
	        fileInput.click();
	    }
	    async showCompilationDirectoryPrompt() {
	        if (!('showDirectoryPicker' in window) || !('VideoEncoder' in window)) {
	            VideoRenderer.showNotSupportedAlert();
	            return;
	        }
	        let directoryHandle;
	        try {
	            directoryHandle = await window.showDirectoryPicker({
	                mode: 'readwrite'
	            });
	        }
	        catch (e) {
	            return;
	        }
	        VideoRenderer.showForCompilation(directoryHandle);
	    }
	    handleControllerInput(gamepad) {
	        // A button to play
	        if (gamepad.buttons[0].value > 0.5 && !previousButtonState[0]) {
	            this.playCurrentMission();
	            mainAudioManager.play('buttonpress.wav');
	        }
	        // LT, RT to change category
	        if (gamepad.buttons[6].value > 0.5 && !previousButtonState[6]) {
	            // Should probably have a function for this tbh
	            if (this.currentMissionArray === MissionLibrary.goldIntermediate)
	                this.setMissionArray(MissionLibrary.goldBeginner);
	            else if (this.currentMissionArray === MissionLibrary.goldAdvanced)
	                this.setMissionArray(MissionLibrary.goldIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.goldCustom)
	                this.setMissionArray(MissionLibrary.goldAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.platinumBeginner)
	                this.setMissionArray(MissionLibrary.goldCustom);
	            else if (this.currentMissionArray === MissionLibrary.platinumIntermediate)
	                this.setMissionArray(MissionLibrary.platinumBeginner);
	            else if (this.currentMissionArray === MissionLibrary.platinumAdvanced)
	                this.setMissionArray(MissionLibrary.platinumIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.platinumExpert)
	                this.setMissionArray(MissionLibrary.platinumAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.platinumCustom)
	                this.setMissionArray(MissionLibrary.platinumExpert);
	            else if (this.currentMissionArray === MissionLibrary.ultraBeginner)
	                this.setMissionArray(MissionLibrary.platinumCustom);
	            else if (this.currentMissionArray === MissionLibrary.ultraIntermediate)
	                this.setMissionArray(MissionLibrary.ultraBeginner);
	            else if (this.currentMissionArray === MissionLibrary.ultraAdvanced)
	                this.setMissionArray(MissionLibrary.ultraIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.ultraCustom)
	                this.setMissionArray(MissionLibrary.ultraAdvanced);
	            mainAudioManager.play('buttonpress.wav');
	        }
	        if (gamepad.buttons[7].value > 0.5 && !previousButtonState[7]) {
	            // Should probably have a function for this tbh
	            if (this.currentMissionArray === MissionLibrary.goldBeginner)
	                this.setMissionArray(MissionLibrary.goldIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.goldIntermediate)
	                this.setMissionArray(MissionLibrary.goldAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.goldAdvanced)
	                this.setMissionArray(MissionLibrary.goldCustom);
	            else if (this.currentMissionArray === MissionLibrary.goldCustom)
	                this.setMissionArray(MissionLibrary.platinumBeginner);
	            else if (this.currentMissionArray === MissionLibrary.platinumBeginner)
	                this.setMissionArray(MissionLibrary.platinumIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.platinumIntermediate)
	                this.setMissionArray(MissionLibrary.platinumAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.platinumAdvanced)
	                this.setMissionArray(MissionLibrary.platinumExpert);
	            else if (this.currentMissionArray === MissionLibrary.platinumExpert)
	                this.setMissionArray(MissionLibrary.platinumCustom);
	            else if (this.currentMissionArray === MissionLibrary.platinumCustom)
	                this.setMissionArray(MissionLibrary.ultraBeginner);
	            else if (this.currentMissionArray === MissionLibrary.ultraBeginner)
	                this.setMissionArray(MissionLibrary.ultraIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.ultraIntermediate)
	                this.setMissionArray(MissionLibrary.ultraAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.ultraAdvanced)
	                this.setMissionArray(MissionLibrary.ultraCustom);
	            mainAudioManager.play('buttonpress.wav');
	        }
	        // D-pad left+right to change missions
	        if (gamepad.buttons[14].value > 0.5 && !previousButtonState[14]) {
	            this.cycleMission(-1);
	            mainAudioManager.play('buttonpress.wav');
	        }
	        if (gamepad.buttons[15].value > 0.5 && !previousButtonState[15]) {
	            this.cycleMission(1);
	            mainAudioManager.play('buttonpress.wav');
	        }
	    }
	    computeSeekMultiplier(event) {
	        return event.ctrlKey ? 100 : event.shiftKey ? 10 : 1;
	    }
	}

	class MbgLevelSelect extends LevelSelect {
	    constructor() {
	        super(...arguments);
	        this.localScoresCount = 3;
	        this.scorePlaceholderName = "Nardo Polo";
	        this.scoreElementHeight = 14;
	    }
	    initProperties() {
	        this.div = document.querySelector('#level-select');
	        this.homeButton = document.querySelector('#level-select-home-button');
	        this.homeButtonSrc = 'play/back';
	        this.tabBeginner = document.querySelector('#tab-beginner');
	        this.tabIntermediate = document.querySelector('#tab-intermediate');
	        this.tabAdvanced = document.querySelector('#tab-advanced');
	        this.tabCustom = document.querySelector('#tab-custom');
	        this.scrollWindow = document.querySelector('#level-select-text-window-scrollable');
	        this.levelTitle = document.querySelector('#level-title');
	        this.levelArtist = document.querySelector('#level-artist');
	        this.levelDescription = document.querySelector('#level-description');
	        this.levelQualifyTime = document.querySelector('#level-qualify-time');
	        this.localBestTimesContainer = document.querySelector('#level-select-local-best-times');
	        this.leaderboardLoading = document.querySelector('#online-leaderboard-loading');
	        this.leaderboardScores = document.querySelector('#leaderboard-scores');
	        this.levelImage = document.querySelector('#level-image');
	        this.levelNumberElement = document.querySelector('#level-number');
	        this.prevButton = document.querySelector('#level-select-prev');
	        this.playButton = document.querySelector('#level-select-play');
	        this.nextButton = document.querySelector('#level-select-next');
	        this.searchInput = document.querySelector('#search-input');
	        this.sortToggleButton = document.querySelector('#sort-icon');
	        this.loadReplayButton = document.querySelector('#load-replay-button');
	        this.shuffleButton = document.querySelector('#shuffle-button');
	    }
	    async init() {
	        await super.init();
	        const setupTab = (element, levels) => {
	            element.addEventListener('mousedown', (e) => {
	                if (e.button !== 0)
	                    return;
	                mainAudioManager.play('buttonpress.wav');
	            });
	            element.addEventListener('click', (e) => e.button === 0 && this.setMissionArray(levels));
	        };
	        setupTab(this.tabBeginner, MissionLibrary.goldBeginner);
	        setupTab(this.tabIntermediate, MissionLibrary.goldIntermediate);
	        setupTab(this.tabAdvanced, MissionLibrary.goldAdvanced);
	        setupTab(this.tabCustom, MissionLibrary.goldCustom);
	        this.loadReplayButton.addEventListener('click', async (e) => {
	            this.showLoadReplayPrompt(e);
	        });
	        this.loadReplayButton.addEventListener('mouseenter', () => {
	            mainAudioManager.play('buttonover.wav');
	        });
	        this.loadReplayButton.addEventListener('mousedown', (e) => {
	            if (e.button === 0)
	                mainAudioManager.play('buttonpress.wav');
	        });
	        this.shuffleButton.addEventListener('click', () => {
	            this.shuffle();
	        });
	        this.shuffleButton.addEventListener('mouseenter', () => {
	            mainAudioManager.play('buttonover.wav');
	        });
	        this.shuffleButton.addEventListener('mousedown', (e) => {
	            if (e.button === 0)
	                mainAudioManager.play('buttonpress.wav');
	        });
	        // Preload images and leaderboards
	        this.setMissionArray(MissionLibrary.goldCustom, false); // Make sure to disable the image timeouts so that no funky stuff happens
	        this.setMissionArray(MissionLibrary.goldAdvanced, false);
	        this.setMissionArray(MissionLibrary.goldIntermediate, false);
	        this.setMissionArray(MissionLibrary.goldBeginner, false);
	    }
	    setMissionArray(arr, doImageTimeout) {
	        super.setMissionArray(arr, doImageTimeout);
	        for (let elem of [this.tabBeginner, this.tabIntermediate, this.tabAdvanced, this.tabCustom]) {
	            elem.style.zIndex = "-1";
	        }
	        let index = [MissionLibrary.goldBeginner, MissionLibrary.goldIntermediate, MissionLibrary.goldAdvanced, MissionLibrary.goldCustom].indexOf(this.currentMissionArray);
	        let elem = [this.tabBeginner, this.tabIntermediate, this.tabAdvanced, this.tabCustom][index];
	        elem.style.zIndex = "0"; // Bring the tab to the front
	    }
	    displayMetadata() {
	        let mission = this.currentMission;
	        this.levelTitle.textContent = mission.title;
	        this.levelArtist.textContent = 'by ' + mission.artist.trim();
	        this.levelArtist.style.display = (mission.type === 'custom') ? 'block' : 'none'; // Only show the artist for custom levels
	        this.levelDescription.textContent = mission.description;
	        let qualifyTime = (mission.qualifyTime !== 0) ? mission.qualifyTime : Infinity;
	        this.levelQualifyTime.textContent = isFinite(qualifyTime) ? "Time to Qualify: " + Util.secondsToTimeString(qualifyTime / 1000) : '';
	        this.levelNumberElement.textContent = `${Util.uppercaseFirstLetter(mission.type)} Level ${this.currentMissionIndex + 1}`;
	    }
	    displayEmptyMetadata() {
	        this.levelTitle.innerHTML = '<br>';
	        this.levelArtist.style.display = 'none';
	        this.levelDescription.innerHTML = '<br>';
	        this.levelQualifyTime.innerHTML = '';
	        this.levelNumberElement.textContent = `Level ${this.currentMissionIndex + 1}`;
	    }
	    createScoreElement(getReplayData) {
	        let element = document.createElement('div');
	        element.classList.add('level-select-best-time');
	        let name = document.createElement('div');
	        element.appendChild(name);
	        let img = document.createElement('img');
	        img.src = "./assets/ui/play/goldscore.png";
	        element.appendChild(img);
	        let time = document.createElement('div');
	        element.appendChild(time);
	        element.appendChild(this.createReplayButton(getReplayData));
	        return element;
	    }
	    getReplayButtonForScoreElement(element) {
	        return element.children[3];
	    }
	    updateScoreElement(element, score, rank) {
	        let goldTime = 0;
	        let mission = this.currentMission;
	        if (mission)
	            goldTime = mission.goldTime;
	        element.children[0].textContent = rank + '. ' + score[0];
	        element.children[1].style.opacity = (score[1] <= goldTime) ? '' : '0';
	        element.children[2].textContent = Util.secondsToTimeString(score[1] / 1000);
	    }
	}

	class HomeScreen {
	    constructor(menu) {
	        this.initProperties();
	        menu.setupButton(this.playButton, this.playSrc, () => {
	            // Show the level select
	            this.hide();
	            menu.levelSelect.show();
	            Leaderboard.syncLeaderboard();
	        });
	        menu.setupButton(this.helpButton, this.helpSrc, () => {
	            // Show the help screen
	            this.hide();
	            menu.helpScreen.show();
	        }, undefined, undefined, state.modification === 'gold');
	        menu.setupButton(this.optionsButton, this.optionsSrc, () => {
	            // Show the options screen
	            this.hide();
	            menu.optionsScreen.show();
	        });
	        menu.setupButton(this.exitButton, this.exitSrc, () => {
	            window.close(); // Won't work unless PWA
	            if (!location.search.includes('app'))
	                location.href = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'; // Internet veterans will recognize this link
	        });
	        menu.setupButton(this.showChangelogButton, this.showChangelogSrc, () => {
	            this.changelogContainer.classList.remove('hidden');
	        }, undefined, undefined, state.modification === 'gold');
	        menu.setupButton(this.changelogBackButton, this.changelogBackSrc, () => {
	            this.changelogContainer.classList.add('hidden');
	        });
	        this.div.querySelector('.modification-switcher').addEventListener('click', () => {
	            setMenu((state.modification === 'gold') ? 'platinum' : 'gold');
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    async init() {
	        // Fetch and display the version history
	        let blob = await ResourceManager.loadResource('/api/version_history');
	        let text = await ResourceManager.readBlobAsText(blob);
	        let latestVersion = /(^|\n)## (\d+\.\d+\.\d+)/.exec(text)[2];
	        this.version.textContent = `MBW v${latestVersion}`;
	        if (Util.isTouchDevice) {
	            // Make sure it's not occluded by rounded corners
	            this.version.style.left = '15px';
	            this.version.style.bottom = '15px';
	        }
	        let classPrefix = (state.modification === 'gold') ? 'changelog' : 'mbp-changelog';
	        // Cheap conversion from markdown to HTML here
	        text = text.replace(/(^|\n)# (.*)/g, `$1<span class="${classPrefix}-h1">$2</span>`);
	        text = text.replace(/(^|\n)## (.*)/g, `$1<span class="${classPrefix}-h2">$2</span>`);
	        text = text.replace(/(^|\n)### (.*)/g, `$1<span class="${classPrefix}-h3">$2</span>`);
	        text = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
	        text = text.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank">$1</a>');
	        this.changelogContent.innerHTML = text;
	        // Decide if we should show the changelog on startup
	        if (StorageManager.data.lastSeenVersion) {
	            //let bigger = Util.compareVersions(latestVersion, StorageManager.data.lastSeenVersion) > 0;
	            let different = latestVersion !== StorageManager.data.lastSeenVersion;
	            if (different) {
	                // There's a newer version, go show the changes!
	                this.changelogContainer.classList.remove('hidden');
	                await StorageManager.onVersionUpgrade(StorageManager.data.lastSeenVersion);
	            }
	        }
	        else if (Object.keys(StorageManager.data.bestTimes).length > 0 || StorageManager.hadOldDatabase) {
	            // We assume that if there's at least one local score, the user has interacted with the website to an extent where we can show the changelog.
	            this.changelogContainer.classList.remove('hidden');
	        }
	        StorageManager.data.lastSeenVersion = latestVersion;
	        StorageManager.store();
	    }
	}

	class MbgHomeScreen extends HomeScreen {
	    initProperties() {
	        this.div = document.querySelector('#home-screen');
	        this.playButton = document.querySelector('#home-play');
	        this.optionsButton = document.querySelector('#home-options');
	        this.helpButton = document.querySelector('#home-help');
	        this.exitButton = document.querySelector('#home-exit');
	        this.showChangelogButton = document.querySelector('#show-changelog');
	        this.showChangelogText = document.querySelector('#show-changelog-text');
	        this.changelogContainer = document.querySelector('#changelog');
	        this.changelogBackButton = document.querySelector('#changelog-back');
	        this.changelogContent = document.querySelector('#changelog-content');
	        this.version = document.querySelector('#version');
	        this.playSrc = 'home/play';
	        this.optionsSrc = 'home/options';
	        this.helpSrc = 'home/help';
	        this.exitSrc = 'home/exit';
	        this.showChangelogSrc = 'motd/motd_buttn_textless';
	        this.changelogBackSrc = 'play/back';
	    }
	}

	class Menu {
	    constructor() {
	        this.gameUiDiv = document.querySelector('#game-ui');
	        this.popupContainer = document.querySelector('#popup-container');
	        this.activeButtonVariant = new Map();
	        this.variantChangeListeners = new Map();
	        this.menuDiv = this.getMenuDiv();
	        this.backgroundImage = this.getBackgroundImage();
	        this.home = this.createHome();
	        this.levelSelect = this.createLevelSelect();
	        this.loadingScreen = this.createLoadingScreen();
	        this.optionsScreen = this.createOptionsScreen();
	        this.helpScreen = this.createHelpScreen();
	        this.hud = this.createHud();
	        this.pauseScreen = this.createPauseScreen();
	        this.finishScreen = this.createFinishScreen();
	    }
	    /** Sets up a Torque GUI button element which can take on different variants and switch between them quickly. */
	    setupVaryingButton(element, paths, onclick, loadDisabledImage = false, triggerOnMouseDown = false, playHoverSound = true, rapidFireOnHold = false) {
	        let ogPaths = paths.slice();
	        paths = paths.map(x => this.uiAssetPath + x);
	        let held = false;
	        let hovered = false;
	        let rapidFireId;
	        const normal = () => paths[this.activeButtonVariant.get(element)] + '_n.png';
	        const hover = () => paths[this.activeButtonVariant.get(element)] + '_h.png';
	        const down = () => paths[this.activeButtonVariant.get(element)] + '_d.png';
	        const disabled = () => paths[this.activeButtonVariant.get(element)] + '_i.png';
	        /** Returns true iff the mouse is currently in the bounding box of this button. */
	        const touchInAabb = () => {
	            let radius = 10; // Reasonable guesstimate
	            let x = currentMousePosition.x / SCALING_RATIO;
	            let y = currentMousePosition.y / SCALING_RATIO;
	            let rect = element.getBoundingClientRect();
	            return x >= rect.x - radius && x < rect.x + rect.width + radius && y >= rect.y - radius && y < rect.y + rect.height + radius;
	        };
	        element.addEventListener('mouseenter', () => {
	            if (Util.isTouchDevice)
	                return;
	            hovered = true;
	            element.setAttribute('data-hovered', '');
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = held ? down() : hover();
	            if (!held && playHoverSound)
	                mainAudioManager.play('buttonover.wav');
	        });
	        element.addEventListener('mouseleave', () => {
	            if (Util.isTouchDevice)
	                return;
	            hovered = false;
	            element.removeAttribute('data-hovered');
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = normal();
	        });
	        element.addEventListener('touchmove', () => {
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = touchInAabb() ? down() : normal();
	        });
	        const onMouseDown = (e) => {
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (e.button !== 0)
	                return;
	            held = true;
	            if (!element.hasAttribute('data-locked'))
	                element.src = down();
	            mainAudioManager.play('buttonpress.wav');
	            if (triggerOnMouseDown) {
	                onclick(e);
	                if (rapidFireOnHold)
	                    rapidFireId = setTimeout(() => rapidFireId = setInterval(() => onclick(e), 30), 500);
	            }
	            window.addEventListener('mouseup', onMouseUp);
	            window.addEventListener('touchend', onTouchEnd);
	        };
	        element.addEventListener('mousedown', (e) => {
	            if (!Util.isTouchDevice)
	                onMouseDown(e);
	        });
	        element.addEventListener('touchstart', () => {
	            onMouseDown({ button: 0 });
	        });
	        const onMouseUp = () => {
	            held = false;
	            clearTimeout(rapidFireId);
	            clearInterval(rapidFireId);
	            // Remove the listeners to increase performance
	            window.removeEventListener('mouseup', onMouseUp);
	            window.removeEventListener('touchend', onTouchEnd);
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = hovered ? hover() : normal();
	        };
	        const onTouchEnd = (e) => {
	            if (held && !triggerOnMouseDown && touchInAabb()) {
	                onclick(e);
	            }
	            onMouseUp();
	        };
	        if (!triggerOnMouseDown)
	            element.addEventListener('click', (e) => {
	                if (e.isTrusted && (Util.isTouchDevice && 'ontouchstart' in window))
	                    return; // Do the extra check here to make sure people don't nuke themselves with options
	                if (e.button === 0)
	                    onclick(e);
	            });
	        for (let ogPath of ogPaths) {
	            if (!ogPath)
	                continue;
	            // Preload the images
	            this.activeButtonVariant.set(element, ogPaths.indexOf(ogPath));
	            ResourceManager.loadImage(normal());
	            ResourceManager.loadImage(hover());
	            ResourceManager.loadImage(down());
	            if (loadDisabledImage)
	                ResourceManager.loadImage(disabled());
	        }
	        const onVariantChange = () => {
	            if (held)
	                element.src = down();
	            else if (hovered)
	                element.src = hover();
	            else
	                element.src = normal();
	        };
	        this.variantChangeListeners.set(element, onVariantChange);
	        this.setButtonVariant(element, 0); // This will also set the button's default image
	    }
	    /** Sets up a Torque GUI button element. Adds listeners to show the correct _n, _d and _h variants and plays sounds. */
	    setupButton(element, path, onclick, loadDisabledImage, triggerOnMouseDown, playHoverSound, radidFireOnHold) {
	        this.setupVaryingButton(element, [path], onclick, loadDisabledImage, triggerOnMouseDown, playHoverSound, radidFireOnHold);
	    }
	    /** Sets the active button variant for a given button. */
	    setButtonVariant(element, index) {
	        this.activeButtonVariant.set(element, index);
	        this.variantChangeListeners.get(element)();
	    }
	    show() {
	        mainAudioManager.setAssetPath(this.audioAssetPath);
	        this.menuDiv.classList.remove('hidden');
	        setEnterFullscreenButtonVisibility(true);
	        if (Util.isWeeb) {
	            let before = mainAudioManager.assetPath;
	            mainAudioManager.assetPath = ''; // Quick hack
	            this.music = mainAudioManager.createAudioSource('./assets/music/renai.ogg', mainAudioManager.musicGain);
	            mainAudioManager.assetPath = before;
	        }
	        else {
	            this.music = mainAudioManager.createAudioSource(this.menuMusicSrc, mainAudioManager.musicGain);
	        }
	        this.music.setLoop(true);
	        this.music.play();
	        // These lines will just make the container visible forever after the page loading screen is passed
	        this.popupContainer.style.visibility = 'visible';
	        this.popupContainer.style.pointerEvents = 'auto';
	    }
	    hide() {
	        var _a;
	        this.menuDiv.classList.add('hidden');
	        (_a = this.music) === null || _a === void 0 ? void 0 : _a.stop();
	        setEnterFullscreenButtonVisibility(false);
	    }
	    showGameUi() {
	        this.gameUiDiv.classList.remove('hidden');
	    }
	    hideGameUi() {
	        this.gameUiDiv.classList.add('hidden');
	    }
	    createAlertBase(heading, body, custom) {
	        let div = document.createElement('div');
	        div.classList.add('hidden');
	        div.classList.add('popup');
	        div.classList.add((state.modification === 'gold') ? 'mbg' : 'mbp');
	        let clickPreventer = document.createElement('div');
	        let img = document.createElement('img');
	        img.onload = () => {
	            div.style.width = ((state.modification === 'gold') ? 400 : img.width) + 'px';
	            div.style.height = ((state.modification === 'gold') ? 250 : img.height) + 'px';
	            img.style.width = div.style.width;
	            img.style.height = div.style.height;
	            div.classList.remove('hidden');
	        };
	        img.src = this.popupBackgroundSrc;
	        let headingElem = document.createElement('p');
	        headingElem.classList.add('_heading');
	        headingElem.innerHTML = heading;
	        let bodyElem = document.createElement('p');
	        bodyElem.classList.add('_body');
	        bodyElem.innerHTML = body;
	        bodyElem.innerHTML = bodyElem.innerHTML.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank">$1</a>');
	        div.append(clickPreventer, img, headingElem, bodyElem);
	        if (custom) {
	            custom.classList.add('_custom');
	            // Timeout to let text get layouted (couldn't get it to work otherwise)
	            setTimeout(() => {
	                custom.style.top = 44 + bodyElem.clientHeight + 'px';
	                div.append(custom);
	            });
	        }
	        return div;
	    }
	    /** Shows a customizable alert pop-up on screen that the user can dismiss. */
	    showAlertPopup(heading, body, custom) {
	        return new Promise(resolve => {
	            let div = this.createAlertBase(heading, body, custom);
	            let okayButton = document.createElement('img');
	            okayButton.classList.add('_okay');
	            this.setupButton(okayButton, this.popupOkaySrc, () => {
	                this.popupContainer.removeChild(div);
	                if (this.popupContainer.children.length === 0)
	                    this.popupContainer.style.display = 'none';
	                window.removeEventListener('keydown', handler1);
	                window.removeEventListener('keyup', handler2);
	                resolve();
	            });
	            let handler1 = (e) => {
	                if (e.key === 'Escape')
	                    okayButton.src = this.uiAssetPath + this.popupOkaySrc + '_d.png';
	            };
	            let handler2 = (e) => {
	                if (e.key === 'Escape')
	                    okayButton.click();
	            };
	            window.addEventListener('keydown', handler1);
	            window.addEventListener('keyup', handler2);
	            div.append(okayButton);
	            this.popupContainer.append(div);
	            this.popupContainer.style.display = '';
	        });
	    }
	    /** Shows a customizable confirm (yes/no) pop-up on screen. */
	    showConfirmPopup(heading, body, custom) {
	        return new Promise(resolve => {
	            let div = this.createAlertBase(heading, body, custom);
	            let noButton = document.createElement('img');
	            noButton.classList.add('_no');
	            this.setupButton(noButton, this.popupNoSrc, () => {
	                this.popupContainer.removeChild(div);
	                if (this.popupContainer.children.length === 0)
	                    this.popupContainer.style.display = 'none';
	                window.removeEventListener('keydown', handler1);
	                window.removeEventListener('keyup', handler2);
	                resolve(false);
	            });
	            let yesButton = document.createElement('img');
	            yesButton.classList.add('_yes');
	            this.setupButton(yesButton, this.popupYesSrc, () => {
	                this.popupContainer.removeChild(div);
	                if (this.popupContainer.children.length === 0)
	                    this.popupContainer.style.display = 'none';
	                window.removeEventListener('keydown', handler1);
	                window.removeEventListener('keyup', handler2);
	                resolve(true);
	            });
	            let handler1 = (e) => {
	                if (e.key === 'Escape')
	                    noButton.src = this.uiAssetPath + this.popupNoSrc + '_d.png';
	            };
	            let handler2 = (e) => {
	                if (e.key === 'Escape')
	                    noButton.click();
	            };
	            window.addEventListener('keydown', handler1);
	            window.addEventListener('keyup', handler2);
	            div.append(noButton, yesButton);
	            this.popupContainer.append(div);
	            this.popupContainer.style.display = '';
	        });
	    }
	    async init() {
	        mainAudioManager.setAssetPath(this.audioAssetPath);
	        await mainAudioManager.loadBuffers([this.menuMusicSrc, 'buttonover.wav', 'buttonpress.wav']);
	        await Promise.all([this.home.init(), this.levelSelect.init(), this.finishScreen.init(), this.optionsScreen.init(), this.helpScreen.init()]);
	        // Load pop-up stuff:
	        await ResourceManager.loadImages([this.popupBackgroundSrc]);
	        let dummy = document.createElement('img');
	        this.setupButton(dummy, this.popupOkaySrc, null);
	        this.setupButton(dummy, this.popupNoSrc, null);
	        this.setupButton(dummy, this.popupYesSrc, null);
	        this.home.show();
	    }
	}

	class LoadingScreen {
	    constructor(menu) {
	        this.loadingIndex = 0;
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.cancelButton, 'loading/cancel', () => {
	            // Cancel the loading progress and return to level select
	            this.hide();
	            menu.levelSelect.show();
	            this.loadingIndex++;
	            clearInterval(this.refresher);
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    async loadLevel(mission, getReplay) {
	        this.show();
	        let indexAtStart = this.loadingIndex; // Remember the index at the start. If it changes later, that means that loading was cancelled.
	        this.levelNameElement.textContent = mission.title;
	        this.progressBar.style.width = '0px';
	        // Give the UI a bit of time to breathe before we begin to load the level.
	        await Util.wait(50);
	        try {
	            // Fire off replay fetching right at the start
	            let replayPromise = getReplay ? getReplay() : Promise.resolve();
	            await mission.load();
	            if (this.loadingIndex !== indexAtStart)
	                return;
	            this.refresher = setInterval(() => {
	                // Constantly refresh the loading bar's width
	                let completion = level.getLoadingCompletion();
	                this.progressBar.style.width = (completion * this.maxProgressBarWidth) + 'px';
	            });
	            let level = new Level(mission);
	            state.level = level;
	            await level.init();
	            let replay = await replayPromise;
	            if (replay) {
	                level.replay = replay;
	                replay.level = level;
	                replay.mode = 'playback';
	            }
	            if (this.loadingIndex !== indexAtStart) {
	                level.dispose();
	                return;
	            }
	            clearInterval(this.refresher);
	            // Fake some second loading pass
	            let start = performance.now();
	            this.refresher = setInterval(() => {
	                let completion = Util.clamp((performance.now() - start) / 100, 0, 1);
	                this.progressBar.style.width = (completion * this.maxProgressBarWidth) + 'px';
	            });
	            await Util.wait(150);
	            if (this.loadingIndex !== indexAtStart) {
	                level.dispose();
	                return;
	            }
	            clearInterval(this.refresher);
	            // Loading has finished, hop into gameplay.
	            level.start();
	            this.hide();
	            this.menu.hide();
	            this.menu.showGameUi();
	        }
	        catch (e) {
	            console.error(e);
	            this.cancelButton.click();
	            state.level = null;
	            state.menu.showAlertPopup('Error', "There was an error due to which the level couldn't be loaded.");
	        }
	    }
	}

	class MbgLoadingScreen extends LoadingScreen {
	    constructor() {
	        super(...arguments);
	        this.maxProgressBarWidth = 252;
	    }
	    initProperties() {
	        this.div = document.querySelector('#loading');
	        this.levelNameElement = document.querySelector('#loading-level-name');
	        this.cancelButton = document.querySelector('#loading-cancel');
	        this.progressBar = document.querySelector('#loading-progress');
	    }
	}

	class MbgOptionsScreen extends OptionsScreen {
	    constructor(menu) {
	        super(menu);
	        this.trackLength = 235; // The total draggable length of the slider
	        this.musicVolumeKnobLeft = 155; // The left-most position of the knob
	        this.soundVolumeKnobLeft = 157;
	        this.mouseSensitivityKnobLeft = 148;
	        this.draggingMusicVolume = false;
	        this.draggingSoundVolume = false;
	        this.draggingMouseSensitivity = false;
	        this.soundTestingSound = null;
	        menu.setupButton(this.resolution640, 'options/graf640', () => this.selectResolutionButton(this.resolution640, 0));
	        menu.setupButton(this.resolution800, 'options/graf800', () => this.selectResolutionButton(this.resolution800, 1));
	        menu.setupButton(this.resolution1024, 'options/graf1024', () => this.selectResolutionButton(this.resolution1024, 2));
	        menu.setupButton(this.openGl, 'options/grafopgl', () => this.selectVideoDriverButton(this.openGl, 0));
	        menu.setupButton(this.direct3D, 'options/grafdir3d', () => this.selectVideoDriverButton(this.direct3D, 1));
	        menu.setupButton(this.windowedButton, 'options/grafwindo', () => this.selectScreenStyleButton(this.windowedButton, 0));
	        menu.setupButton(this.fullButton, 'options/grafful', () => this.selectScreenStyleButton(this.fullButton, 1));
	        menu.setupButton(this.depth16, 'options/graf16bt', () => this.selectColorDepthButton(this.depth16, 0));
	        menu.setupButton(this.depth32, 'options/graf32bt', () => this.selectColorDepthButton(this.depth32, 1));
	        menu.setupButton(this.shadowsCheckbox, 'options/graf_chkbx', () => {
	            StorageManager.data.settings.shadows = !this.shadowsCheckbox.hasAttribute('data-locked');
	            StorageManager.store();
	            // Toggle the checkbox
	            if (!this.shadowsCheckbox.hasAttribute('data-locked')) {
	                this.shadowsCheckbox.setAttribute('data-locked', '');
	                this.shadowsCheckbox.src = './assets/ui/options/graf_chkbx_d.png';
	            }
	            else {
	                this.shadowsCheckbox.removeAttribute('data-locked');
	                this.shadowsCheckbox.src = './assets/ui/options/graf_chkbx_h.png';
	            }
	        });
	        menu.setupButton(this.graphicsApply, 'options/grafapply', () => { });
	        const handler = () => {
	            if (!this.draggingMusicVolume && !this.draggingSoundVolume && !this.draggingMouseSensitivity)
	                return;
	            // Release all dragging things
	            this.draggingMusicVolume = this.draggingSoundVolume = this.draggingMouseSensitivity = false;
	            StorageManager.store();
	            if (this.soundTestingSound) {
	                // Stop the sound
	                this.soundTestingSound.stop();
	                this.soundTestingSound = null;
	            }
	        };
	        window.addEventListener('mouseup', handler);
	        window.addEventListener('touchend', handler);
	        this.musicVolumeTrack.addEventListener('mousedown', () => this.draggingMusicVolume = true);
	        this.musicVolumeTrack.addEventListener('touchstart', () => this.draggingMusicVolume = true);
	        this.musicVolumeKnob.addEventListener('mousedown', () => this.draggingMusicVolume = true);
	        this.musicVolumeKnob.addEventListener('touchstart', () => this.draggingMusicVolume = true);
	        this.soundVolumeTrack.addEventListener('mousedown', () => this.draggingSoundVolume = true);
	        this.soundVolumeTrack.addEventListener('touchstart', () => this.draggingSoundVolume = true);
	        this.soundVolumeKnob.addEventListener('mousedown', () => this.draggingSoundVolume = true);
	        this.soundVolumeKnob.addEventListener('touchstart', () => this.draggingSoundVolume = true);
	        requestAnimationFrame(() => this.updateSliders());
	        menu.setupButton(this.marbleTab, '', () => this.selectControlsTab('marble'));
	        menu.setupButton(this.cameraTab, '', () => this.selectControlsTab('camera'));
	        menu.setupButton(this.mouseTab, '', () => this.selectControlsTab('mouse'));
	        menu.setupButton(this.buttonMarbleLeft, 'options/cntr_mrb_lft', () => this.changeKeybinding('left'));
	        menu.setupButton(this.buttonMarbleRight, 'options/cntr_mrb_rt', () => this.changeKeybinding('right'));
	        menu.setupButton(this.buttonMarbleUp, 'options/cntr_mrb_fw', () => this.changeKeybinding('up'));
	        menu.setupButton(this.buttonMarbleDown, 'options/cntr_mrb_bak', () => this.changeKeybinding('down'));
	        menu.setupButton(this.buttonMarbleUse, 'options/cntr_mrb_pwr', () => this.changeKeybinding('use'));
	        menu.setupButton(this.buttonMarbleJump, 'options/cntr_mrb_jmp', () => this.changeKeybinding('jump'));
	        menu.setupButton(this.buttonCameraLeft, 'options/cntr_cam_lft', () => this.changeKeybinding('cameraLeft'));
	        menu.setupButton(this.buttonCameraRight, 'options/cntr_cam_rt', () => this.changeKeybinding('cameraRight'));
	        menu.setupButton(this.buttonCameraUp, 'options/cntr_cam_up', () => this.changeKeybinding('cameraUp'));
	        menu.setupButton(this.buttonCameraDown, 'options/cntr_cam_dwn', () => this.changeKeybinding('cameraDown'));
	        this.mouseSensitivityKnob.addEventListener('mousedown', () => this.draggingMouseSensitivity = true);
	        this.mouseSensitivityKnob.addEventListener('touchstart', () => this.draggingMouseSensitivity = true);
	        menu.setupButton(this.invertY, 'options/cntrl_mous_invrt', () => {
	            StorageManager.data.settings.invertMouse &= ~0b10;
	            StorageManager.data.settings.invertMouse |= Number(!this.invertY.hasAttribute('data-locked')) << 1;
	            StorageManager.store();
	            // Toggle the checkbox
	            if (!this.invertY.hasAttribute('data-locked')) {
	                this.invertY.setAttribute('data-locked', '');
	                this.invertY.src = './assets/ui/options/cntrl_mous_invrt_d.png';
	            }
	            else {
	                this.invertY.removeAttribute('data-locked');
	                this.invertY.src = './assets/ui/options/cntrl_mous_invrt_h.png';
	            }
	        });
	        menu.setupButton(this.alwaysFreeLook, 'options/cntrl_mous_freel', () => {
	            StorageManager.data.settings.alwaysFreeLook = !this.alwaysFreeLook.hasAttribute('data-locked');
	            StorageManager.store();
	            // Toggle the checkbox
	            if (!this.alwaysFreeLook.hasAttribute('data-locked')) {
	                this.alwaysFreeLook.setAttribute('data-locked', '');
	                this.alwaysFreeLook.src = './assets/ui/options/cntrl_mous_freel_d.png';
	            }
	            else {
	                this.alwaysFreeLook.removeAttribute('data-locked');
	                this.alwaysFreeLook.src = './assets/ui/options/cntrl_mous_freel_h.png';
	            }
	        });
	        menu.setupButton(this.freeLookKey, 'options/cntrl_mous_bttn', () => this.changeKeybinding('freeLook'));
	        menu.setupButton(this.chooseMarbleTexture, 'options/cntr_cam_up', async () => {
	            await this.showMarbleTexturePicker();
	            this.setResetMarbleTextureState(true);
	        });
	        menu.setupButton(this.resetMarbleTexture, 'options/cntr_cam_dwn', () => {
	            StorageManager.databaseDelete('keyvalue', 'marbleTexture');
	            this.setResetMarbleTextureState(false);
	        });
	        menu.setupButton(this.buttonRestartLevel, 'options/cntr_cam_dwn', () => this.changeKeybinding('restart'));
	        menu.setupButton(this.reflectiveMarbleCheckbox, 'options/cntrl_mous_freel', () => {
	            StorageManager.data.settings.marbleReflectivity = (!this.reflectiveMarbleCheckbox.hasAttribute('data-locked')) ? 2 : 0;
	            StorageManager.store();
	            // Toggle the checkbox
	            if (!this.reflectiveMarbleCheckbox.hasAttribute('data-locked')) {
	                this.reflectiveMarbleCheckbox.setAttribute('data-locked', '');
	                this.reflectiveMarbleCheckbox.src = './assets/ui/options/cntrl_mous_freel_d.png';
	            }
	            else {
	                this.reflectiveMarbleCheckbox.removeAttribute('data-locked');
	                this.reflectiveMarbleCheckbox.src = './assets/ui/options/cntrl_mous_freel_h.png';
	            }
	        });
	    }
	    initProperties() {
	        this.div = document.querySelector('#options');
	        this.homeButton = document.querySelector('#options-home');
	        this.rebindDialog = document.querySelector('#rebind-dialog');
	        this.rebindConfirm = document.querySelector('#rebind-confirm');
	        this.rebindConfirmYes = document.querySelector('#rebind-confirm-yes');
	        this.rebindConfirmNo = document.querySelector('#rebind-confirm-no');
	        this.homeButtonSrc = 'options/mainm';
	        this.rebindConfirmYesSrc = 'common/yes';
	        this.rebindConfirmNoSrc = 'common/no';
	        this.tabGraphics = document.querySelector('#tab-graphics');
	        this.tabAudio = document.querySelector('#tab-audio');
	        this.tabControls = document.querySelector('#tab-controls');
	        this.graphicsDiv = document.querySelector('#options-graphics');
	        this.audioDiv = document.querySelector('#options-audio');
	        this.controlsDiv = document.querySelector('#options-controls');
	        this.resolution640 = document.querySelector('#graphics-640');
	        this.resolution800 = document.querySelector('#graphics-800');
	        this.resolution1024 = document.querySelector('#graphics-1024');
	        this.openGl = document.querySelector('#graphics-opengl');
	        this.direct3D = document.querySelector('#graphics-direct3d');
	        this.windowedButton = document.querySelector('#graphics-windowed');
	        this.fullButton = document.querySelector('#graphics-full');
	        this.depth16 = document.querySelector('#graphics-depth16');
	        this.depth32 = document.querySelector('#graphics-depth32');
	        this.shadowsCheckbox = document.querySelector('#graphics-shadows');
	        this.graphicsApply = document.querySelector('#graphics-apply');
	        this.musicVolumeTrack = document.querySelector('#audio-music-track');
	        this.musicVolumeKnob = document.querySelector('#audio-music-knob');
	        this.soundVolumeTrack = document.querySelector('#audio-sound-track');
	        this.soundVolumeKnob = document.querySelector('#audio-sound-knob');
	        this.controlsBackground = document.querySelector('#controls-background');
	        this.marbleTab = document.querySelector('#tab-marble'); // it's not
	        this.cameraTab = document.querySelector('#tab-camera');
	        this.mouseTab = document.querySelector('#tab-mouse');
	        this.marbleControlsDiv = document.querySelector('#controls-marble');
	        this.cameraControlsDiv = document.querySelector('#controls-camera');
	        this.mouseControlsDiv = document.querySelector('#controls-mouse');
	        this.buttonMarbleLeft = document.querySelector('#button-marble-left');
	        this.buttonMarbleRight = document.querySelector('#button-marble-right');
	        this.buttonMarbleUp = document.querySelector('#button-marble-up');
	        this.buttonMarbleDown = document.querySelector('#button-marble-down');
	        this.buttonMarbleUse = document.querySelector('#button-marble-use');
	        this.buttonMarbleJump = document.querySelector('#button-marble-jump');
	        this.buttonMarbleLeftContent = document.querySelector('#button-marble-left-content');
	        this.buttonMarbleRightContent = document.querySelector('#button-marble-right-content');
	        this.buttonMarbleUpContent = document.querySelector('#button-marble-up-content');
	        this.buttonMarbleDownContent = document.querySelector('#button-marble-down-content');
	        this.buttonMarbleUseContent = document.querySelector('#button-marble-use-content');
	        this.buttonMarbleJumpContent = document.querySelector('#button-marble-jump-content');
	        this.buttonCameraLeft = document.querySelector('#button-camera-left');
	        this.buttonCameraRight = document.querySelector('#button-camera-right');
	        this.buttonCameraUp = document.querySelector('#button-camera-up');
	        this.buttonCameraDown = document.querySelector('#button-camera-down');
	        this.buttonCameraLeftContent = document.querySelector('#button-camera-left-content');
	        this.buttonCameraRightContent = document.querySelector('#button-camera-right-content');
	        this.buttonCameraUpContent = document.querySelector('#button-camera-up-content');
	        this.buttonCameraDownContent = document.querySelector('#button-camera-down-content');
	        this.mouseSensitivityKnob = document.querySelector('#sensitivity-knob');
	        this.invertY = document.querySelector('#invert-y');
	        this.alwaysFreeLook = document.querySelector('#always-free-look');
	        this.freeLookKey = document.querySelector('#free-look-key');
	        this.freeLookKeyContent = document.querySelector('#free-look-key-content');
	        this.chooseMarbleTexture = document.querySelector('#graphics-marble-texture-choose');
	        this.resetMarbleTexture = document.querySelector('#graphics-marble-texture-reset');
	        this.buttonRestartLevel = document.querySelector('#button-restart-level');
	        this.buttonRestartLevelContent = document.querySelector('#button-restart-level-content');
	        this.reflectiveMarbleCheckbox = document.querySelector('#graphics-reflective-marble');
	    }
	    show() {
	        super.show();
	        this.updateAllElements();
	    }
	    async init() {
	        super.init();
	        this.setupTab(this.tabGraphics, 'graphics');
	        this.setupTab(this.tabAudio, 'audio');
	        this.setupTab(this.tabControls, 'controls');
	        // Default selection
	        this.selectControlsTab('marble');
	        this.selectTab('graphics');
	        await ResourceManager.loadImages(['cntrl_marb_bse.png', 'cntrl_cam_bse.png', 'cntrl_mous_base.png'].map(x => './assets/ui/options/' + x));
	        await this.updateAllElements();
	    }
	    async updateAllElements() {
	        this.selectResolutionButton([this.resolution640, this.resolution800, this.resolution1024][StorageManager.data.settings.resolution], StorageManager.data.settings.resolution);
	        this.selectVideoDriverButton([this.openGl, this.direct3D][StorageManager.data.settings.videoDriver], StorageManager.data.settings.videoDriver);
	        this.selectScreenStyleButton([this.windowedButton, this.fullButton][StorageManager.data.settings.screenStyle], StorageManager.data.settings.videoDriver);
	        this.selectColorDepthButton([this.depth16, this.depth32][StorageManager.data.settings.colorDepth], StorageManager.data.settings.colorDepth);
	        this.musicVolumeKnob.style.left = Math.floor(this.musicVolumeKnobLeft + StorageManager.data.settings.musicVolume * this.trackLength) + 'px';
	        this.soundVolumeKnob.style.left = Math.floor(this.soundVolumeKnobLeft + StorageManager.data.settings.soundVolume * this.trackLength) + 'px';
	        this.mouseSensitivityKnob.style.left = Math.floor(this.mouseSensitivityKnobLeft + StorageManager.data.settings.mouseSensitivity * this.trackLength) + 'px';
	        this.refreshKeybindings();
	        if (!!(StorageManager.data.settings.invertMouse & 0b10) !== this.invertY.hasAttribute('data-locked'))
	            this.invertY.click();
	        if (StorageManager.data.settings.alwaysFreeLook !== this.alwaysFreeLook.hasAttribute('data-locked'))
	            this.alwaysFreeLook.click();
	        if ((StorageManager.data.settings.marbleReflectivity === 2) !== this.reflectiveMarbleCheckbox.hasAttribute('data-locked'))
	            this.reflectiveMarbleCheckbox.click();
	        this.setResetMarbleTextureState(!((await StorageManager.databaseCount('keyvalue', 'marbleTexture')) === 0));
	    }
	    selectTab(which) {
	        for (let elem of [this.tabGraphics, this.tabAudio, this.tabControls]) {
	            elem.style.zIndex = "-1";
	        }
	        for (let elem of [this.graphicsDiv, this.audioDiv, this.controlsDiv]) {
	            elem.classList.add('hidden');
	        }
	        let index = ['graphics', 'audio', 'controls'].indexOf(which);
	        let elem = [this.tabGraphics, this.tabAudio, this.tabControls][index];
	        elem.style.zIndex = "0";
	        [this.graphicsDiv, this.audioDiv, this.controlsDiv][index].classList.remove('hidden');
	    }
	    setupTab(element, which) {
	        element.addEventListener('mousedown', (e) => {
	            if (e.button !== 0)
	                return;
	            mainAudioManager.play('buttonpress.wav');
	        });
	        element.addEventListener('click', (e) => e.button === 0 && this.selectTab(which));
	    }
	    selectResolutionButton(button, index) {
	        this.unlockResolutionButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager.data.settings.resolution = index;
	        StorageManager.store();
	    }
	    unlockResolutionButtons() {
	        // Deselect all resolution buttons
	        this.resolution640.src = './assets/ui/options/graf640_n.png';
	        this.resolution640.removeAttribute('data-locked');
	        this.resolution800.src = './assets/ui/options/graf800_n.png';
	        this.resolution800.removeAttribute('data-locked');
	        this.resolution1024.src = './assets/ui/options/graf1024_n.png';
	        this.resolution1024.removeAttribute('data-locked');
	    }
	    selectVideoDriverButton(button, index) {
	        this.unlockVideoDriverButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager.data.settings.videoDriver = index;
	        StorageManager.store();
	    }
	    unlockVideoDriverButtons() {
	        // Deselect all video driver buttons
	        this.openGl.src = './assets/ui/options/grafopgl_n.png';
	        this.openGl.removeAttribute('data-locked');
	        this.direct3D.src = './assets/ui/options/grafdir3d_n.png';
	        this.direct3D.removeAttribute('data-locked');
	    }
	    selectScreenStyleButton(button, index) {
	        this.unlockScreenStyleButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager.data.settings.screenStyle = index;
	        StorageManager.store();
	    }
	    unlockScreenStyleButtons() {
	        // Deselect all screen style buttons
	        this.windowedButton.src = './assets/ui/options/grafwindo_n.png';
	        this.windowedButton.removeAttribute('data-locked');
	        this.fullButton.src = './assets/ui/options/grafful_n.png';
	        this.fullButton.removeAttribute('data-locked');
	    }
	    selectColorDepthButton(button, index) {
	        this.unlockColorDepthButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager.data.settings.colorDepth = index;
	        StorageManager.store();
	    }
	    unlockColorDepthButtons() {
	        // Deselect all color depth buttons
	        this.depth16.src = './assets/ui/options/graf16bt_n.png';
	        this.depth16.removeAttribute('data-locked');
	        this.depth32.src = './assets/ui/options/graf32bt_n.png';
	        this.depth32.removeAttribute('data-locked');
	    }
	    async updateSliders() {
	        requestAnimationFrame(() => this.updateSliders());
	        if (this.div.classList.contains('hidden'))
	            return;
	        // Updates all sliders based on mouse position.
	        if (this.draggingMusicVolume) {
	            let leftStart = this.div.getBoundingClientRect().left * SCALING_RATIO + this.musicVolumeKnobLeft;
	            let completion = Util.clamp(((currentMousePosition.x - 12) - leftStart) / this.trackLength, 0, 1);
	            this.musicVolumeKnob.style.left = Math.floor(this.musicVolumeKnobLeft + completion * this.trackLength) + 'px';
	            StorageManager.data.settings.musicVolume = completion;
	            mainAudioManager.updateVolumes();
	        }
	        if (this.draggingSoundVolume) {
	            let leftStart = this.div.getBoundingClientRect().left * SCALING_RATIO + this.soundVolumeKnobLeft;
	            let completion = Util.clamp(((currentMousePosition.x - 12) - leftStart) / this.trackLength, 0, 1);
	            this.soundVolumeKnob.style.left = Math.floor(this.soundVolumeKnobLeft + completion * this.trackLength) + 'px';
	            StorageManager.data.settings.soundVolume = completion;
	            mainAudioManager.updateVolumes();
	            if (!this.soundTestingSound) {
	                this.soundTestingSound = mainAudioManager.createAudioSource('testing.wav');
	                this.soundTestingSound.setLoop(true);
	                this.soundTestingSound.play();
	            }
	        }
	        if (this.draggingMouseSensitivity) {
	            let leftStart = this.div.getBoundingClientRect().left * SCALING_RATIO + this.mouseSensitivityKnobLeft;
	            let completion = Util.clamp(((currentMousePosition.x - 12) - leftStart) / this.trackLength, 0, 1);
	            this.mouseSensitivityKnob.style.left = Math.floor(this.mouseSensitivityKnobLeft + completion * this.trackLength) + 'px';
	            StorageManager.data.settings.mouseSensitivity = completion;
	        }
	    }
	    selectControlsTab(which) {
	        for (let elem of [this.marbleControlsDiv, this.cameraControlsDiv, this.mouseControlsDiv]) {
	            elem.classList.add('hidden');
	        }
	        let index = ['marble', 'camera', 'mouse'].indexOf(which);
	        let elem = [this.marbleControlsDiv, this.cameraControlsDiv, this.mouseControlsDiv][index];
	        elem.classList.remove('hidden');
	        this.controlsBackground.src = './assets/ui/options/' + ['cntrl_marb_bse.png', 'cntrl_cam_bse.png', 'cntrl_mous_base.png'][index];
	        if (which === 'mouse') {
	            // The mouse background is sized differently and requires its own transform
	            this.controlsBackground.style.left = '2px';
	            this.controlsBackground.style.top = '-1px';
	        }
	        else {
	            this.controlsBackground.style.left = '';
	            this.controlsBackground.style.top = '';
	        }
	    }
	    refreshKeybindings() {
	        this.buttonMarbleLeftContent.textContent = this.formatKeybinding('left');
	        this.buttonMarbleRightContent.textContent = this.formatKeybinding('right');
	        this.buttonMarbleUpContent.textContent = this.formatKeybinding('up');
	        this.buttonMarbleDownContent.textContent = this.formatKeybinding('down');
	        this.buttonMarbleUseContent.textContent = this.formatKeybinding('use');
	        this.buttonMarbleJumpContent.textContent = this.formatKeybinding('jump');
	        this.buttonCameraLeftContent.textContent = this.formatKeybinding('cameraLeft');
	        this.buttonCameraRightContent.textContent = this.formatKeybinding('cameraRight');
	        this.buttonCameraUpContent.textContent = this.formatKeybinding('cameraUp');
	        this.buttonCameraDownContent.textContent = this.formatKeybinding('cameraDown');
	        this.freeLookKeyContent.textContent = this.formatKeybinding('freeLook');
	        this.buttonRestartLevelContent.textContent = this.formatKeybinding('restart');
	    }
	    setResetMarbleTextureState(enabled) {
	        if (enabled) {
	            this.resetMarbleTexture.style.pointerEvents = '';
	            this.resetMarbleTexture.style.filter = '';
	            document.querySelector('#graphics-marble-texture-reset-text').style.opacity = '';
	        }
	        else {
	            // Make it all grayed out and things
	            this.resetMarbleTexture.style.pointerEvents = 'none';
	            this.resetMarbleTexture.style.filter = 'saturate(0)';
	            this.resetMarbleTexture.src = './assets/ui/options/cntr_cam_dwn_n.png';
	            document.querySelector('#graphics-marble-texture-reset-text').style.opacity = '0.7';
	        }
	    }
	}

	class HelpScreen {
	    constructor(menu) {
	        this.initProperties();
	        menu.setupButton(this.homeButton, this.homeButtonSrc, () => {
	            // Close help and go back to the main menu
	            this.hide();
	            menu.home.show();
	        }, undefined, undefined, state.modification === 'gold');
	    }
	    async init() { }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	}

	/** A list describing all possible scenes that can be displayed in the help menu. */
	const sceneDescriptions = {
	    "startPad": [{
	            dtsPath: 'shapes/pads/startarea.dts',
	            distance: 6
	        }],
	    "endPad": [{
	            dtsPath: 'shapes/pads/endarea.dts',
	            distance: 6
	        }],
	    "gems": [{
	            dtsPath: 'shapes/items/gem.dts',
	            distance: 1.6,
	            translation: new Vector3(0.15, 0.1, 0.05),
	            matNamesOverride: { "base.gem": "purple.gem" }
	        },
	        {
	            dtsPath: 'shapes/items/gem.dts',
	            distance: 1.6,
	            translation: new Vector3(-0.2, 0, -0.2)
	        },
	        {
	            dtsPath: 'shapes/items/gem.dts',
	            distance: 1.6,
	            translation: new Vector3(0.15, 0, -0.55),
	            matNamesOverride: { "base.gem": "green.gem" }
	        }],
	    "superSpeed": [{
	            dtsPath: 'shapes/items/superspeed.dts',
	            distance: 2.5
	        }],
	    "superJump": [{
	            dtsPath: 'shapes/items/superjump.dts',
	            distance: 2.5,
	            translation: new Vector3(0, 0, -0.5)
	        }],
	    "shockAbsorber": [{
	            dtsPath: 'shapes/items/shockabsorber.dts',
	            distance: 2.5
	        }],
	    "superBounce": [{
	            dtsPath: 'shapes/items/superbounce.dts',
	            distance: 2.5
	        }],
	    "gyrocopter": [{
	            dtsPath: 'shapes/images/helicopter.dts',
	            distance: 2.5,
	            translation: new Vector3(0, 0, -0.4)
	        }],
	    "timeTravel": [{
	            dtsPath: 'shapes/items/timetravel.dts',
	            distance: 2.5
	        }],
	    "gravityModifier": [{
	            dtsPath: 'shapes/items/antigravity.dts',
	            distance: 2.5
	        }],
	    "ductFan": [{
	            dtsPath: 'shapes/hazards/ductfan.dts',
	            distance: 3.2
	        }],
	    "tornado": [{
	            dtsPath: 'shapes/hazards/tornado.dts',
	            distance: 10,
	            translation: new Vector3(0, 0, -6)
	        }],
	    "trapDoor": [{
	            dtsPath: 'shapes/hazards/trapdoor.dts',
	            distance: 5,
	            translation: new Vector3(0, 0, 0.8)
	        }],
	    "bumper": [{
	            dtsPath: 'shapes/bumpers/pball_round.dts',
	            distance: 1.3,
	            translation: new Vector3(0, 0, -0.15)
	        }],
	    "mine": [{
	            dtsPath: 'shapes/hazards/landmine.dts',
	            distance: 1.3,
	            translation: new Vector3(0, 0, -0.1)
	        }],
	    "oilslick": [{
	            dtsPath: 'shapes/hazards/oilslick.dts',
	            distance: 7
	        }]
	};
	class MbgHelpScreen extends HelpScreen {
	    constructor(menu) {
	        super(menu);
	        // Retrieve a list all of pages from the HTML
	        this.pages = [...document.querySelectorAll('.help-page')];
	        this.helpCanvas = document.createElement('canvas');
	        /** A renderer used to render small icons of shapes in the help screen. */
	        this.helpRenderer = new Renderer({ canvas: this.helpCanvas, alpha: true, desynchronized: false });
	        this.helpCamera = new PerspectiveCamera(40, 1);
	        this.scenes = new Map();
	        this.shapes = new Map();
	        menu.setupButton(this.prevButton, 'play/prev', () => this.cyclePage(-1));
	        menu.setupButton(this.nextButton, 'play/next', () => this.cyclePage(1));
	        this.showHelpPage(0);
	        requestAnimationFrame(() => this.update());
	        this.helpRenderer.setSize(80, 80);
	        let rot = new Quaternion().setFromRotationMatrix(new Matrix4().makeRotationX(1.1));
	        this.helpCamera.orientation.premultiply(rot);
	        window.addEventListener('keydown', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'Escape') {
	                this.homeButton.src = './assets/ui/play/back_d.png';
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'Escape') {
	                this.homeButton.click();
	            }
	        });
	    }
	    initProperties() {
	        this.div = document.querySelector('#help');
	        this.homeButton = document.querySelector('#help-back');
	        this.homeButtonSrc = 'play/back';
	        this.prevButton = document.querySelector('#help-prev');
	        this.nextButton = document.querySelector('#help-next');
	    }
	    show() {
	        super.show();
	        this.initHelpScenes();
	        this.showHelpPage(0);
	    }
	    cyclePage(direction) {
	        let index = this.pages.indexOf(this.currentPage);
	        index = Util.adjustedMod(index + direction, this.pages.length);
	        this.showHelpPage(index);
	    }
	    showHelpPage(index) {
	        for (let page of this.pages) {
	            page.classList.add('hidden');
	        }
	        this.pages[index].classList.remove('hidden');
	        this.currentPage = this.pages[index];
	        // Scan the paragraph
	        let paragraph = this.currentPage.querySelector('.help-paragraph');
	        if (paragraph) {
	            for (let element of paragraph.children) {
	                let buttonAttribute = element.getAttribute('data-button'); // This element represents a keybinding, we need to replace its content based on what key the user has bound
	                // Automatically replace the content with the correct value for the button
	                if (buttonAttribute) {
	                    let str = Util.getKeyForButtonCode(StorageManager.data.settings.gameButtonMapping[buttonAttribute]);
	                    element.textContent = str;
	                }
	            }
	        }
	    }
	    async update() {
	        requestAnimationFrame(this.update.bind(this));
	        if (this.div.classList.contains('hidden'))
	            return;
	        let now = performance.now();
	        let canvasRows = this.currentPage.querySelectorAll('.help-canvas-row');
	        // Update all shapes in the current page
	        for (let row of canvasRows) {
	            let canvas = row.children[0];
	            let sceneName = canvas.getAttribute('data-scene'); // The name of the scene to show is stored in this attribute
	            let scene = this.scenes.get(sceneName);
	            if (!(scene === null || scene === void 0 ? void 0 : scene.compiled))
	                continue;
	            // Select the correct scene
	            let shapeArr = this.shapes.get(sceneName);
	            for (let shape of shapeArr) {
	                let euler = new Euler(0, 0, now / 3000 * Math.PI);
	                shape.group.orientation.setFromEuler(euler);
	                shape.group.recomputeTransform();
	            }
	            // Render the scene
	            this.helpCamera.updateMatrixWorld();
	            scene.prepareForRender(this.helpCamera);
	            this.helpRenderer.render(scene, this.helpCamera);
	            // Copy it to the other canvas
	            let ctx = canvas.getContext('2d');
	            ctx.clearRect(0, 0, 80, 80);
	            ctx.drawImage(this.helpCanvas, 0, 0);
	        }
	    }
	    async initHelpScenes() {
	        if (this.scenes.size > 0)
	            return;
	        let timeState = { timeSinceLoad: 0, currentAttemptTime: 0, gameplayClock: 0, physicsTickCompletion: 0, tickIndex: 0 };
	        // Create all scenes and shapes
	        for (let key in sceneDescriptions) {
	            let scene = new Scene(this.helpRenderer);
	            let description = sceneDescriptions[key];
	            let arr = [];
	            for (let shapeDescription of description) {
	                let shape = new Shape();
	                shape.dtsPath = shapeDescription.dtsPath;
	                if (shapeDescription.matNamesOverride)
	                    shape.matNamesOverride = shapeDescription.matNamesOverride;
	                arr.push(shape);
	            }
	            this.scenes.set(key, scene);
	            this.shapes.set(key, arr);
	        }
	        // Init the shapes
	        let promises = [];
	        for (let [, shapeArr] of this.shapes) {
	            for (let shape of shapeArr)
	                promises.push(shape.init());
	        }
	        await Promise.all(promises);
	        let lookVector = new Vector3(0, 0, -1);
	        lookVector.applyQuaternion(this.helpCamera.orientation);
	        // Construct the scenes and set transforms
	        for (let [key, scene] of this.scenes) {
	            let shapeArr = this.shapes.get(key);
	            for (let i = 0; i < shapeArr.length; i++) {
	                let shape = shapeArr[i];
	                let description = sceneDescriptions[key][i];
	                let position = lookVector.clone().multiplyScalar(description.distance);
	                if (description.translation)
	                    position.add(description.translation);
	                shape.setTransform(position, new Quaternion(), new Vector3(1, 1, 1));
	                shape.render(timeState);
	                scene.add(shape.group);
	            }
	            // A simple ambient light will do
	            let light = new AmbientLight(new Vector3().setScalar(1));
	            scene.addAmbientLight(light);
	            scene.compile();
	        }
	    }
	}

	class MbgHud extends Hud {
	    constructor() {
	        super(...arguments);
	        this.gemCountMinDigits = 2;
	        this.showClockBackground = false;
	        this.supportNumberColors = false;
	        this.supportFpsMeter = false;
	    }
	}

	class MbgPauseScreen extends PauseScreen {
	    initProperties() {
	        this.div = document.querySelector('#pause-screen');
	        this.yesButton = document.querySelector('#pause-yes');
	        this.noButton = document.querySelector('#pause-no');
	        this.restartButton = document.querySelector('#pause-restart');
	        this.replayButton = document.querySelector('#pause-replay');
	        this.yesSrc = 'common/yes';
	        this.noSrc = 'common/no';
	        this.restartSrc = 'common/restart';
	    }
	    constructor(menu) {
	        super(menu);
	        this.replayButton.addEventListener('click', async (e) => {
	            if (e.button !== 0)
	                return;
	            this.onReplayButtonClick(e.altKey);
	        });
	        Util.onLongTouch(this.replayButton, () => this.onReplayButtonClick(true));
	    }
	}

	class FinishScreen {
	    constructor(menu) {
	        this.initProperties();
	        menu.setupButton(this.replayButton, 'endgame/replay', () => {
	            // Restart the level
	            this.div.classList.add('hidden');
	            state.level.restart(true);
	            if (!Util.isTouchDevice)
	                Util.requestPointerLock();
	        });
	        menu.setupButton(this.continueButton, 'endgame/continue', () => state.level.stopAndExit());
	        menu.setupButton(this.nameEntryButton, this.nameEntryButtonSrc, async () => {
	            let trimmed = this.nameEntryInput.value.trim().slice(0, 16);
	            if (trimmed.length < 2) {
	                state.menu.showAlertPopup('Warning', "Please enter a proper name for usage in the online leaderboard.");
	                return;
	            }
	            if (Util.isNaughty(trimmed)) {
	                state.menu.showAlertPopup('Warning', "The name you chose contains words deemed inappropriate. Please do the right thing and choose a non-offensive name.");
	                return;
	            }
	            StorageManager.data.lastUsedName = trimmed;
	            StorageManager.store();
	            // Store the time and close the dialog.
	            let level = state.level;
	            let inserted = StorageManager.insertNewTime(level.mission.path, trimmed, level.finishTime.gameplayClock);
	            this.nameEntryScreenDiv.classList.add('hidden');
	            this.div.style.pointerEvents = '';
	            this.drawBestTimes();
	            if (inserted) {
	                // Store the replay
	                if (level.replay.mode === 'record' && !level.replay.isInvalid) {
	                    level.replay.canStore = false;
	                    let serialized = await level.replay.serialize();
	                    await StorageManager.databasePut('replays', serialized, inserted.score[2]);
	                }
	            }
	            // Submit the score to the leaderboard if it's qualified
	            if (level.finishTime.gameplayClock <= level.mission.qualifyTime) {
	                Leaderboard.submitScore(level.mission.path, inserted.score);
	            }
	        }, undefined, undefined, state.modification === 'gold');
	        window.addEventListener('keydown', (e) => {
	            if (!state.level)
	                return;
	            if (state.menu !== menu)
	                return;
	            if (e.key === 'Enter') {
	                if (!this.nameEntryScreenDiv.classList.contains('hidden')) {
	                    this.nameEntryButton.src = menu.uiAssetPath + this.nameEntryButtonSrc + '_d.png';
	                }
	                else if (!this.div.classList.contains('hidden')) {
	                    this.continueButton.src = menu.uiAssetPath + 'endgame/continue_d.png';
	                }
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (!state.level)
	                return;
	            if (state.menu !== menu)
	                return;
	            if (e.key === 'Enter') {
	                if (!this.nameEntryScreenDiv.classList.contains('hidden')) {
	                    this.nameEntryButton.click();
	                }
	                else if (!this.div.classList.contains('hidden')) {
	                    this.continueButton.click();
	                }
	            }
	        });
	    }
	    get showing() {
	        return !this.div.classList.contains('hidden');
	    }
	    async init() {
	        for (let i = 0; i < this.bestTimeCount; i++) {
	            let element = this.createBestTimeElement();
	            this.bestTimeContainer.appendChild(element);
	        }
	    }
	    show() {
	        let level = state.level;
	        this.div.classList.remove('hidden');
	        let elapsedTime = Math.max(level.finishTime.currentAttemptTime - GO_TIME, 0);
	        let bonusTime = Util.roundToMultiple(Math.max(0, elapsedTime - level.finishTime.gameplayClock), 1e-8); // Fix 4999 bullshit
	        let failedToQualify = false;
	        // Change the message based on having achieve gold time, qualified time or not having qualified.
	        if (level.finishTime.gameplayClock > level.mission.qualifyTime) {
	            this.showMessage('failed');
	            failedToQualify = true;
	        }
	        else if (level.finishTime.gameplayClock <= level.mission.ultimateTime) {
	            this.showMessage('ultimate');
	        }
	        else if (level.finishTime.gameplayClock <= level.mission.goldTime) {
	            this.showMessage('gold');
	        }
	        else {
	            this.showMessage('qualified');
	        }
	        this.updateTimeElements(elapsedTime, bonusTime, failedToQualify);
	        this.drawBestTimes();
	        let bestTimes = StorageManager.getBestTimesForMission(level.mission.path, this.bestTimeCount, this.scorePlaceholderName);
	        let place = bestTimes.filter((time) => time[1] <= level.finishTime.gameplayClock).length; // The place is determined by seeing how many scores there currently are faster than the achieved time.
	        if (place < this.bestTimeCount && (!failedToQualify || this.storeNotQualified)) {
	            // Prompt the user to enter their name
	            this.nameEntryScreenDiv.classList.remove('hidden');
	            this.nameEntryText.textContent = this.generateNameEntryText(place);
	            this.nameEntryInput.value = StorageManager.data.lastUsedName;
	            this.div.style.pointerEvents = 'none';
	            //nameEntryInput.select(); // Don't select, since we want to avoid renames for leaderboard consistency
	        }
	        else {
	            this.nameEntryScreenDiv.classList.add('hidden');
	            this.div.style.pointerEvents = '';
	        }
	        if (!failedToQualify && level.mission.type !== 'custom') {
	            let levelSelect = state.menu.levelSelect;
	            if (levelSelect.currentMission === level.mission)
	                levelSelect.cycleMission(1); // Cycle to that next level, but only if it isn't already selected
	        }
	        // Hide the replay button if the replay's invalid
	        this.viewReplayButton.style.display = level.replay.isInvalid ? 'none' : '';
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    /** Updates the best times. */
	    drawBestTimes() {
	        let bestTimes = StorageManager.getBestTimesForMission(state.level.mission.path, this.bestTimeCount, this.scorePlaceholderName);
	        for (let i = 0; i < this.bestTimeCount; i++) {
	            this.updateBestTimeElement(this.bestTimeContainer.children[i], bestTimes[i], i + 1);
	        }
	    }
	    async onViewReplayButtonClick(download) {
	        let level = state.level;
	        if (download) {
	            let serialized = await level.replay.serialize();
	            Replay.download(serialized, level.mission, false);
	            if (Util.isTouchDevice && Util.isInFullscreen())
	                state.menu.showAlertPopup('Downloaded', 'The .wrec has been downloaded.');
	        }
	        else {
	            let confirmed = await state.menu.showConfirmPopup('Confirm', `Do you want to start the replay for the last playthrough? This can be done only once if this isn't one of your top ${this.bestTimeCount} local scores.`);
	            if (!confirmed)
	                return;
	            level.replay.mode = 'playback';
	            this.replayButton.click();
	        }
	    }
	    handleGamepadInput() {
	        // If the finish screen is up, handle those buttons ...
	        if (!this.nameEntryScreenDiv.classList.contains('hidden')) {
	            if (isPressedByGamepad('jump') && getPressedFlag('jump')) {
	                resetPressedFlag('jump');
	                this.nameEntryButton.click();
	                mainAudioManager.play('buttonpress.wav');
	            }
	        }
	        else if (!this.div.classList.contains('hidden')) {
	            // Check for buttons
	            if (isPressedByGamepad('use') && getPressedFlag('use')) {
	                resetPressedFlag('use');
	                this.viewReplayButton.click();
	                mainAudioManager.play('buttonpress.wav');
	            }
	            if (isPressedByGamepad('jump') && getPressedFlag('jump')) {
	                resetPressedFlag('jump');
	                this.continueButton.click();
	                mainAudioManager.play('buttonpress.wav');
	                return;
	            }
	            if (isPressedByGamepad('restart') && getPressedFlag('restart')) {
	                resetPressedFlag('restart');
	                this.replayButton.click();
	                mainAudioManager.play('buttonpress.wav');
	            }
	        }
	    }
	}

	class MbgFinishScreen extends FinishScreen {
	    constructor(menu) {
	        super(menu);
	        this.viewReplayButton = document.querySelector('#finish-view-replay');
	        this.bestTimeCount = 3;
	        this.scorePlaceholderName = "Nardo Polo";
	        this.storeNotQualified = false;
	        this.viewReplayButton.addEventListener('click', async (e) => {
	            if (e.button !== 0)
	                return;
	            this.onViewReplayButtonClick(e.altKey);
	        });
	        Util.onLongTouch(this.viewReplayButton, () => this.onViewReplayButtonClick(true));
	        this.viewReplayButton.addEventListener('mouseenter', () => mainAudioManager.play('buttonover.wav'));
	        this.viewReplayButton.addEventListener('mousedown', () => mainAudioManager.play('buttonpress.wav'));
	    }
	    initProperties() {
	        this.div = document.querySelector('#finish-screen');
	        this.time = document.querySelector('#finish-screen-time-time');
	        this.message = document.querySelector('#finish-message');
	        this.qualifyTimeElement = document.querySelector('#finish-qualify-time');
	        this.goldTimeElement = document.querySelector('#finish-gold-time');
	        this.elapsedTimeElement = document.querySelector('#finish-elapsed-time');
	        this.bonusTimeElement = document.querySelector('#finish-bonus-time');
	        this.replayButton = document.querySelector('#finish-replay');
	        this.continueButton = document.querySelector('#finish-continue');
	        this.bestTimeContainer = document.querySelector('#finish-best-times');
	        this.nameEntryScreenDiv = document.querySelector('#name-entry-screen');
	        this.nameEntryText = document.querySelector('#name-entry-screen > p:nth-child(3)');
	        this.nameEntryInput = document.querySelector('#name-entry-input');
	        this.nameEntryButton = this.nameEntryScreenDiv.querySelector('#name-entry-confirm');
	        this.nameEntryButtonSrc = 'common/ok';
	    }
	    showMessage(type) {
	        this.message.style.color = '';
	        if (type === 'ultimate') {
	            // This message doesn't really exist in MBG, but can't hurt to add it here for completeness.
	            this.message.innerHTML = 'You beat the <span style="color: #fff700;">ULTIMATE</span> time!';
	        }
	        else if (type === 'gold') {
	            this.message.innerHTML = 'You beat the <span style="color: #fff700;">GOLD</span> time!';
	        }
	        else if (type === 'qualified') {
	            this.message.innerHTML = "You've qualified!";
	        }
	        else if (type === 'failed') {
	            this.message.innerHTML = "You failed to qualify!";
	            this.message.style.color = 'red';
	        }
	    }
	    updateTimeElements(elapsedTime, bonusTime, failedToQualify) {
	        let level = state.level;
	        this.time.textContent = Util.secondsToTimeString(level.finishTime.gameplayClock / 1000);
	        this.qualifyTimeElement.textContent = isFinite(level.mission.qualifyTime) ? Util.secondsToTimeString(level.mission.qualifyTime / 1000) : Util.secondsToTimeString(5999.999);
	        this.qualifyTimeElement.style.color = failedToQualify ? 'red' : '';
	        this.qualifyTimeElement.style.textShadow = failedToQualify ? '1px 1px 0px black' : '';
	        Util.monospaceNumbers(this.qualifyTimeElement);
	        let goldTime = level.mission.goldTime;
	        this.goldTimeElement.textContent = Util.secondsToTimeString(goldTime / 1000);
	        this.goldTimeElement.parentElement.style.display = (goldTime !== -Infinity) ? '' : 'none';
	        Util.monospaceNumbers(this.goldTimeElement);
	        this.elapsedTimeElement.textContent = Util.secondsToTimeString(elapsedTime / 1000);
	        this.bonusTimeElement.textContent = Util.secondsToTimeString(bonusTime / 1000);
	        Util.monospaceNumbers(this.elapsedTimeElement);
	        Util.monospaceNumbers(this.bonusTimeElement);
	    }
	    createBestTimeElement() {
	        let div = document.createElement('div');
	        div.innerHTML = '<p></p><p></p>';
	        div.classList.add('finish-row');
	        return div;
	    }
	    updateBestTimeElement(element, score, rank) {
	        let goldTime = state.level.mission.goldTime;
	        element.children[0].textContent = rank + '. ' + score[0];
	        element.children[1].textContent = Util.secondsToTimeString(score[1] / 1000);
	        Util.monospaceNumbers(element.children[1]);
	        element.children[1].style.color = (score[1] <= goldTime) ? '#fff700' : '';
	        element.children[1].style.textShadow = (score[1] <= goldTime) ? '1px 1px 0px black' : '';
	    }
	    generateNameEntryText(place) {
	        return `You got the ${['best', '2nd best', '3rd best'][place]} time!`;
	    }
	}

	class MbgMenu extends Menu {
	    constructor() {
	        super(...arguments);
	        this.audioAssetPath = './assets/data/sound/';
	        this.menuMusicSrc = 'shell.ogg';
	        this.popupBackgroundSrc = './assets/ui/common/dialog.png';
	        this.popupOkaySrc = 'common/ok';
	        this.popupNoSrc = 'common/no';
	        this.popupYesSrc = 'common/yes';
	    }
	    get uiAssetPath() {
	        return './assets/ui/';
	    }
	    createHome() {
	        return new MbgHomeScreen(this);
	    }
	    createLevelSelect() {
	        return new MbgLevelSelect(this);
	    }
	    createLoadingScreen() {
	        return new MbgLoadingScreen(this);
	    }
	    createOptionsScreen() {
	        return new MbgOptionsScreen(this);
	    }
	    createHelpScreen() {
	        return new MbgHelpScreen(this);
	    }
	    createHud() {
	        return new MbgHud(this);
	    }
	    createPauseScreen() {
	        return new MbgPauseScreen(this);
	    }
	    createFinishScreen() {
	        return new MbgFinishScreen(this);
	    }
	    getMenuDiv() {
	        return document.querySelector('#menu');
	    }
	    getBackgroundImage() {
	        return document.querySelector('#background-image');
	    }
	    async init() {
	        if (Util.isWeeb) {
	            this.backgroundImage.src = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	        }
	        await super.init();
	    }
	}

	const MBP_GOLD_COLOR = 'rgb(255, 204, 0)';
	const MBP_PLATINUM_COLOR = 'rgb(204, 204, 204)';
	const MBP_ULTIMATE_COLOR = 'rgb(255, 221, 34)';
	class MbpFinishScreen extends FinishScreen {
	    constructor(menu) {
	        super(menu);
	        this.viewReplayButton = document.querySelector('#mbp-finish-view-replay');
	        this.timeRows = document.querySelector('#mbp-finish-time-rows');
	        this.nextLevelImage = document.querySelector('#mbp-finish-next-level-image');
	        this.nextLevelButton = document.querySelector('#mbp-finish-next-level');
	        this.bestTimeCount = 5;
	        this.scorePlaceholderName = "Matan W.";
	        this.storeNotQualified = true;
	        menu.setupButton(this.viewReplayButton, 'play/replay', (e) => this.onViewReplayButtonClick(e.altKey));
	        Util.onLongTouch(this.viewReplayButton, () => this.onViewReplayButtonClick(true));
	        this.qualifyTimeElement = this.createTimeRow('Par Time').children[0];
	        this.goldTimeElement = this.createTimeRow('Gold Time').children[0];
	        this.platinumTimeElement = this.createTimeRow('Platinum Time').children[0];
	        this.ultimateTimeElement = this.createTimeRow('Ultimate Time').children[0];
	        this.elapsedTimeElement = this.createTimeRow('Time Passed').children[0];
	        this.bonusTimeElement = this.createTimeRow('Clock Bonuses').children[0];
	        this.goldTimeElement.parentElement.style.color = 'rgb(255, 204, 0)';
	        this.platinumTimeElement.parentElement.style.color = 'rgb(204, 204, 204)';
	        this.ultimateTimeElement.parentElement.style.color = 'rgb(255, 221, 34)';
	        this.elapsedTimeElement.parentElement.style.marginTop = '20px';
	        menu.setupButton(this.nextLevelButton, 'endgame/level_window', () => {
	            let nextLevel = this.getNextLevel();
	            let levelSelect = state.menu.levelSelect;
	            // Exit to level select and immediately load the next level
	            this.continueButton.click();
	            levelSelect.setMissionArray(nextLevel.array);
	            levelSelect.currentMissionIndex = nextLevel.index;
	            levelSelect.playCurrentMission();
	        }, undefined, undefined, false);
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-finish-screen');
	        this.time = document.querySelector('#mbp-finish-screen-time-time');
	        this.message = document.querySelector('#mbp-finish-message');
	        this.replayButton = document.querySelector('#mbp-finish-replay');
	        this.continueButton = document.querySelector('#mbp-finish-continue');
	        this.bestTimeContainer = document.querySelector('#mbp-finish-screen-top-times');
	        this.nameEntryScreenDiv = document.querySelector('#mbp-name-entry-screen');
	        this.nameEntryText = document.querySelector('#mbp-name-entry-screen > p:nth-child(3)');
	        this.nameEntryInput = document.querySelector('#mbp-name-entry-input');
	        this.nameEntryButton = this.nameEntryScreenDiv.querySelector('#mbp-name-entry-confirm');
	        this.nameEntryButtonSrc = 'endgame/ok';
	    }
	    createTimeRow(label) {
	        let row = document.createElement('p');
	        row.innerHTML = label + ':<span></span>';
	        this.timeRows.appendChild(row);
	        return row;
	    }
	    show() {
	        super.show();
	        let nextLevel = this.getNextLevel();
	        let sortedArray = [...nextLevel.array].sort(state.menu.levelSelect.currentSortFn);
	        let mission = sortedArray[nextLevel.index];
	        this.nextLevelImage.src = mission.getImagePath();
	    }
	    showMessage(type) {
	        this.message.style.color = '';
	        if (type === 'ultimate') {
	            this.message.innerHTML = `You beat the <span style="color: ${MBP_ULTIMATE_COLOR};">Ultimate</span> Time!`;
	        }
	        else if (type === 'gold') {
	            if (state.level.mission.modification === 'gold')
	                this.message.innerHTML = `You beat the <span style="color: ${MBP_GOLD_COLOR};">Gold</span> Time!`;
	            else
	                this.message.innerHTML = `You beat the <span style="color: ${MBP_PLATINUM_COLOR};">Platinum</span> Time!`;
	        }
	        else if (type === 'qualified') {
	            this.message.innerHTML = "You beat the Par Time!";
	        }
	        else {
	            this.message.innerHTML = "You didn't pass the Par Time!";
	            this.message.style.color = 'rgb(245, 85, 85)';
	        }
	    }
	    updateTimeElements(elapsedTime, bonusTime) {
	        let level = state.level;
	        this.time.textContent = Util.secondsToTimeString(level.finishTime.gameplayClock / 1000);
	        this.qualifyTimeElement.textContent = isFinite(level.mission.qualifyTime) ? Util.secondsToTimeString(level.mission.qualifyTime / 1000) : Util.secondsToTimeString(5999.999);
	        Util.monospaceNumbers(this.qualifyTimeElement);
	        let goldTime = level.mission.goldTime;
	        this.goldTimeElement.parentElement.style.display = 'none';
	        this.platinumTimeElement.parentElement.style.display = 'none';
	        if (goldTime !== -Infinity) {
	            if (level.mission.modification === 'gold') {
	                this.goldTimeElement.textContent = Util.secondsToTimeString(goldTime / 1000);
	                this.goldTimeElement.parentElement.style.display = '';
	                Util.monospaceNumbers(this.goldTimeElement);
	            }
	            else {
	                this.platinumTimeElement.textContent = Util.secondsToTimeString(goldTime / 1000);
	                this.platinumTimeElement.parentElement.style.display = '';
	                Util.monospaceNumbers(this.platinumTimeElement);
	            }
	        }
	        let ultimateTime = level.mission.ultimateTime;
	        this.ultimateTimeElement.parentElement.style.display = 'none';
	        if (ultimateTime !== -Infinity) {
	            this.ultimateTimeElement.textContent = Util.secondsToTimeString(ultimateTime / 1000);
	            this.ultimateTimeElement.parentElement.style.display = '';
	            Util.monospaceNumbers(this.ultimateTimeElement);
	        }
	        this.elapsedTimeElement.textContent = Util.secondsToTimeString(elapsedTime / 1000);
	        this.bonusTimeElement.textContent = Util.secondsToTimeString(bonusTime / 1000);
	        Util.monospaceNumbers(this.elapsedTimeElement);
	        Util.monospaceNumbers(this.bonusTimeElement);
	    }
	    createBestTimeElement() {
	        let div = document.createElement('div');
	        return div;
	    }
	    updateBestTimeElement(element, score, rank) {
	        let goldTime = state.level.mission.goldTime;
	        let ultimateTime = state.level.mission.ultimateTime;
	        let tmp = document.createElement('div');
	        tmp.textContent = Util.secondsToTimeString(score[1] / 1000);
	        Util.monospaceNumbers(tmp);
	        element.innerHTML = `<div><span>${rank}. </span>${Util.htmlEscape(score[0])}</div><div>${tmp.innerHTML}</div>`;
	        element.style.color = '';
	        if (score[1] <= goldTime)
	            element.style.color = (state.level.mission.modification === 'gold') ? MBP_GOLD_COLOR : MBP_PLATINUM_COLOR;
	        if (score[1] <= ultimateTime)
	            element.style.color = MBP_ULTIMATE_COLOR;
	    }
	    generateNameEntryText(place) {
	        return `You have the ${['top', 'second top', 'third top', 'fourth top', 'fifth top'][place]} time!`;
	    }
	    /** Figures out what the next level after this one should be. */
	    getNextLevel() {
	        let levelSelect = state.menu.levelSelect;
	        let currIndex = levelSelect.sortedMissionArray.indexOf(state.level.mission); // Get it like this because the index might have already changed
	        if (currIndex < levelSelect.currentMissionArray.length - 1) {
	            // Just the next level in the current array
	            return {
	                index: currIndex + 1,
	                array: levelSelect.currentMissionArray
	            };
	        }
	        else {
	            if (levelSelect.currentMission.type === 'custom')
	                return {
	                    // We stay at the last custom level
	                    index: currIndex,
	                    array: levelSelect.currentMissionArray
	                };
	            else {
	                // Move on to the next mission array
	                let next = MissionLibrary.allCategories[MissionLibrary.allCategories.indexOf(levelSelect.currentMissionArray) + 1];
	                return {
	                    index: 0,
	                    array: next
	                };
	            }
	        }
	    }
	}

	class MbpLevelSelect extends LevelSelect {
	    constructor() {
	        super(...arguments);
	        this.loadReplayButton = document.querySelector('#mbp-load-replay-button');
	        this.shuffleButton = document.querySelector('#mbp-shuffle-button');
	        this.viewToggleButton = document.querySelector('#mbp-level-select-view-toggle');
	        this.metadataContainer = document.querySelector('#mbp-level-metadata');
	        this.scoresContainer = document.querySelector('#mbp-level-scores');
	        this.easterEggIcon = document.querySelector('#mbp-level-select-egg');
	        this.difficultySelectorCollapsed = document.querySelector('#mbp-difficulty-selector-collapsed');
	        this.difficultySelectorModificationIcon = document.querySelector('#mbp-difficulty-selector-modification-icon');
	        this.difficultySelectorWindow = document.querySelector('#mbp-difficulty-selector-window');
	        this.difficultySelectorContent = document.querySelector('#mbp-difficulty-selector-window > ._content');
	        this.localScoresCount = 5;
	        this.scorePlaceholderName = "Matan W.";
	        this.scoreElementHeight = 16;
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-level-select');
	        this.homeButton = document.querySelector('#mbp-level-select-home-button');
	        this.homeButtonSrc = 'play/menu';
	        this.prevButton = document.querySelector('#mbp-level-select-prev');
	        this.playButton = document.querySelector('#mbp-level-select-play');
	        this.nextButton = document.querySelector('#mbp-level-select-next');
	        this.levelImage = document.querySelector('#mbp-level-image');
	        this.levelTitle = document.querySelector('#mbp-level-title');
	        this.levelArtist = document.querySelector('#mbp-level-artist');
	        this.levelDescription = document.querySelector('#mbp-level-description');
	        this.levelQualifyTime = document.querySelector('#mbp-level-qualify-time');
	        this.localBestTimesContainer = document.querySelector('#mbp-level-select-local-best-times');
	        this.leaderboardLoading = document.querySelector('#mbp-online-leaderboard-loading');
	        this.leaderboardScores = document.querySelector('#mbp-leaderboard-scores');
	        this.scrollWindow = document.querySelector('#mbp-level-select-text-window');
	        this.searchInput = document.querySelector('#mbp-search-input');
	        this.sortToggleButton = document.querySelector('#mbp-sort-icon');
	    }
	    async init() {
	        await super.init();
	        this.menu.setupVaryingButton(this.difficultySelectorCollapsed, [
	            'play/difficulty_beginner', 'play/difficulty_intermediate', 'play/difficulty_advanced', 'play/difficulty_expert', 'play/difficulty_custom'
	        ], () => {
	            if (this.difficultySelectorWindow.classList.contains('hidden')) {
	                this.difficultySelectorWindow.classList.remove('hidden');
	            }
	            else {
	                this.difficultySelectorWindow.classList.add('hidden');
	            }
	        }, undefined, undefined, false);
	        this.createDifficultySection('Gold', './assets/ui_mbp/play/marble_gold.png', [
	            { name: 'Beginner', arr: MissionLibrary.goldBeginner },
	            { name: 'Intermediate', arr: MissionLibrary.goldIntermediate },
	            { name: 'Advanced', arr: MissionLibrary.goldAdvanced },
	            { name: 'Custom', arr: MissionLibrary.goldCustom }
	        ]);
	        this.createDifficultySection('Platinum', './assets/ui_mbp/play/marble_platinum.png', [
	            { name: 'Beginner', arr: MissionLibrary.platinumBeginner },
	            { name: 'Intermediate', arr: MissionLibrary.platinumIntermediate },
	            { name: 'Advanced', arr: MissionLibrary.platinumAdvanced },
	            { name: 'Expert', arr: MissionLibrary.platinumExpert },
	            { name: 'Custom', arr: MissionLibrary.platinumCustom }
	        ]);
	        this.createDifficultySection('Ultra', './assets/ui_mbp/play/marble_ultra.png', [
	            { name: 'Beginner', arr: MissionLibrary.ultraBeginner },
	            { name: 'Intermediate', arr: MissionLibrary.ultraIntermediate },
	            { name: 'Advanced', arr: MissionLibrary.ultraAdvanced },
	            { name: 'Custom', arr: MissionLibrary.ultraCustom }
	        ]);
	        this.difficultySelectorWindow.querySelector('._click-preventer').addEventListener('mousedown', () => {
	            mainAudioManager.play('buttonpress.wav');
	        });
	        this.difficultySelectorWindow.querySelector('._click-preventer').addEventListener('click', () => {
	            this.difficultySelectorWindow.classList.add('hidden');
	        });
	        // Button toggles between metadata and scores screen
	        this.menu.setupVaryingButton(this.viewToggleButton, ['mp/play/scoresactive', 'mp/play/settingsactive'], () => {
	            if (this.scoresContainer.classList.contains('hidden')) {
	                this.metadataContainer.classList.add('hidden');
	                this.scoresContainer.classList.remove('hidden');
	                this.levelQualifyTime.classList.add('hidden');
	                this.scrollWindow.style.height = '';
	                this.menu.setButtonVariant(this.viewToggleButton, 1);
	                this.viewToggleButton.title = "Show level information";
	            }
	            else {
	                this.metadataContainer.classList.remove('hidden');
	                this.scoresContainer.classList.add('hidden');
	                this.levelQualifyTime.classList.remove('hidden');
	                this.scrollWindow.style.height = '150px';
	                this.menu.setButtonVariant(this.viewToggleButton, 0);
	                this.viewToggleButton.title = "Show scores";
	            }
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.loadReplayButton, 'play/replay', (e) => {
	            this.showLoadReplayPrompt(e);
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.shuffleButton, 'search/random', () => {
	            this.shuffle();
	        }, undefined, undefined, false);
	        // Preload images and leaderboards
	        for (let category of MissionLibrary.allCategories) {
	            this.setMissionArray(category, false); // Make sure to disable the image timeouts so that no funky stuff happens
	        }
	        // Show a random beginner category at the start
	        this.setMissionArray(Util.randomFromArray([MissionLibrary.goldBeginner, MissionLibrary.platinumBeginner, MissionLibrary.ultraBeginner]), false);
	        await ResourceManager.loadImages(['play/eggnotfound.png', 'play/eggfound.png', 'play/marble_gold.png', 'play/marble_platinum.png', 'play/marble_ultra.png', 'mp/menu/brown/joined.png', 'mp/menu/brown/divider-orange-joined.png', 'options/textentry.png'].map(x => './assets/ui_mbp/' + x));
	    }
	    /** Creates a vertical section for the difficulty picker. */
	    createDifficultySection(title, img, difficulties) {
	        let div = document.createElement('div');
	        let header = document.createElement('p');
	        let icon = document.createElement('img');
	        div.classList.add('_section');
	        div.append(header, icon);
	        header.textContent = title;
	        icon.src = img;
	        for (let difficulty of difficulties) {
	            let container = document.createElement('div');
	            let nameElement = document.createElement('p');
	            let buttonElement = document.createElement('img');
	            container.append(nameElement, buttonElement);
	            div.append(container);
	            nameElement.textContent = difficulty.name;
	            this.menu.setupButton(buttonElement, 'play/difficulty_highlight-120', () => {
	                this.setMissionArray(difficulty.arr);
	                this.difficultySelectorWindow.classList.add('hidden');
	            });
	            if (!difficulty.arr) {
	                container.style.opacity = '0.333';
	                container.style.pointerEvents = 'none';
	            }
	        }
	        this.difficultySelectorContent.append(div);
	    }
	    setMissionArray(arr, doImageTimeout) {
	        super.setMissionArray(arr, doImageTimeout);
	        if (arr.length > 0) {
	            // Make sure to update the difficulty picker accordingly
	            this.menu.setButtonVariant(this.difficultySelectorCollapsed, ['beginner', 'intermediate', 'advanced', 'expert', 'custom'].indexOf(MissionLibrary.getDifficulty(arr)));
	            this.difficultySelectorModificationIcon.src = "./assets/ui_mbp/play/" + ((MissionLibrary.getModification(arr) === 'gold') ? "marble_gold.png" : (MissionLibrary.getModification(arr) === 'ultra') ? "marble_ultra.png" : "marble_platinum.png");
	        }
	        this.updateBackground();
	    }
	    displayMetadata() {
	        let mission = this.currentMission;
	        this.levelTitle.textContent = `#${this.currentMissionIndex + 1}: ${mission.title}`;
	        this.levelArtist.textContent = 'Author: ' + mission.artist.trim();
	        this.levelDescription.textContent = mission.description;
	        let qualifyTime = (mission.qualifyTime !== 0) ? mission.qualifyTime : Infinity;
	        this.levelQualifyTime.innerHTML = `<span style="opacity: 0.8;">${mission.modification === 'gold' ? 'Qualify' : 'Par'} Time: </span>` + (isFinite(qualifyTime) ? Util.secondsToTimeString(qualifyTime / 1000) : 'N/A');
	        if (mission.hasEasterEgg) {
	            this.easterEggIcon.classList.remove('hidden');
	            this.easterEggIcon.src = StorageManager.data.collectedEggs.includes(mission.path) ? './assets/ui_mbp/play/eggfound.png' : './assets/ui_mbp/play/eggnotfound.png';
	        }
	        else {
	            this.easterEggIcon.classList.add('hidden');
	        }
	    }
	    displayEmptyMetadata() {
	        this.levelTitle.innerHTML = '<br>';
	        this.levelArtist.innerHTML = '<br>';
	        this.levelDescription.innerHTML = '<br>';
	        this.levelQualifyTime.innerHTML = '';
	        this.easterEggIcon.classList.add('hidden');
	    }
	    createScoreElement(getReplayData) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-level-select-best-time');
	        let name = document.createElement('div');
	        element.appendChild(name);
	        let time = document.createElement('div');
	        element.appendChild(time);
	        element.appendChild(this.createReplayButton(getReplayData));
	        return element;
	    }
	    getReplayButtonForScoreElement(element) {
	        return element.children[2];
	    }
	    updateScoreElement(element, score, rank) {
	        element.children[0].innerHTML = `<span>${rank}.</span> ${Util.htmlEscape(score[0])}`;
	        element.children[1].textContent = Util.secondsToTimeString(score[1] / 1000);
	        Util.monospaceNumbers(element.children[1]);
	        element.style.color = '';
	        if (!this.currentMission)
	            return;
	        if (score[1] <= this.currentMission.goldTime)
	            element.style.color = (this.currentMission.modification === 'gold') ? MBP_GOLD_COLOR : MBP_PLATINUM_COLOR;
	        if (score[1] <= this.currentMission.ultimateTime)
	            element.style.color = MBP_ULTIMATE_COLOR;
	    }
	    show() {
	        super.show();
	        this.updateBackground();
	    }
	    /** Sets the background image based on the modification. */
	    updateBackground() {
	        let arr = this.currentMissionArray;
	        state.menu.backgroundImage.src =
	            (MissionLibrary.getModification(arr) === 'gold') ? state.menu.mbgBg :
	                (MissionLibrary.getModification(arr) === 'ultra') ? state.menu.mbuBg :
	                    state.menu.mbpBg;
	    }
	}

	class MbpHomeScreen extends HomeScreen {
	    constructor(menu) {
	        super(menu);
	        this.onlineButton = document.querySelector('#mbp-home-online'); // Doesn't do anything yet :)
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-home-screen');
	        this.playButton = document.querySelector('#mbp-home-play');
	        this.optionsButton = document.querySelector('#mbp-home-options');
	        this.helpButton = document.querySelector('#mbp-home-help');
	        this.exitButton = document.querySelector('#mbp-home-quit');
	        this.showChangelogButton = document.querySelector('#mbp-show-changelog');
	        this.changelogContainer = document.querySelector('#mbp-changelog');
	        this.changelogBackButton = document.querySelector('#mbp-changelog-back');
	        this.changelogContent = document.querySelector('#mbp-changelog-content');
	        this.version = document.querySelector('#mbp-version');
	        this.playSrc = 'menu/play';
	        this.optionsSrc = 'menu/options';
	        this.helpSrc = 'menu/help';
	        this.exitSrc = 'menu/quit';
	        this.showChangelogSrc = 'menu/changelog';
	        this.changelogBackSrc = 'motd/ok';
	    }
	    show() {
	        super.show();
	        state.menu.backgroundImage.src = state.menu.homeBg;
	    }
	}

	class MbpLoadingScreen extends LoadingScreen {
	    constructor() {
	        super(...arguments);
	        this.maxProgressBarWidth = 219;
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-loading');
	        this.levelNameElement = document.querySelector('#mbp-loading-level-name');
	        this.cancelButton = document.querySelector('#mbp-loading-cancel');
	        this.progressBar = document.querySelector('#mbp-loading-progress');
	    }
	}

	/** The page files to load and show, ordered. */
	const PAGES = ['webport', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22'];
	const FORMAT_COMMAND_REGEX = /<.+?>/g; // Literally the cheapest thing ever
	const ANCHOR_REGEX = /&lt;a:(.+?)&gt;(.+?)&lt;\/a&gt;/g; // Looks a bit shitty 'cuz of escaped HTML stuff
	class MbpHelpScreen extends HelpScreen {
	    constructor() {
	        super(...arguments);
	        this.pagePicker = document.querySelector('#mbp-help-picker');
	        this.pageElements = [];
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-help');
	        this.homeButton = document.querySelector('#mbp-help-home');
	        this.homeButtonSrc = 'manual/home';
	    }
	    /** Fetches all the pages for this help page. */
	    async init() {
	        let promises = [];
	        for (let page of PAGES) {
	            let path = `./assets/ui_mbp/manual/pages/${page}.txt`;
	            promises.push(ResourceManager.loadResource(path));
	        }
	        let blobs = await Promise.all(promises);
	        let texts = await Promise.all(blobs.map(x => ResourceManager.readBlobAsText(x)));
	        // For each text, create the necessary elements
	        for (let text of texts) {
	            let heading = text.slice(0, text.indexOf('\n')); // The title of each page is its first line
	            let selector = document.createElement('div');
	            selector.textContent = heading;
	            selector.addEventListener('mousedown', () => this.selectPage(texts.indexOf(text)));
	            this.pagePicker.appendChild(selector);
	            let pageElement = document.createElement('div');
	            pageElement.classList.add('_page', 'hidden');
	            pageElement.innerHTML = this.generatePageHtml(text);
	            this.pageElements.push(pageElement);
	            this.div.appendChild(pageElement);
	        }
	        this.selectPage(0);
	    }
	    selectPage(index) {
	        for (let child of this.pagePicker.children)
	            child.classList.remove('selected');
	        this.pagePicker.children[index].classList.add('selected');
	        for (let page of this.pageElements)
	            page.classList.add('hidden');
	        this.pageElements[index].classList.remove('hidden');
	        this.pageElements[index].scrollTop = 0;
	    }
	    /** Turns a subset of TorqueML into HTML. */
	    generatePageHtml(text) {
	        let currentStyle = ''; // The current style used for inserted text
	        let styleStack = []; // Stores previous styles so they can be reverted to
	        let html = '';
	        let heading = text.slice(0, text.indexOf('\n'));
	        let headingElement = document.createElement('h1');
	        headingElement.textContent = heading;
	        html += headingElement.outerHTML;
	        text = text.slice(text.indexOf('\n') + 1);
	        while (true) {
	            FORMAT_COMMAND_REGEX.lastIndex = 0;
	            let nextCommand;
	            while (nextCommand = FORMAT_COMMAND_REGEX.exec(text)) {
	                // Check if the command is a supported one
	                if (nextCommand[0].startsWith('<just') || nextCommand[0].startsWith('<font') || nextCommand[0] === '<spush>' || nextCommand[0] === '<spop>')
	                    break;
	            }
	            let div = document.createElement('div');
	            if (currentStyle)
	                div.setAttribute('style', currentStyle);
	            if (!nextCommand) {
	                // There is no more command found, so dump the remaining text
	                div.textContent = text;
	                if (div.innerHTML)
	                    html += div.outerHTML;
	                break;
	            }
	            div.textContent = text.slice(0, nextCommand.index);
	            if (div.innerHTML)
	                html += div.outerHTML;
	            // Update the text style based on the command
	            if (nextCommand[0].startsWith('<just')) {
	                // Add text align to the style
	                currentStyle += 'text-align: ' + nextCommand[0].slice(6, -1) + ';';
	            }
	            else if (nextCommand[0].startsWith('<font')) {
	                // Add a font family change to the style
	                let font = nextCommand[0].slice(6, nextCommand[0].lastIndexOf(':'));
	                let size = nextCommand[0].slice(nextCommand[0].lastIndexOf(':') + 1, -1);
	                currentStyle += `font-family: ${font};font-size: ${size}px;`;
	            }
	            else if (nextCommand[0] === '<spush>') {
	                // Push the current style to the stack
	                styleStack.push(currentStyle);
	            }
	            else if (nextCommand[0] === '<spop>') {
	                // Pop the last style from the stack into the current style
	                currentStyle = styleStack.pop();
	            }
	            text = text.slice(nextCommand.index + nextCommand[0].length);
	        }
	        // Make links clickable
	        html = html.replace(ANCHOR_REGEX, '<a href="http://$1" target="_blank">$2</a>');
	        return html;
	    }
	}

	const BACKGROUNDS = {
	    'gold': 12,
	    'platinum': 28,
	    'ultra': 9,
	    'multi': 13
	};
	class MbpMenu extends Menu {
	    constructor() {
	        super(...arguments);
	        this.audioAssetPath = './assets/data_mbp/sound/';
	        this.menuMusicSrc = 'music/pianoforte.ogg';
	        this.popupBackgroundSrc = './assets/ui_mbp/play/text_window.png';
	        this.popupOkaySrc = 'achiev/close';
	        this.popupNoSrc = 'exit/no';
	        this.popupYesSrc = 'exit/yes';
	    }
	    get uiAssetPath() {
	        return './assets/ui_mbp/';
	    }
	    createHome() {
	        return new MbpHomeScreen(this);
	    }
	    createLevelSelect() {
	        return new MbpLevelSelect(this);
	    }
	    createLoadingScreen() {
	        return new MbpLoadingScreen(this);
	    }
	    createOptionsScreen() {
	        return new MbpOptionsScreen(this);
	    }
	    createHelpScreen() {
	        return new MbpHelpScreen(this);
	    }
	    createHud() {
	        return new MbpHud(this);
	    }
	    createPauseScreen() {
	        return new MbpPauseScreen(this);
	    }
	    createFinishScreen() {
	        return new MbpFinishScreen(this);
	    }
	    getMenuDiv() {
	        return document.querySelector('#mbp-menu');
	    }
	    getBackgroundImage() {
	        return document.querySelector('#mbp-background-image');
	    }
	    async init() {
	        // Preselect random backgrounds and load them
	        let homeCategory = Util.randomFromArray(Object.keys(BACKGROUNDS));
	        let homeIndex = Math.floor(Math.random() * BACKGROUNDS[homeCategory]) + 1;
	        let mbgIndex = Math.floor(Math.random() * BACKGROUNDS['gold']) + 1;
	        let mbpIndex = Math.floor(Math.random() * BACKGROUNDS['platinum']) + 1;
	        let mbuIndex = Math.floor(Math.random() * BACKGROUNDS['ultra']) + 1;
	        this.homeBg = './assets/ui_mbp/backgrounds/' + homeCategory + '/' + homeIndex + '.jpg';
	        this.mbgBg = './assets/ui_mbp/backgrounds/' + 'gold/' + mbgIndex + '.jpg';
	        this.mbpBg = './assets/ui_mbp/backgrounds/' + 'platinum/' + mbpIndex + '.jpg';
	        this.mbuBg = './assets/ui_mbp/backgrounds/' + 'ultra/' + mbuIndex + '.jpg';
	        if (Util.isWeeb) {
	            this.homeBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.mbgBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.mbpBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.mbuBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	        }
	        await ResourceManager.loadImages([this.homeBg, this.mbgBg, this.mbpBg, this.mbuBg]);
	        await super.init();
	    }
	}

	// I'm pissed. Had to put this in a separate file because Rollup is just too stupid to order stuff correctly.
	let mbgMenu;
	let mbpMenu;
	const switchingMessage = document.querySelector('#switching-message');
	/** Sets the menu to the given modification. */
	const setMenu = async (type) => {
	    var _a;
	    (_a = state.menu) === null || _a === void 0 ? void 0 : _a.hide();
	    if (state.menu)
	        switchingMessage.classList.remove('hidden');
	    document.querySelector('#favicon').setAttribute('href', (type === 'gold') ? "./assets/img/marble-blast-gold-logo.png" : "./assets/img/mbp.png");
	    if (type === 'gold') {
	        if (mbgMenu) {
	            // It already exists, show it immediately
	            state.modification = 'gold';
	            state.menu = mbgMenu;
	            mbgMenu.show();
	        }
	        else {
	            // We still need to create it
	            mbgMenu = new MbgMenu();
	            state.modification = 'gold';
	            state.menu = mbgMenu;
	            await mbgMenu.init();
	            if (mbpMenu)
	                mbgMenu.show();
	        }
	    }
	    else {
	        if (mbpMenu) {
	            // It already exists, show it immediately
	            state.modification = 'platinum';
	            state.menu = mbpMenu;
	            mbpMenu.show();
	        }
	        else {
	            // We still need to create it
	            mbpMenu = new MbpMenu();
	            state.modification = 'platinum';
	            state.menu = mbpMenu;
	            await mbpMenu.init();
	            if (mbgMenu)
	                mbpMenu.show();
	        }
	    }
	    switchingMessage.classList.add('hidden');
	    StorageManager.data.modification = type;
	    StorageManager.store();
	};

	const loadingMessage = document.querySelector('#loading-message');
	const loadingDetail = document.querySelector('#loading-detail');
	const startGameDialog = document.querySelector('#start-game-dialog');
	const init = async () => {
	    await Util.init();
	    await StorageManager.init();
	    await ResourceManager.init();
	    initMainRenderer();
	    loadingDetail.textContent = 'Loading levels...';
	    await MissionLibrary.init();
	    mainAudioManager.init();
	    loadingDetail.textContent = 'Loading UI...';
	    let searchParams = new URLSearchParams(location.search);
	    if (searchParams.has('mbg')) {
	        StorageManager.data.modification = 'gold';
	        StorageManager.store();
	    }
	    else if (searchParams.has('mbp')) {
	        StorageManager.data.modification = 'platinum';
	        StorageManager.store();
	    }
	    await setMenu(StorageManager.data.modification);
	    loadingDetail.textContent = 'Loading leaderboard...';
	    await Leaderboard.init();
	    if (Util.isWeeb)
	        document.title = 'Marble Blast Weeb'; // <- humor
	    // If we're on a touch device, remind the user that the site can be installed as a PWA
	    if (Util.isTouchDevice && !location.search.includes('app')) {
	        let div = document.createElement('div');
	        div.id = 'install-popup';
	        let img = document.createElement('img');
	        img.src = './assets/img/download.png';
	        img.style.display = 'none';
	        div.append(img);
	        img.addEventListener('click', () => {
	            installPromptEvent.prompt();
	        });
	        let intervalId = setInterval(() => {
	            if (installPromptEvent)
	                img.style.display = '';
	        }, 100);
	        state.menu.showAlertPopup('Install as app', `This website can be installed on your device's home screen to run in proper fullscreen and feel like a native app. To install it, press the icon below, or if there is none, follow <a href="https://natomasunified.org/kb/add-website-to-mobile-device-home-screen/" target="_blank">these</a> steps.`, div).then(() => {
	            clearInterval(intervalId);
	        });
	    }
	    let started = false;
	    const start = async () => {
	        started = true;
	        startGameDialog.style.display = 'none';
	        mainAudioManager.context.resume();
	        state.menu.show();
	        maybeLaunchLevelFromQueryParams(new URLSearchParams(window.location.search));
	    };
	    loadingMessage.style.display = 'none';
	    loadingDetail.style.display = 'none';
	    if (mainAudioManager.context.state === "running" && !Util.isSafari()) {
	        // Start the game automatically if we already have audio autoplay permission.
	        start();
	        return;
	    }
	    // Otherwise, we need user interaction to start audio.
	    if (Util.isInFullscreen() || Util.isTouchDevice) {
	        // No need to tell them to enter fullscreen if they're already in it
	        startGameDialog.children[0].textContent = 'Click anywhere to start';
	        startGameDialog.children[1].textContent = '';
	    }
	    else {
	        startGameDialog.children[0].textContent = `Press ${Util.isMac() ? '^⌘F' : 'F11'} to start in fullscreen mode`;
	    }
	    startGameDialog.style.display = 'block';
	    window.addEventListener('mousedown', () => {
	        if (started)
	            return;
	        start();
	    });
	    window.addEventListener('pointerdown', () => {
	        if (started)
	            return;
	        start();
	    });
	    window.addEventListener('keydown', (e) => {
	        if (started)
	            return;
	        if (e.code === 'F11' && !Util.isInFullscreen())
	            start();
	    });
	};
	window.onload = init;
	/** Launch a level from the query params */
	const maybeLaunchLevelFromQueryParams = async (urlParams) => {
	    // Check if we are using the ?play-custom={id} query param to launch the game directly into the specified mission
	    const playParam = urlParams.get('play-custom');
	    if (playParam === null)
	        return;
	    if (!Number.isInteger(parseInt(playParam)))
	        return;
	    const intParam = parseInt(playParam);
	    let missionToPlay = MissionLibrary.allMissions.find(x => x.id === intParam);
	    if (missionToPlay === undefined)
	        return;
	    if (state.modification === 'gold' && (missionToPlay.path.startsWith('mbp') || missionToPlay.path.startsWith('mbu'))) {
	        // Switch the menu to MBP
	        await setMenu('platinum');
	    }
	    state.menu.home.changelogContainer.classList.add('hidden'); // No need to show version history when directly launching into the mission
	    state.menu.home.hide();
	    state.menu.levelSelect.show();
	    state.menu.levelSelect.hide();
	    state.menu.loadingScreen.loadLevel(missionToPlay, undefined);
	};
	let errorTimeout = null;
	// Keep track all errors
	let errorQueue = [];
	window.addEventListener('error', (e) => {
	    errorQueue.push({
	        message: e.error.stack,
	        lineno: e.lineno,
	        colno: e.colno,
	        filename: e.filename
	    });
	    if (errorTimeout === null)
	        sendErrors();
	});
	window.addEventListener('unhandledrejection', (e) => {
	    errorQueue.push({
	        message: e.reason instanceof Error ? e.reason.stack : e.reason.toString(),
	        lineno: 0,
	        colno: 0,
	        filename: 'Unhandled in Promise'
	    });
	    if (errorTimeout === null)
	        sendErrors();
	});
	/** Sends an error report to the server. */
	const sendErrors = () => {
	    errorTimeout = null;
	    if (errorQueue.length === 0)
	        return;
	    let errors = [];
	    errorQueue.length = Math.min(errorQueue.length, 16); // Cap it at 16 errors, we don't wanna be sending too much
	    for (let event of errorQueue) {
	        errors.push({
	            message: event.message,
	            line: event.lineno,
	            column: event.colno,
	            filename: event.filename
	        });
	    }
	    errorQueue.length = 0;
	    if (errors.length > 0) {
	        fetch('./api/error', {
	            method: 'POST',
	            headers: {
	                'Content-Type': 'application/json'
	            },
	            body: JSON.stringify({
	                userAgent: navigator.userAgent,
	                errors: errors
	            })
	        });
	    }
	    // 5-second timeout until it's done again
	    errorTimeout = setTimeout(sendErrors, 5000);
	};
	const activityId = Util.getRandomId();
	setInterval(() => {
	    fetch('/api/activity?id=' + activityId);
	}, 30000);
	// Very basic Service Worker code here:
	if (navigator.serviceWorker) {
	    navigator.serviceWorker.register('/sw.js', {
	        scope: '/'
	    }).then(reg => {
	        reg.update();
	    }).catch(error => {
	        console.log('Service worker registration failed, error:', error);
	    });
	}
	let installPromptEvent = null;
	window.addEventListener('beforeinstallprompt', (e) => {
	    e.preventDefault();
	    installPromptEvent = e; // Save the prompt for later
	});

}());
})()
